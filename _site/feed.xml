<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-11-25T19:06:02+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">AI/Business Study Log</title><subtitle>NLP, Marketing</subtitle><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><entry><title type="html">📈 Gradient: Directional Derivative</title><link href="http://localhost:4000/optimization-theory/gradient" rel="alternate" type="text/html" title="📈 Gradient: Directional Derivative" /><published>2023-11-25T00:00:00+09:00</published><updated>2023-11-25T23:00:00+09:00</updated><id>http://localhost:4000/optimization-theory/gradient</id><content type="html" xml:base="http://localhost:4000/optimization-theory/gradient"><![CDATA[<h3 id="concept-of-gradient"><code class="language-plaintext highlighter-rouge">🤔 Concept of Gradient</code></h3>

<p>그라디언트는 다변수 함수의 기울기를 나타내는 벡터를 말한다. 그라디언트의 원소는 함수에 존재하는 모든 변수를 대상으로 편미분한 결과로 구성되는데, 예를 들어 변수가 $x_1, x_2$ 2개인 다변수 함수 $f(x_1, x_2)$가 있다고 가정해보자. 다변수 함수 $f$의 그라디언트는 아래 수식처럼 표현할 수 있다.</p>

\[f'(x_1, x_2) = \begin{vmatrix}
  \frac{∂f}{∂x_1} \\
  \frac{∂f}{∂x_2}
\end{vmatrix}\]

<p>이러한 그라디언트는 머신 러닝, 수치 최적화 학문에서 매우 중요한 개념으로 꼽힌다. 그라디언트 벡터가 가리키는 방향이 바로 다변수 함수가 특정 지점에서 가장 가파르게 증가하는 방향을 가리키기 때문이다. 이처럼 그라디언트는 함수의 입력 공간을 따라 함수가 어떻게 변화하는지를 알려주는 길잡이 역할을 하기 때문에, 그라디언트 방향을 따라 변수값을 튜닝하다 보면 함수의 최대값•최소값에 도달하여 최적화 문제를 해결할 수 있게 된다. 그렇다면 왜 그라디언트 벡터의 방향이 특정 지점에서 함수가 가장 가파르게 증가하는 방향을 나타내는 것일까?? 편미분, 도함수 정의 그리고 내적을 활용해 증명할 수 있다.</p>

<h3 id="-proof-of-gradient"><code class="language-plaintext highlighter-rouge">🪪 Proof of Gradient</code></h3>

<p align="center">
<img src="/assets/images/gradient/gradient.jpg" alt="Example of multivariate function" class="align-center image-caption" width="60%&quot;, height=&quot;25%" />
<strong><em><a href="https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=galaxyenergy&amp;logNo=221431325545">Example of multivariate function</a></em></strong>
</p>

<p>그라디언트 벡터의 방향이 함수가 가장 가파르게 증가하는 방향과 일치한다는 명제를 증명하기 위해 최단 경로로 산 정상에 오르는 과정을 떠올려보려 한다. 우리는 현재 이변수 함수로 정의되는 산 중턱 어딘가, 점 $(x_1^0, x_2^0)$를 지나고 있다. 산 정상을 최단 경로로 오르려면 어떻게 해야할까?? 가장 경사가 가파른 급경사 지대를 향해 나아가면 될 것이다. 하지만 산 중턱에 있는 우리가 어느 방향이 가장 가파른 급경사 지대인지 직관적으로 알 길이 없다. 그래서 방향 도함수를 도입해 급경사 지대로 향할 수 있는 방향을 구해 보기로 했다. 아래 수식을 보자.</p>

\[\lim_{\Delta{x}-&gt;0}\frac{f(x+\Delta{x}) - f(x)}{\Delta{x}} =    \frac{df}{dx}= f'(x) \\
df = f'(x)dx\]

<p>너무나도 익숙한 형태 아닌가?? 우리가 일반적으로 알고 있는 일변수 함수의 미분 정의 그리고 좌변의 $dx$를 우변으로 넘겨 살짝 변형한 식이다. 이것을 이제 다변수 함수에 적용하면 바로 방향 도함수가 된다. 다시 우리가 오르려는 산(이변수 함수)으로 돌아와 보자.</p>

\[f(x_1 + dx_1, x_2) = f(x_1, x_2) + f'(x_1, x_2)dx_1 \\
f(x_1, x_2 + dx_2) = f(x_1, x_2) + f'(x_1, x_2)dx_2 \\\]

<p>위에서 서술한 도함수 정의를 활용해 우리가 다음에 발걸음을 옮길 위치를 점  $A$를 $(x_1^0 + dx_1, x_2^0+dx_2)$ 이라고 표현할 수 있다. 이 표현을 활용해 다변수 함수의 미분을 정의해보자. 우리는 이미 다변수 함수의 개별 변수에 편미분을 취하고 행벡터로 쌓은 결과가 바로 전미분이라는 것을 알고 있다.</p>

\[f(x_1 + dx_1, x_2 + dx_2) - f(x_1, x_2) = f'(x_1)dx_1 + f'(x_2)dx_2\]

<p>다시 편미분의 정의를 활용해 수식을 정리하면 방향 벡터와 편미분 결과의 내적으로 표현할 수 있다.</p>

\[dL = \frac{∂L}{∂{x_1}}dx_1 + \frac{∂L}{∂{x_2}}dx_2 \\
dL = [dx_1, dx_2]\ •\ \begin{vmatrix}
  \frac{∂L}{∂x_1} \\
  \frac{∂L}{∂x_2}
\end{vmatrix}\]

<p>쏟아지는 수식 속에 우리의 본래 목적을 잊어서는 안된다. 우리는 지금 가장 빠르게 산 정상에 도달할 수 있는 방법을 찾기 위해 지금까지 달려왔다. 산 정상에 가장 빠르게 도달하기 위해 가장 가파른 급경사 지대만 찾아서 올라가는 전략을 세웠었다. 다시 말해, 다변수 함수 $f(x)$의 극소 변화량 $dL$이 최대가 되는 방향으로 발걸음을 옮기면 된다는 것이다. 그렇다면 극소 변화량 $dL$은 언제 최대가 될까??</p>

<p>이제 까먹고 있었던 내적의 개념을 다시 한 번 상기시켜보자. 내적은 다양하게 해석되지만, 본디 서로 다른 두 벡터의 <code class="language-plaintext highlighter-rouge">닮은 정도</code>를 나타낸다. 극소 변화량 $dL$이 최대가 되려면 우변의 내적 결과가 최대가 되어야 한다. 내적의 최대값은 서로 다른 두 벡터 사이의 끼인각도가 0˚일 때 즉, 두 벡터가 동일한 방향을 나타낼 때 정의된다. <strong><u>따라서 방향 벡터가 그라디언트(편미분의 행벡터) 방향일 때</u></strong> <code class="language-plaintext highlighter-rouge">내적 결과</code>(극소 변화량 $dL$)<strong><u>가 최대가 된다.</u></strong></p>

<p><strong><u>한편, 실제 기계학습에서는 손실함수의 최적화를 목적 함수로 사용하기 때문에 그라디언트(손실함수의 전미분) 방향에 음수를 취해준 값을 사용하게 된다.</u></strong></p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Optimization Theory" /><category term="Optimization Theory" /><category term="Calculus" /><category term="Partial Derivative" /><category term="Total Derivative" /><category term="loss function" /><category term="Gradient" /><category term="Gradient Descent" /><category term="Machine Learning" /><summary type="html"><![CDATA[Proof of gradient direction with Total Derivative]]></summary></entry><entry><title type="html">🔢 Eigen Decomposition</title><link href="http://localhost:4000/linear-algebra/eigen-decomposition" rel="alternate" type="text/html" title="🔢 Eigen Decomposition" /><published>2023-11-25T00:00:00+09:00</published><updated>2023-11-26T13:00:00+09:00</updated><id>http://localhost:4000/linear-algebra/eigen-decomposition</id><content type="html" xml:base="http://localhost:4000/linear-algebra/eigen-decomposition"><![CDATA[<p>고유값, 고유벡터, 고유값 분해는 비단 선형대수학뿐만 아니라 해석기하학 나아가 데이터 사이언스 전반에서 가장 중요한 개념 중 하나라고 생각한다. 머신러닝에서 자주 사용하는 여러 행렬 분해(Matrix Factorization) 기법(ex: <code class="language-plaintext highlighter-rouge">SVD</code>)과 <code class="language-plaintext highlighter-rouge">PCA</code>의 이론적 토대가 되므로 반드시 완벽하게 숙지하고 넘어가야 하는 파트다. 이번 포스팅 역시 <a href="https://www.youtube.com/watch?v=PP9VQXKvSCY&amp;t=108s&amp;ab_channel=%ED%98%81%ED%8E%9C%ED%95%98%EC%9E%84%7CAI%26%EB%94%A5%EB%9F%AC%EB%8B%9D%EA%B0%95%EC%9D%98"><strong><u>혁펜하임님의 선형대수학 강의</u></strong></a>와 <a href="https://www.youtube.com/watch?v=7dmV3p3Iy90&amp;ab_channel=%EA%B3%B5%EB%8F%8C%EC%9D%B4%EC%9D%98%EC%88%98%ED%95%99%EC%A0%95%EB%A6%AC%EB%85%B8%ED%8A%B8"><strong><u>공돌이의 수학정리님의 강의 및 포스트</u></strong></a> 그리고 <a href="https://product.kyobobook.co.kr/detail/S000001743773"><strong><u>딥러닝을 위한 선형대수학 교재</u></strong></a>을 참고하고 개인적인 해석을 더해 정리했다.</p>

<h3 id="concept-of-eigen-value--vector"><code class="language-plaintext highlighter-rouge">🌟 Concept of Eigen Value &amp; Vector</code></h3>

\[Av = \lambda v\]

<p>등식을 만족시키는 벡터 $v$를 <code class="language-plaintext highlighter-rouge">고유 벡터(Eigen Vector)</code>, 람다 $\lambda$를 <code class="language-plaintext highlighter-rouge">고유값(Eigen Value)</code>이라고 정의한다. 좌변의 $A$는 <code class="language-plaintext highlighter-rouge">선형 변환(행렬)</code>을 의미한다. 이러한 정보를 활용해 위 등식의 의미를 살펴보자. 어떤 선형변환 $A$와 벡터 $v$를 곱했더니, 어떤 스칼라와 벡터를 곱한 결과와 같았다는 것인데, 벡터에 스칼라를 곱하면 그 크기만 변화할 뿐 방향은 이전과 동일하다. 따라서 선형변환 $A$를 가해도 그 크기만 스칼라 배(고유값 배)만큼 변할뿐 방향은 동일한 벡터를 찾고자 하는게 위 수식의 목적이며 이게 바로 고유벡터의 정의가 된다.</p>

<p>그렇다면 수식을 풀어서 고유값과 고유벡터를 직접 구해보자. 먼저 좌변으로 모든 항을 넘긴 뒤, 고유 벡터 $v$로 좌변의 모든 항을 묶어준다.</p>

\[(A - \lambda I) v = 0\]

<p>고유 벡터 $v$로 묶어준다고만 했는데 왜 갑자기 람다 뒤에 항등행렬이 붙게 되었을까?? 람다는 고유값, 다시 말해 스칼라다. <code class="language-plaintext highlighter-rouge">행렬 - 스칼라</code>는 불가능하기 때문에 선형변환 $A$와 크기를 맞춰주기 위해 곱한 것이다. 다시 등식을 전체적인 관점에서 살펴보자. 지금 <code class="language-plaintext highlighter-rouge">행렬•벡터 = 0</code> 의 형태를 취하고 있다. 어디서 많이 본 듯한 꼴이 아닌가?? 바로 행렬의 영공간을 구할 때 사용하던 수식이다. 따라서 우리는 고유벡터 $v$가 좌측 괄호 안의 행렬 $A-\lambda I$의 영공간이 span하는 공간 어딘가에 위치했다는 것을 알 수 있다.</p>

<p>한편, 우리가 이 등식을 풀어헤친 목적은 고유값 그리고 고유벡터를 구하기 위함이다. 등식을 만족시키려면 고유벡터가 0이기만 하면 되겠지만, $v=0$인 경우를 찾자고 우리가 이렇게 고생하는 것은 당연히 아닐 것이다. 따라서 $v=0$이 아니라 좌측 괄호 안의 항 $A-\lambda I=0$이 되어야 한다. 이 때 $det(A-\lambda I) =0$를 만족해야 한다. 그 이유는 만약 행렬식이 0이 아니라면 역행렬이 존재한다는 것이 되고, 전체 등식에서 좌측 항에 대한 역행렬을 양변에 곱해주면 다시 $v=0$이라는 결과를 얻게 된다. 따라서 반드시 $det(A-\lambda I) =0$을 충족해 역행렬이 없도록 만들어야 한다.</p>

<p>따라서 결론적으로 우리는 두 가지 수식을 풀어내면 고유값과 고유벡터를 구할 수 있다.</p>

\[N(A-\lambda I) = V \\
det(A-\lambda I) = 0\]

<p>이 때, 영공간에 <code class="language-plaintext highlighter-rouge">span</code>하는 벡터는 무수히 많기 때문에 일반적으로 <code class="language-plaintext highlighter-rouge">Basis</code>를 고유값으로 간주한다.</p>

<h3 id="-eigen-decomposition"><code class="language-plaintext highlighter-rouge">🔢 Eigen Decomposition</code></h3>

\[A = V\Lambda V^{-1} \\
\Lambda = V^{-1}AV\]

<p>위 수식과 같은 형태로 임의의 정사각행렬 $A$를 표현 가능하다면, 우리는 이러한 행렬 $A$를 <code class="language-plaintext highlighter-rouge">Diagonalizable Matrix</code>라고 부르며, <code class="language-plaintext highlighter-rouge">Diagonalizable Matrix</code>를 고유벡터와 고유값 행렬로 분해하는 것을 <code class="language-plaintext highlighter-rouge">고유값 분해(Eidgen Decomposition)</code>라고 한다.</p>

<p>여기서 <code class="language-plaintext highlighter-rouge">Diagonalizable Matrix</code> 이란, 고유값 행렬을 이용해 대각행렬로 변환이 가능한 정사각행렬을 말한다. 두번째 수식이 바로 <code class="language-plaintext highlighter-rouge">Diagonalizable Matrix</code> 를 표현한 것이다. 어떤 행렬이 <code class="language-plaintext highlighter-rouge">Diagonalizable Matrix</code> 하다는 것은 다시 말해, 행렬에 <code class="language-plaintext highlighter-rouge">Independent</code>한 고유벡터가 N개 있다는 것과 동치다. 방금 서술한 사실을 유도해보자.</p>

<p>3X3 크기의 행렬 $A$와 서로 독립인 고유 벡터 $v_1, v_2, v_3$과 이에 대응되는 고유값 $\lambda_1, \lambda_2, \lambda_3$이 있다고 가정해보자. 여러개의 고유 벡터와 고유값을 수식 하나로 표현하기 위해 벡터화를 이용하고자 한다.</p>

\[A[v_1, v_2, v_3] = [v_1, v_2, v_3]•   \begin{bmatrix} 
   \lambda_1 &amp; 0 &amp; 0 \\
   0 &amp; \lambda_2 &amp; 0 \\
   0 &amp; 0 &amp; \lambda_3 \\
   \end{bmatrix} \\\]

<p>우리는 지금 어떤 행렬이 <code class="language-plaintext highlighter-rouge">Diagonalizable Matrix</code> 일 때 벌어지는 현상에 대해 증명하는게 목표라서 좌변에 행렬 $A$만 남기려고 한다. $[v_1, v_2, v_3]$ 은 서로 독립인 고유 벡터다. 그리고 사이즈는 3x3으로 정사각행렬에 해당된다. 열벡터가 서로 독립이면서 정사각행렬에 해당되기 때문에 $[v_1, v_2, v_3]$ 은 가역행렬의 조건을 모두 충족한다. 따라서 양변에 $[v_1, v_2, v_3]$ 의 역행렬을 곱해주자. 이제부터 편의상 $[v_1, v_2, v_3]$ 은 $V$,  고유값-대각행렬(우변 오른쪽 항) $\Lambda$로 표기하겠다.</p>

\[A = V\Lambda V^{-1} \\\]

<p>$V$가 <code class="language-plaintext highlighter-rouge">Independent</code>한 고유벡터가 N개를 갖고 있기 때문에 $V$를 일부분으로 갖고 있는 행렬 $A$는 당연히 <code class="language-plaintext highlighter-rouge">Independent</code>한 고유벡터가 N개 있다고 말할 수 있다.</p>

<h3 id="️-property-of-eigen-decomposition"><code class="language-plaintext highlighter-rouge">⭐️ Property of Eigen Decomposition</code></h3>

<p>고유값 분해가 가능한 <code class="language-plaintext highlighter-rouge">Diagonalizable Matrix</code> $A$의 속성에 대해 알아보자. 이런 속성들은 이후 <code class="language-plaintext highlighter-rouge">PCA</code>, <code class="language-plaintext highlighter-rouge">SVD</code>에서 사용되니 숙지하고 있는게 좋다.</p>

<ul>
  <li><strong>1) $A^k = V \Lambda V^{-1}•V \Lambda V^{-1} … = V \Lambda^k V^{-1}$</strong></li>
  <li><strong>2) $A^{-1} = (V \Lambda V^{-1})^{-1}$= $(V \Lambda^{-1} V^{-1})$</strong>
    <ul>
      <li>$AA^{-1}=I$</li>
    </ul>
  </li>
  <li><strong>3) $det(A) = det(V \Lambda V^{-1}) = det(V)det(\Lambda)det(V ^{-1}) = \prod_{i=1}^{N} {\lambda_i}$</strong>
    <ul>
      <li><strong>행렬식은 곱으로 쪼개는게 성립</strong></li>
    </ul>
  </li>
  <li><strong>4) $tr(A)=tr(V \Lambda V^{-1})=tr( \Lambda V^{-1}V)=tr(\Lambda)=\sum_i^{N}\lambda_i$</strong>
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">trace</code> 는 원소의 순서를 바꾸는거 허용</strong></li>
    </ul>
  </li>
  <li><strong>5) rank-difficient == $det(A)=0$ ⇒ 행렬 $A$에는 값이 0인 고유값이 적어도 하나 이상 존재</strong>
    <ul>
      <li><strong>3)번 속성 이용</strong></li>
    </ul>
  </li>
  <li><strong>6) Diagonalizable Matrix의 non-zero eidgen value 개수 == rank(A)</strong>
    <ul>
      <li>$rank(A) = rank(V \Lambda V^{-1}) = rank(\Lambda)$</li>
      <li>$V, V^{-1}$ <strong>은 서로 독립인 열벡터를 쌓아 만든 행렬이라서 반드시 Full Rank</strong></li>
      <li><strong>랭크의 성질에 의해 가장 작은 값이 행렬의 랭크가 된다</strong></li>
      <li><strong><code class="language-plaintext highlighter-rouge">non-zero eigen value 개수</code> ==</strong> $rank(\Lambda)$</li>
    </ul>
  </li>
</ul>

<h3 id="insight-of-eigen-decomposition"><code class="language-plaintext highlighter-rouge">💡 Insight of Eigen Decomposition</code></h3>

<p>이렇게 고유값, 고유벡터, 고유값 분해에 대해서 전반적으로 살펴보았다. 하지만 아직도 왜 고유값 분해가 그리도 중요하다는 것인지 아직 감이 오지 않을 것이다. 고유값 분해의 중요성에 대해 알아보기 위해 먼저 다음과 같은 명제에 대해서 증명해보자.</p>

<p><strong><em>“대칭행렬(Symmetric Matrix)은 대각화 가능한 행렬(Diagonalizable Matrix)이다”</em></strong></p>

\[V^T = V^{-1} = Q\]

<p>대칭행렬은 정사각행렬 중에서 원본과 전치행렬이 동일한($A=A^{T}$) 특수 행렬을 말한다. 따라서 어떤 행렬 $A$가 대칭행렬이라면, $V \Lambda V^{-1} = V^{-T} \Lambda V^{T}$가 된다. 각변의 가장 마지막 항에 주목해보자. 등식 조건에 의해 $V^{-1} = V^T$가 성립하기 때문에 행렬 $V$는 전치행렬과 역행렬이 같은 행렬이 된다. 다시 말해, $V$는 직교행렬 $Q$가 된다. 따라서 행렬 $A$에 대한 고유값 분해식을 아래처럼 직교행렬로 표현할 수 있다.</p>

\[A = Q \Lambda Q^{-1} \\
A = [q_1, q_2, q_3]•\begin{bmatrix} 
   \lambda_1 &amp; 0 &amp; 0 \\
   0 &amp; \lambda_2 &amp; 0 \\
   0 &amp; 0 &amp; \lambda_3 \\
   \end{bmatrix}•\begin{bmatrix} 
   q_1^T \\
   q_2^T \\
   q_3^T \\
   \end{bmatrix} \\\]

<p>이제 우변을 수식을 전개해서 그 의미를 알아보자. 전개하면 아래와 같다.</p>

\[A = \lambda_1q_1q_1^T + \lambda_2q_2q_2^T + \lambda_3q_3q_3^T\]

<p>우변의 항을 하나 하나 살펴보자. 세개의 항은 모두 개별 고유벡터에 대한 <code class="language-plaintext highlighter-rouge">고유값</code>, <code class="language-plaintext highlighter-rouge">고유벡터</code> 그리고 <code class="language-plaintext highlighter-rouge">고유벡터의 전치</code>에 대한 곱으로 구성되어 있다. 고유벡터와 그것의 전치벡터의 곱은 크기는 <code class="language-plaintext highlighter-rouge">nxn</code>이지만, 사실 같은 벡터를 두번 곱한 것과 같기에 랭크는 1이된다. 다시 말해, 3차원 공간에서 1차원 직선 공간으로 <code class="language-plaintext highlighter-rouge">span</code>하는 부분 공간이 3개가 만들어지며 3개의 부분 공간은 서로 독립이면서, 모두 근본이 직교 행렬의 열벡터라는 점 때문에 서로 직교한다. 따라서 우리는 대칭행렬 $A$를 크기는 <code class="language-plaintext highlighter-rouge">NxN</code>이면서 랭크는 <code class="language-plaintext highlighter-rouge">1</code>인 행렬 3개를 고유값을 이용해 <code class="language-plaintext highlighter-rouge">가중합 방식</code>으로 더한 것이라고 해석할 수 있다. 뒤집어 서술하면 대칭행렬 $A$를 크기는 <code class="language-plaintext highlighter-rouge">NxN</code>이면서 랭크는 <code class="language-plaintext highlighter-rouge">1</code>인 행렬 <code class="language-plaintext highlighter-rouge">3</code>개로 쪼개는 방식이 바로 <code class="language-plaintext highlighter-rouge">고유값 분해</code>이다.</p>

<p>고유값에 따라, 부분 공간의 크기를 조절할 수 있다는 점에서 차원 축소나 제거처럼 중요도가 높은 데이터•특징만 추출하는게 가능해진다. 이러한 고유값 분해를 정사각행렬(대칭행렬)이 아닌 일반적인 직사각행렬에도 적용할 수 있도록 개념을 확장한게 바로 <code class="language-plaintext highlighter-rouge">SVD(Singular Vector Decomposition)</code>이고, 중요도(고유값의 크기)에 따라서 중요한 특징•데이터만 남기는 방법론은 <code class="language-plaintext highlighter-rouge">PCA(Princlpal Component Analysis)</code>의 이론적 토대가 된다.</p>

<p>이렇게 대칭행렬은 대각화 가능한 행렬이라는 점을 통해 <code class="language-plaintext highlighter-rouge">고유값 분해</code>의 의미에 대해서 알아보았다. 이제 마지막으로 선형변환으로서 행렬 $A$가 갖는 의미를 살펴보자. 고유벡터가 아닌 임의의 벡터 $\vec x$를 선형변환 $A$에 통과시켜보자. 그럼 우리는 아래와 같은 식을 얻을 수 있다.</p>

\[A\vec x = \lambda_1q_1q_1^T•\vec x + \lambda_2q_2q_2^T•\vec x + \lambda_3q_3q_3^T•\vec x\]

<p>우변을 해석해보자. 아까 고유값 분해의 의미를 살펴보면서 $q_1q_1^T$는 전체 공간에서 1차원 직선 공간으로 span하는 부분 공간을 의미한다고 했었다. 따라서 우변에는 서로 다른 항이 3개 있기 때문에 부분 공간이 3개 있는 3차원 공간이 형성된다. 이제 부분 공간과 벡터 $\vec x$를 내적한 형태로 바라볼 수 있다. 내적은 정사영이다. 따라서 $q_nq_n^T•\vec x$은 벡터 $\vec x$를 부분 공간에 정사영 내려준 벡터가 된다. 그리고 고유값을 곱해 정사영 내린 벡터들의 크기를 조절해주는게 우변의 의미가 된다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Linear Algebra" /><category term="Linear Algebra" /><category term="Eigen Decomposition" /><category term="Eigen Vector" /><category term="Eigen Value" /><category term="SVD" /><category term="PCA" /><summary type="html"><![CDATA[💡 Concept of Eigen Decomposition]]></summary></entry><entry><title type="html">🍎 Newton-Raphson Method for Optimization</title><link href="http://localhost:4000/optimization-theory/newton-raphson" rel="alternate" type="text/html" title="🍎 Newton-Raphson Method for Optimization" /><published>2023-11-15T00:00:00+09:00</published><updated>2023-11-16T02:00:00+09:00</updated><id>http://localhost:4000/optimization-theory/newton_raphson</id><content type="html" xml:base="http://localhost:4000/optimization-theory/newton-raphson"><![CDATA[<h3 id="zero-find-ver"><code class="language-plaintext highlighter-rouge">🤔 Zero-Find Ver</code></h3>

<p>비선형 방정식의 근사해를 찾거나 최적화 문제를 해결하는 방식으로, 같은 과정을 반복해 최적값에 수렴한다는 점에서 경사하강법이랑 근본이 같다. 반면, 경사하강에 비해 빠른 수렴 속도를 자랑하고 풀이 방식이 매우 간단하다는 장점이 있다. 하지만 여러 제약 조건과 더불어 해당 알고리즘이 잘 작동하는 상황이 비현실적인 부분이 많아 경사하강에 비해 자주 사용되지는 않고 있다. 뉴턴-랩슨 방식은 근사해를 찾거나, 최적화 문제를 푸는 두 가지 버젼이 있는데 먼저 해를 찾는 버전부터 살펴보자. 알고리즘의 수식은 다음과 같다.</p>

\[x_{n+1}:= x_n - \frac{f(x_n)}{f'(x_n)}\]

<p>반복법을 사용하기 때문에 수식의 생김새가 상당히 경사하강법과 비슷하다. 왜 이런 수식이 등장하게 되었을까?? 일단 뉴턴-랩슨 방식의 풀이 과정을 살펴보자. 먼저 초기값을 설정한다. 그 다음 해당 점을 지나는 접선의 방정식을 세운다. 이제 접선의 방정식의 $x$절편을 구하고 이것을 다음 초기값으로 사용한다. 이제 $f(x_n) \approx 0$이 될 때까지 위 과정을 지속적으로 반복하면 된다. 아래 그래프와 함께 다시 살펴보자.</p>

<p align="center">
<img src="/assets/images/optimization/zero_find.png" alt="Newton-Raphson for Zero Find" class="align-center image-caption" width="60%&quot;, height=&quot;50%" />
<strong><em><a href="">Newton-Raphson for Zero Find</a></em></strong>
</p>

<p>초기값은 $x_0=3$이다. 시작점 $(x_0, f(x_0))$을 지나는 접선의 방정식을 세우고 해당 방정식의 $x$절편을 구하는 수식을 작성하면 아래와 같다.</p>

\[f'(x_0)(x-x_n) + f(x_0) = 0\]

<p>이제 이것을 예쁘게 잘 정리해서 다음 초기값 $x_1$을 구해보자.</p>

\[x = x_0 - \frac{f(x_0)}{f'(x_0)}\]

<p>이번 포스트 맨 처음에 봤던 뉴턴-랩슨 방법의 수식과 똑같다는 것을 알 수 있다. 다시 말해 뉴턴-랩슨의 Zero-Find 버전은 접선의 방정식의 $x$절편을 활용해 목적 함수의 해를 찾아가는 방식인 것이다.</p>

<p>지금까지 근사해를 찾아주는 뉴턴-랩슨 메서드를 살펴보았다. 하지만 머신러닝처럼 현실의 최적화 문제를 풀어야 하는 우리 입장에서는 단순 목적 함수의 근을 찾는 것만으로는 주어진 문제를 해결할 수 없다. 머신러닝의 최적화 대상인 비용 함수는 거의 모든 경우에 근이 없기(베이지안 오차까지 고려하면 사실상 불가능) 때문에 일단 알고리즘의 가정 자체가 성립하지 않는다. 이러한 한계점을 극복하고자 최적화 버전의 뉴턴-랩슨 메서드가 등장하게 된다.</p>

<h3 id="optimization-ver"><code class="language-plaintext highlighter-rouge">📉 Optimization Ver</code></h3>

\[x_{n+1}:= x_n - \frac{f'(x_n)}{f''(x_n)}\]

<p>최적화 버전의 뉴턴 랩슨 메서드는 이계도함수를 사용한다. 원함수(비용함수)가 근이 없을지라도, 함수의 극점이 존재하는한 도함수의 근은 항상 존재한다는 가정에서 출발한다. 근을 찾는 행위는 동일하게 하되, 이번에는 원함수의 근이 아니라 도함수의 근을 찾는다. 도함수의 근사해를 찾으면, 해당 위치는 국소/전역 최적값에 근접한 수치일 것이라고 기대해볼 수 있다.</p>

<p>하지만 최적화 버전의 뉴턴 랩슨 메서드 역시 여전히 많은 단점을 갖고 있다. 일단 먼저 계산량이 지나치게 많아진다. 예시를 모두 스칼라 형태로 들어서 간단해 보이지만, 다변수함수에 적용하면 과정이 매우 매우 복잡해진다. 모든 <code class="language-plaintext highlighter-rouge">iteration</code> 마다 자코비안, 헤시안 행렬을 구해줘야 한다. 도함수만 이용하는 경사 하강에 비해 연산 부담이 상당히 커질 수 밖에 없는 것이다. 그리고 결정적으로 헤시안 행렬이 <code class="language-plaintext highlighter-rouge">invertible</code> 해야한다. 이게 개인적으로 <code class="language-plaintext highlighter-rouge">뉴턴-랩슨</code> 방식의 가장 큰 단점이라고 생각한다. 헤시안 행렬의 역행렬이 존재하려면 반드시 원함수는 <code class="language-plaintext highlighter-rouge">Convex Function</code>이어야 하기 때문이다. 따라서 상당히 비현실적인 풀이 방식이라고 볼 수 있다.</p>

<p>한편, 위 모든 제약 조건을 만족한다면 최적화 버전의 뉴턴-랩슨 방식은 경사하강에 비해 상당히 빠른 수렴 속도를 갖는데 그 이유를 간단히 살펴보자. 결과부터 설명하면 뉴턴-랩슨 방식이 사실상 <code class="language-plaintext highlighter-rouge">Least Square Method(최소 자승법)</code> 와 동치라서 그렇다. 목적함수 $f(x)$를 <code class="language-plaintext highlighter-rouge">MSE</code> 로 두고 선형 회귀 문제를 푸는 상황을 가정해보자.</p>

\[Z = Ax+n \\
f(x) = (Z-Ax)^T(Z-Ax)\]

<p>목적함수를 정의했기 때문에 우리는 이제 목적함수의 도함수와 이계도함수를 구할 수 있다.</p>

\[f'(x) = -2A^T(Z-Ax)\\
f''(x) = 2A^tA\]

<p>도함수와 이계도 함수를 뉴턴—랩슨 수식에 대입하면 다음과 같다.</p>

\[x_{n+1} := x_n + \frac{A^T(Z-Ax)} {A^TA} = x_n + (A^TA)^{-1}A^T(Z-Ax)\]

<p>분모는 헤시안 행렬과 동치다. 행렬로 어떤 수를 나눌 수는 없기 때문에 나눗셈 표현 대신 역행렬로 표기했다. 그리고 수식이 상당히 더럽기 때문에 정리를 위해 전개를 해보려 한다. 전개 결과는 다음과 같다.</p>

\[x_{n+1} := x_n + (A^TA)^{-1}A^TZ - (A^TA)^{-1}A^TAx_n = (A^TA)^{-1}A^TZ\]

<p>헤시안 행렬이 <code class="language-plaintext highlighter-rouge">invertible</code> 해야한다라는 제약 조건이 여기서 등장한다. 만약 헤시안 행렬이 <code class="language-plaintext highlighter-rouge">invertible</code> 이라면, 다 날라가고 우변의 항만 남게 된다. 우변의 항을 자세히 살펴보면, <code class="language-plaintext highlighter-rouge">Least Square Method(최소 자승법)</code> 의 수식과 동일하다는 것을 알 수 있다. 경사하강과는 다르게 $x_n$과 관련된 항이 수식에 전혀 남아있지 않기 때문에, 최소 자승법 수식을 한 번 풀어내는 것만으로 극점에 도달하여 수렴속도가 훨씬 빠르게 되는 것이다.</p>

<p align="center">
<img src="/assets/images/optimization/gd_nr_1.png" alt="Newton-Raphson for Optimization" class="align-center image-caption" width="60%&quot;, height=&quot;50%" />
<strong><em><a href="">Newton-Raphson for Optimization</a></em></strong>
</p>

<p>두 방식이 최적화 문제를 풀어나가는 과정을 비교하기 위해 시각화를 시도해봤다. 필자의 시각화 실력이 매우 좋지 못해 그 차이가 직관적으로 잘 안보인다… 빨간 직선은 뉴턴-랩슨 방식이고 파란 직선은 경사 하강 방법이다. 전자는 위에서 살펴본 것처럼 한번에 극소점으로 이동하는 것을 볼 수 있다. 한편 후자는 수많은 <code class="language-plaintext highlighter-rouge">Iteration</code> 을 거쳐 극소점에 도달한다. 필자의 시각화 자료가 상당히 좋지 못하다고 생각해 하단에 <a href="https://www.youtube.com/watch?v=MlZoafOnMS0&amp;list=PL_iJu012NOxeMJ5TPPW1JZKec7rhjKXUy&amp;index=6&amp;ab_channel=%ED%98%81%ED%8E%9C%ED%95%98%EC%9E%84%7CAI%26%EB%94%A5%EB%9F%AC%EB%8B%9D%EA%B0%95%EC%9D%98">혁펜하임</a>님의 자료도 함께 첨부했으니 참고하자. 훨씬 직관적으로 잘 보인다.</p>

<p align="center">
<img src="/assets/images/optimization/gradient_vs_newton.png" alt="Newton-Raphson vs Gradient-Descent" class="align-center image-caption" width="60%&quot;, height=&quot;50%" />
<strong><em><a href="https://ibb.co/VjvkYL7">Newton-Raphson vs Gradient-Descent</a></em></strong>
</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Optimization Theory" /><category term="Optimization Theory" /><category term="Newton-Raphson" /><summary type="html"><![CDATA[최적화 문제를 위한 뉴턴-랩슨 메서드 설명]]></summary></entry><entry><title type="html">🗂️ Convex Optimization Problem</title><link href="http://localhost:4000/optimization-theory/convex" rel="alternate" type="text/html" title="🗂️ Convex Optimization Problem" /><published>2023-11-13T00:00:00+09:00</published><updated>2023-11-14T02:00:00+09:00</updated><id>http://localhost:4000/optimization-theory/convex_problem</id><content type="html" xml:base="http://localhost:4000/optimization-theory/convex"><![CDATA[<h3 id="convex-optimization-problem"><code class="language-plaintext highlighter-rouge">❓ Convex Optimization Problem</code></h3>

\[f(wx_1 + (1-w)x_2)≤ wf(x_1) + (1-w)f(x_2),\ \ w \in [0,1] \\
f''(x) ≥ 0\]

<p><code class="language-plaintext highlighter-rouge">Convex Problem</code> 이란, 목적 함수 $f(x)$가 <code class="language-plaintext highlighter-rouge">Convex Function</code> 이면서 <code class="language-plaintext highlighter-rouge">Feasible Set</code> 역시 <code class="language-plaintext highlighter-rouge">Convex Set</code> 이 되는 문제 상황을 일컫는다. <code class="language-plaintext highlighter-rouge">Convex Problem</code> 는 수학적 최적화에서 매우 중요한 개념인데, 그 이유는 해당 조건을 만족하면 <code class="language-plaintext highlighter-rouge">국소 최적해</code>가 <code class="language-plaintext highlighter-rouge">전역 최적해</code>와 동치가 되어 최적화 난이도가 급격히 낮아지기 때문이다. 또한 <code class="language-plaintext highlighter-rouge">Convex Problem</code>을 해결해 국소 최적해를 구하는 알고리즘은 이미 많이 개발 되어 있기 때문에 주어진 최적화 문제를 <code class="language-plaintext highlighter-rouge">Convex Problem</code>으로 치환해 해결하는게 가장 효율적이다. 한편, 여기서 <code class="language-plaintext highlighter-rouge">Feasible Set</code> 이란, 함수의 <code class="language-plaintext highlighter-rouge">실행 가능 영역•정의역</code>이라고 생각하면 된다. 아래 그림, 빨간 직선의 영역에 해당한다. 세트라는 명칭은 무한한 직선이 아닌 유한한 선분을 표현하는 용어라고 생각하면 된다.</p>

<p>위에 서술한 두개의 수식은 어떤 문제 상황이 <code class="language-plaintext highlighter-rouge">Convex Problem</code> 인지 아닌지 구분해주는 판별식의 역할을 한다. 왜 두 수식을 만족하면 <code class="language-plaintext highlighter-rouge">Convex Problem</code>이 되는지 살펴보고 마지막에는 <code class="language-plaintext highlighter-rouge">Convex Problem</code> 에서 왜 <code class="language-plaintext highlighter-rouge">국소 최적해</code>가 <code class="language-plaintext highlighter-rouge">전역 최적해</code>와 동치가 되는지 그 증명을 해보려 한다.</p>

<p align="center">
<img src="/assets/images/optimization/convex_function.png" alt="Convex Function" class="align-center image-caption" width="60%&quot;, height=&quot;50%" />
<strong><em><a href="">Convex Function</a></em></strong>
</p>

<h3 id="-jensens-inequality"><code class="language-plaintext highlighter-rouge">﹤ Jensen’s Inequality</code></h3>

<p>첫번째 수식을 보자. 우리는 이것을 <code class="language-plaintext highlighter-rouge">얀센 부등식</code>이라고 부른다. <code class="language-plaintext highlighter-rouge">얀센 부등식</code> 은 어떤 함수 $f(x)$의 <code class="language-plaintext highlighter-rouge">Convex Function</code> 여부를 판정 하는데 사용된다. 좌변은 <code class="language-plaintext highlighter-rouge">Feasible Set</code> 에 해당되는 데이터 포인트의 함수값을 의미하며 그림 상에서 초록색 곡선으로 표현된다. 한편, 우변은 <code class="language-plaintext highlighter-rouge">Feasible Set</code>의 평균변화율을 기울기로 하면서 구간 양쪽 끝을 지나는 선분을 일컫는다. 그림에서 파란색 직선이 바로 부등식의 우변이다.</p>

<p>그렇다면 위 부등식을 항상 만족하려면 함수 $f(x)$는 어떤 형태를 가져야 할까?? 먼저 오목 함수인 <code class="language-plaintext highlighter-rouge">Concave Function</code>부터 생각해보자. 위 그림을 뒤집어서 생각해보면 되는데, 함수가 정의되는 전체 정의역에서 위 부등식을 만족하는 구간(파란색 직선이 초록색 곡선보다 위에 있는)을 전혀 찾아볼 수 없다. 따라서 얀센 부등식을 만족하려면 <code class="language-plaintext highlighter-rouge">Feasible Set</code> 의 구간이 반드시 <code class="language-plaintext highlighter-rouge">Convex Set</code> 이어야 하고, 해당 구간에서 목적함수는 반드시 <code class="language-plaintext highlighter-rouge">Convex Function</code>의 형태를 띄고 있어야 한다.</p>

<p>그렇다면 목적함수가 <code class="language-plaintext highlighter-rouge">Convex</code>인지는 어떻게 판별할 수 있을까?? 주어진 모든 상황에서 위 그림처럼 쉽게 함수의 그래프를 그릴 수는 없을 것이다. 그래서 수식으로 어떤 목적함수가 <code class="language-plaintext highlighter-rouge">Convex</code>인지 판별할 수 있어야 한다. 드디어 제시된 두번째 수식을 활용할 차례다.</p>

<h3 id="second-derivative"><code class="language-plaintext highlighter-rouge">📈 Second Derivative</code></h3>

<p>두번째 수식을 흔히 이계도함수라고 부른다. 아마 수능 수학에서 21, 30번과 같은 킬러 문제를 풀 때 가끔씩 사용하던 기억이 날 것이다. 이계도함수는 도함수를 한 번 더 미분한 것으로 원함수의 곡선이 얼마나 빠르게 변하는지 혹은 곡선의 곡률에 대한 정보를 알려준다. 이를 통해 원함수의 극대, 극소는 물론 변곡점의 위치를 알아낼 수 있다. 그래서 어떤 이차함수를 예시로 들어보자. 2차항의 부호가 양수라면 이계도함수의 값은 항상 양수가 될 것이고, 음수라면 항상 음수가 될 것이다. 그런데 우리는 이미 직관적으로 2차함수에서 최고차항의 부호가 양수면 아래로 볼록한 함수, 반대의 경우 위로 오목한 오목함수가 된다는 것을 알고 있다. 따라서 이계도 함수의 값이 항상 양수라면 해당 함수는 <code class="language-plaintext highlighter-rouge">Convex Function</code>이 된다.</p>

<p>지금까지는 단변수 함수에 대한 케이스만 살펴보았다. 그렇다면 이것을 다변수로 확장할 수는 없을까?? 물론 가능하다. 어떤 다변수 함수가 <code class="language-plaintext highlighter-rouge">Convex</code>인지 판정하는 것도 위와 동일한 조건을 통해 판별한다. 이 때 등장하는게 바로 헤시안 행렬이다. 헤시안 행렬이란, 어떤 다변수 함수의 이계도함수값을 행렬로 나타낸 것이다. 단변수 함수의 이계도함수 역할과 동일하다. 그래서 어떤 다변수 함수가 컨백스 함수이려면, 헤시안 행렬이 <code class="language-plaintext highlighter-rouge">Positive Semi-Define</code> 조건을 만족해야 한다. 헤시안 행렬과 <code class="language-plaintext highlighter-rouge">Positive Semi-Define</code>에 대해서는 다른 포스트에서 자세히 다루도록 하겠다.</p>

<h3 id="-proof-local-minimum-same-as-global-minimum-in-convex"><code class="language-plaintext highlighter-rouge">🪪 Proof: local minimum same as global minimum in Convex</code></h3>

<p>이제 드디어 목적함수가 컨백스 함수일 때, 국소 최적해가 전역 최적해와 동치가 되는지를 증명해보려 한다. 먼저 증명은 귀류법을 사용한다. 귀류법이란, 수학, 논리학, 철학 등에서 주장이 부정됨을 보이기 위해 모순 또는 부정된 가정을 유도하는 논증 기법으로, 특정 주장이 참임을 증명하기보다는 그 반대인 부정된 주장이 거짓임을 보이는 데 사용한다. 그래서 귀류법을 활용해 다음과 같은 명제가 거짓임을 증명해보려 한다.</p>

<p>어떤 함수 $f(x)$는 Convex면서 Feasible Set이 Convex Set임을 만족하는 동시에 아래 수식을 만족한다고 한다.</p>

\[f(x^@) &lt; f(x^!)\]

<p>부등식의 우변은 국소 최적해를 의미하고, 좌변은 국소 최적해보다 작은 함수값이 존재한다고 가정한 것이다. 이제 이 명제가 틀림을 증명하면 우리는 자연스럽게 국소 최적해가 전역 최적해와 동치가 된다는 것을 확인할 수 있게 된다.</p>

<p>우리는 함수 $f(x)$가 <code class="language-plaintext highlighter-rouge">Convex</code>면서 <code class="language-plaintext highlighter-rouge">Feasible Set</code>이 <code class="language-plaintext highlighter-rouge">Convex Set</code>이라고 가정했기 때문에, $\alpha x^! + (1-\alpha)x^@$ 역시 <code class="language-plaintext highlighter-rouge">Feasible Set</code>이 될 것이다. 이러한 사실을 활용해 두 점($x^!, x^@$)을 얀센 부등식에 넣어보자.</p>

\[f(wx^! + (1-w)x^@)≤ wf(x^!) + f(x^!) - f(x^!) + (1-w)f(x^@) \\
f(wx^! + (1-w)x^@)≤ f(x^!) +(1-w)(f(x^@) -f(x^!))\]

<p>우변부터 함께 살펴보자. $(1-w)$는 반드시 양수가 된다. 얀센 부등식 정의상 $w \in [0,1]$을 만족하기 때문이다. 한편, $f(x^@) -f(x^!)$는 음수가 된다. 증명을 시작하면서 $f(x^@)$가 $f(x^!)$보다 작다고 가정했기 때문이다. 따라서 우변은 $f(x^!)$보다 아주 조금 작은 값(w→1)이 될 것이다. 이제 좌변을 살펴보자. 마찬가지로 w→1을 해주면 좌변은 $f(x^!)$의 매우 근접한 위치의 함수값을 보자는 의미가 된다. 좌변을 $\alpha$, 우변을 $\beta$로 치환해 지금까지 증명 과정을 다시 부등식으로 표현하면 다음과 같다.</p>

\[\alpha ≤ \beta &lt; f(x^!)\]

<p>우리는 $f(x^!)$가 지역 최소값이라고 정의한 바 있다. 지역 최소값이라는 것은 그 주변에서 가장 작은값이라는 의미를 갖는다. 그런데 $f(x^!)$의 주변값인 $\alpha$가 지역 최소값보다 작다고 부등식은 말하고 있기 때문에, 지역 최소값 정의에 위배되어 위 명제는 거짓이 된다.</p>

<p>정리하자면, 어떤 함수 $f(x)$가 컨백스 성질을 만족하면서, Feasible Set 역시 Convex Set인 경우에 국소 최소값이 전역 최소값이 아닐 경우, 국소 최적이 국소 최적이 아닌 경우가 발생하기 떄문에 반드시 위 조건에서 국소 최적값은 전역 최적값이 되어야 한다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Optimization Theory" /><category term="Optimization Theory" /><category term="Convex Optimization" /><summary type="html"><![CDATA[컨백스 최적화 문제 증명]]></summary></entry><entry><title type="html">🗂️ Graph Theory 4: Union-Find (Disjoint Set)</title><link href="http://localhost:4000/algorithm/union-find" rel="alternate" type="text/html" title="🗂️ Graph Theory 4: Union-Find (Disjoint Set)" /><published>2023-11-11T00:00:00+09:00</published><updated>2023-11-12T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/union-find</id><content type="html" xml:base="http://localhost:4000/algorithm/union-find"><![CDATA[<h3 id="disjoint-set"><code class="language-plaintext highlighter-rouge">🙅 Disjoint Set</code></h3>

<p>서로 공통된 원소를 가지고 있지 않은 여러 집합들을 지칭하는 용어다. 개별 원소가 정확히 하나의 집합에 속하며, 어떤 집합도 서로 공통 원소를 가지고 있지 않아야 한다. 서로소 집합 자료구조를 사용하면 서로 다른 원소들이 같은 집합군에 속해 있는가 판별하는 것과 같은 작업을 쉽게 할 수 있다. 그렇다면 이제부터 자료구조로서 서로소 집합을 효과적으로 표현하고 조작할 수 있는 <code class="language-plaintext highlighter-rouge">Makeset</code>, <code class="language-plaintext highlighter-rouge">Union</code>, <code class="language-plaintext highlighter-rouge">Find</code> 연산에 대해서 알아보자.</p>

<h3 id="️makeset"><code class="language-plaintext highlighter-rouge">🗂️ Makeset</code></h3>

<p>트리 자료구조를 활용해 집합을 표현하는 방법 중 하나로, 주어진 요소만 중복없이 포함하는 집합을 생성하는 연산이다. 실제 코드상 구현으로는 배열, 리스트 자료구조를 활용한다. 배열의 인덱스를 개별 원소의 식별자로 간주하고 해당 위치의 값에는 부모 원소의 인덱스를 채워 넣는다. 만약 인덱스와 원소값이 동일하다면 해당 원소가 포함된 집합에서 현재 원소가 루트 노드임을 의미한다. 이렇게 특정 인덱스의 원소값을 타고 거슬러 올라가다면 만나게 되는 루트 노드의 값을 이용해 우리는 서로 다른 두 원소가 같은 집합에 속하는지 혹은 다른 집합에 속하는지 구별할 수 있게 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" Disjoint Makeset Example """</span>

<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span> <span class="c1"># 노드 개수
</span><span class="n">M</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span> <span class="c1"># 엣지 개수
</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># 1) Makeset Array Init
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
</code></pre></div></div>

<p>배열의 인덱스를 개별 노드의 식별자로 사용하기 위해, 전체 그래프 상의 노드 개수만큼 배열의 크기를 초기화 해주고 있다. 그리고 초기에는 아직 노드 사이의 연결 정보에 대해서 주어진게 전혀 없기 때문에 개별 노드 자신이 루트 노드가 되도록 초기화를 해주는게 일반적이다. 이렇게 초기화한 배열은 <code class="language-plaintext highlighter-rouge">Union</code>, <code class="language-plaintext highlighter-rouge">Find</code> 연산에 활용된다.</p>

<h3 id="find"><code class="language-plaintext highlighter-rouge">🔬 Find</code></h3>

<p>어떤 원소가 속한 집합의 루트 노드 값을 반환하는 연산이다. <code class="language-plaintext highlighter-rouge">Find</code> 연산은 앞서 초기화한 <code class="language-plaintext highlighter-rouge">Makeset Array</code> 를 해당 집합(트리)의 루트 노드를 만날 때까지 재귀적으로 순회한다. 실제로는 단순 루트 노드를 반환하는 용도로 사용하지 않고, 특정 두 원소가 같은 집합(트리)에 속하는지 아니면 서로 다른 집합에 속하는지 판정하는데 사용된다. 서로 다른 두 원소를 <code class="language-plaintext highlighter-rouge">Find</code> 연산자에 넣어주면 각각의 루트 노드를 구할 수 있는데, 이 때 서로 같은 루트 노드값을 반환한다면 같은 집합이라고 간주하고 다르다면 서로 서로소 관계에 있다고 판단할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" find method """</span>

<span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="s">""" method for finding root node """</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

<span class="c1"># 1) Kruskal Algorithm
</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">weight</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">final</span><span class="p">):</span>
        <span class="n">union</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">weight</span>
</code></pre></div></div>

<p>위 소스코드처럼 <code class="language-plaintext highlighter-rouge">Kruskal</code> Algorithm처럼 최소 스패닝 트리가 필요한 상황에 자주 사용된다. 또한 근본이 트리 자료구조에 대한 연산이라는 점을 활용해, 특정 그래프의 사이클 여부를 판정하는 알고리즘으로도 많이 사용되고 있다.</p>

<h3 id="union"><code class="language-plaintext highlighter-rouge">👩‍👩‍👧‍👦 Union</code></h3>

<p>두 개의 집합을 하나로 합치는 연산이다. 집합의 루트 노드를 다른 집합의 루트 노드 아래에 연결하는 방식으로 합친다. 합치는 방식에는 다양한 방법론이 존재하는데, 일반적으로 루트 노드의 번호가 더 작은 쪽에 더 큰 쪽의 집합(트리)를 붙여주는 <code class="language-plaintext highlighter-rouge">Union by Rank</code> 방식을 많이 사용한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" union method """</span>

<span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="s">""" method for union-find """</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>

<span class="c1"># 1) Kruskal Algorithm
</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">weight</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">final</span><span class="p">):</span>
        <span class="n">union</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">weight</span>

<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<p>역시 마찬가지로 최소 스패닝 트리가 필요한 상황에 자주 사용되고 있으며, 주로 Find를 통해 서로소 집합 관계에 놓인 집합들을 판정하고, 그들을 하나로 통합시키는데 자주 쓰인다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Union-Find" /><summary type="html"><![CDATA[Union-Find Algorithm with Disjoint Set]]></summary></entry><entry><title type="html">🗂️ Graph Theory 5: MST with Kruskal &amp;amp; Prim</title><link href="http://localhost:4000/algorithm/mst" rel="alternate" type="text/html" title="🗂️ Graph Theory 5: MST with Kruskal &amp;amp; Prim" /><published>2023-11-11T00:00:00+09:00</published><updated>2023-11-12T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/mst</id><content type="html" xml:base="http://localhost:4000/algorithm/mst"><![CDATA[<h3 id="spanning-tree"><code class="language-plaintext highlighter-rouge">🎡 Spanning Tree</code></h3>

<p>그래프 내부에 포함된 모든 노드를 포함하는 트리를 의미한다. 모든 정점을 포함하긴 하지만 근본은 트리라서 사이클이 발생하면 안되며, 최소의 간선을 사용해 모든 노드를 연결해야 한다. 따라서 <code class="language-plaintext highlighter-rouge">Spanning Tree</code> 의 간선 개수는 <code class="language-plaintext highlighter-rouge">노드 개수-1</code>에 해당한다.</p>

<h3 id="minimum-spanning-tree"><code class="language-plaintext highlighter-rouge">💵 Minimum Spanning Tree</code></h3>

<p>그래프 상에서 발생할 수 있는 여러 <code class="language-plaintext highlighter-rouge">Spanning Tree</code> 중에서 간선들의 가중치 합이 최소인 트리를 의미한다. <code class="language-plaintext highlighter-rouge">MST</code>를 구현하는 알고리즘은 대표적으로 <code class="language-plaintext highlighter-rouge">Kruskal</code>, <code class="language-plaintext highlighter-rouge">Prim</code>알고리즘이 있다. 전자의 시간 복잡도는 <code class="language-plaintext highlighter-rouge">O(ElogE)</code>, 후자는 기본적으로 <code class="language-plaintext highlighter-rouge">O(N^2)</code>이라서 노드에 비해 간선 개수가 적은 희소 그래프의 경우는 Kruskal을, 노드에 비해 간선이 많은 밀집 그래프의 경우는 Prim을 사용하는게 시간 복잡도 측면에서 유리하다. 한편, Prim은 구현시에 선택하는 자료구조에 따라서 시간 복잡도를 최적화할 수 있다. 자세한 내용은 개별 알고리즘에 대한 설명에서 다루도록 하겠다.</p>

<h3 id="kruskal-algorithm-간선-선택"><code class="language-plaintext highlighter-rouge">🍃 Kruskal Algorithm (간선 선택)</code></h3>

<p>그리디하게 그래프의 모든 정점을 최소 비용으로 연결하는 방법이다. 구체적으로는 개별 시점에서 사이클을 이루지 않으면서 최소 비용인 간선을 경로로 선택한다. 그리디를 기반으로 하기 때문에 이전 결과, 미래 결과를 고려하지 않고 현재 최소 비용이 되는 간선만을 선택한다. 알고리즘의 구체적인 동작 과정은 다음과 같다.</p>

<ul>
  <li>1) 그래프의 간선들을 오름차순으로 정렬, 가중치 기준</li>
  <li>2) 사이클을 발생시키는지 여부를 체크하면서 순서대로 선택
    <ul>
      <li>가장 낮은 가중치부터 접근해 체크</li>
      <li>사이클 발생 X라면 선택</li>
    </ul>
  </li>
  <li>3) 선택한 간선을 <code class="language-plaintext highlighter-rouge">MST</code>집합에 추가</li>
</ul>

<p>사이클을 발생시키는지 여부를 체크하는 부분이 구현할 때 까다로울 수 있는데, Union-Find 알고리즘을 도입하면 수월하게 만들어 낼 수 있다. Union-Find를 도입한 Kruskal Algorithm을 Python 코드로 작성하면 다음과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" kruskal algorithm example: baekjoon 1043 """</span>

<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="s">""" method for finding root node """</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="s">""" method for union-find """</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>

<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>  <span class="c1"># number of nodes
</span><span class="n">M</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>  <span class="c1"># number of edges
</span><span class="n">graph</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># 0-0) 간선 연결 정보 초기화, 정렬
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">src</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">graph</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">cost</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
<span class="n">graph</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>

<span class="c1"># 0-1) 연결 정보 초기화
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

<span class="c1"># 1) Kruskal Algorithm
</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">weight</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">final</span><span class="p">):</span>
        <span class="n">union</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">weight</span>

<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<p>find 메서드는 입력한 노드의 루트 노드를 찾아 반환한다. 이것을 활용해 서로 다른 노드가 같은 집합(트리)에 속하는지 손쉽게 판정할 수 있으며 이것은 바꿔 생각해보면 선택된 두 노드가 사이클을 발생시키는지 여부를 알아 낼 수 있다는 것이다. 만약 두 노드가 같은 루트 노드값을 갖는다면, 결국 같은 집합(트리)에 속한다는 것을 의미하며, 이것은 사이클을 유발하게 되는 것이다. 따라서 사이클을 유발하는 정점은 선택하지 않으며, 트리의 성질을 유지할 수 있는 노드를 선택해 <code class="language-plaintext highlighter-rouge">union</code> 연산에 대입한다.</p>

<h3 id="prim-algorithm-정점-선택"><code class="language-plaintext highlighter-rouge">🔴 Prim Algorithm (정점 선택)</code></h3>

<p>특정 정점에서 시작해서 가중치가 작은 간선들 순서대로 트리를 확장해나가는 방법이다. 시작점을 지정한다는 점에서 다익스트라와 유사하며, 간선의 숫자가 많은 밀집 그래프 상황에서 <code class="language-plaintext highlighter-rouge">Kruskal</code>보다 빠르다. 구체적인 동작 방식은 다음과 같다.</p>

<ul>
  <li><strong>1) 선택 노드를 MST 집합에 추가</strong></li>
  <li><strong>2) MST 집합에 포함된 노드들에 인접한 정점들 탐색</strong>
    <ul>
      <li><strong>사이클 발생 여부 확인</strong>
        <ul>
          <li><strong>사이클 발생 X: 최소 가중치의 간선을 선택</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>3) 전체 간선의 개수가 N-1개가 될 때까지, 1 &amp; 2 과정  <code class="language-plaintext highlighter-rouge">Iteration</code></strong></li>
</ul>

<p>기본적으로는 <code class="language-plaintext highlighter-rouge">O(N^2)</code>의 시간복잡도를 기록한다. 하지만 자료구조 최적화에 따라서 <code class="language-plaintext highlighter-rouge">Kruskal</code>과 비슷한 시간복잡도인 <code class="language-plaintext highlighter-rouge">O(ElogE)</code>정도로까지 만들어 낼 수 있다. 최소 힙정렬과 우선순위 큐를 이용하면 된다. 힙정렬을 이용해 그래프 연결 정보를 가중치를 기준으로 오름차순 정렬을 한 뒤에, 사이클을 발생시키지 않는 인접 노드를 선택하도록 만든다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" prim algorithm example: baekjoon 1197 """</span>

<span class="kn">import</span> <span class="nn">sys</span><span class="p">,</span> <span class="n">heapq</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="s">"""
[풀이]
1) Prim with 우선순위 큐 (힙)
    - 시작점 선택, MST 집합에 추가
    - MST 집합의 노드들에 인접한 모든 정점 탐색
        - 사이클 발생 여부 확인: 방문 여부로 판정
        - 사이클 발생 X: 최소 가중치 간선 선택 (heapify를 통해 개별 노드마다 간선들을 가중치 기준 오름차순 정렬)
"""</span>

<span class="k">def</span> <span class="nf">prim</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">],</span> <span class="n">visit</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">visit</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>  <span class="c1"># 선택된 노드에 대한 모든 인접 간선 추출
</span>    <span class="n">heapq</span><span class="p">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>  <span class="c1"># 이미 생성되어 있는 자료구조에 대해서는 heapq.heapify를 사용하면 힙 성질을 만족하도록 할 수 있다
</span>    <span class="n">mst</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">tmp</span><span class="p">:</span>
        <span class="n">weight</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visit</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>  <span class="c1"># 미방문 노드로의 간선만 선택하는 방식으로, 사이클 발생 여부 판정하는 알고리즘을 구현
</span>            <span class="n">visit</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">mst</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">weight</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">visit</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]]:</span>
                    <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">total</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">():</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">prim</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 시작 노드를 어떤 것으로 설정해도 상관 없음
</span>    <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">sys</span><span class="p">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">V</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">graph</span><span class="p">,</span> <span class="n">visited</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">V</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
        <span class="n">src</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">src</span><span class="p">].</span><span class="n">append</span><span class="p">([</span><span class="n">cost</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">end</span><span class="p">])</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">end</span><span class="p">].</span><span class="n">append</span><span class="p">([</span><span class="n">cost</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">src</span><span class="p">])</span>
    <span class="n">solution</span><span class="p">()</span>
</code></pre></div></div>

<p>시작 정점은 아무거나 선택해도 상관없다. 그리고 가장 주목할 부분은 노드 선택시 사이클 여부를 판정하는 방법을 어떻게 구현했는가이다. 개별 노드에 대한 방문여부를 기록하는 배열을 따로 생성한 뒤, 방문(해당 노드와 연결되는 간선 선택)할 때 마다 방문 기록을 저장한다. 그리고 만약 어떤 노드를 선택했을 때, 이미 방문한 노드라면 해당 노드와 연결하는 간선의 가중치가 현재 가장 최소에 해당하더라도 사이클을 발생시키기 때문에 선택하지 않도록 사이클 여부를 판정하게 만들었다.<br />
<code class="language-plaintext highlighter-rouge">Kruskal</code>처럼 전체 모든 간선을 알고 있는 상태가 아님에도 최소 스패닝 트리의 조건을 만족하는 결과를 만들어 낼 수 있는 이유는 미리 개별 노드별 간선들을 가중치 기준으로 오름차순 정렬 해뒀기 때문이다. 이것 때문에 지역 최적들의 합이 전역 최적이 되어야 하는 그리디의 제약 조건을 만족시킬 수 있게 된다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="MST" /><category term="Kruskal" /><category term="Prim" /><summary type="html"><![CDATA[MST with Kruskal & Prim Algorithm]]></summary></entry><entry><title type="html">🗂️ Graph Theory 3: Floyd-Warshall</title><link href="http://localhost:4000/algorithm/floyd-warshell" rel="alternate" type="text/html" title="🗂️ Graph Theory 3: Floyd-Warshall" /><published>2023-11-11T00:00:00+09:00</published><updated>2023-11-12T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/floyd-warshell</id><content type="html" xml:base="http://localhost:4000/algorithm/floyd-warshell"><![CDATA[<h3 id="-floyd-warshall"><code class="language-plaintext highlighter-rouge">📚 Floyd-Warshall</code></h3>

<p><code class="language-plaintext highlighter-rouge">Floyd-Warshall</code>은 모든 지점에서 다른 모든 지점까지의 최단 경로를 구하는 알고리즘이다. 지정된 출발점에서 나머지 다른 지점가지의 최단 경로를 구하는 다익스트라 알고리즘과는 차이가 있다. 따라서 솔루션을 도출하는 방식에도 살짝 차이가 생기는데, <code class="language-plaintext highlighter-rouge">Floyd-Warshall</code> 은 그리디하게 매번 최단 경로에 있는 노드를 구할 필요가 없다. 이유는 모든 지점에서 다른 모든 지점까지의 경로를 구해야 하기 때문에 그리디 대신 <code class="language-plaintext highlighter-rouge">DP Tabulation</code>으로 문제를 풀기 때문이다.</p>

<p><code class="language-plaintext highlighter-rouge">Floyd-Warshall</code> 은 주어진 $N$ 개의 노드에 대해서 매번 $N^2$ 번의 연산을 통해 최단 거리를 갱신한다. 따라서 최종적으로 $O(N^3)$ 의 시간 복잡도를 갖게 된다. 연산은 직선 경로와 경유 경로를 비교하는 형태로 이뤄진다. 둘 중에서 더 작은 값이 <code class="language-plaintext highlighter-rouge">DP Table</code>에 저장된다. 여기서 경유 경로란 전체 $N$ 개의 노드에 대한 <code class="language-plaintext highlighter-rouge">iteration</code> 중에서 $i$ 번째 노드를 경유하는 경로를 말한다. 만약 직선 경로가 [$d, k$]라면 경유 경로는 [$d, i$] + [$i, k$] 가 된다. 우리는 테이블에 직선 경로와 경유 경로중에서 최단 거리만 저장하고 있기 때문에, 이렇게 하나의 노드에 대해서만 경유하는 경우만 고려해도 괜찮다. 만약 3개의 중간 노드를 경유해야만 최단 거리가 되는 경로가 있다고 가정해보자. 최적의 솔루션인 전체 경로의 부분 경로 역시 중간에 최단 경로로 선택되어 이미 테이블 어딘가에 값으로 자리 잡고 있게 된다. 따라서 결국엔 부분 집합의 합으로 전체 최적 솔루션인 경로를 도출해낼 수 있게 된다. 이러한 경우의 수를 고려하기 위해 <code class="language-plaintext highlighter-rouge">DP  Table</code>을 사용하게 된 것이라 생각한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" Floyd-Warshall Implementation """</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="s">"""
[Floyd-Warshall]
1) DP Table init
2) triple-loop
    - dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])
3) print result
"""</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>  <span class="c1"># 노드 개수
</span><span class="n">M</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>  <span class="c1"># 간선 개수
</span><span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

<span class="c1"># 1) DP Table init
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">src</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">dp</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>

<span class="c1"># 2) triple-loop
</span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>

<span class="c1"># 3) print result
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'INF'</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">' '</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="s">' '</span><span class="p">)</span>
    <span class="k">print</span><span class="p">()</span>
</code></pre></div></div>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Floyd-Warshall" /><summary type="html"><![CDATA[Floyd-Warshall Algorithm with DP Tabulation]]></summary></entry><entry><title type="html">🗂️ Graph Theory 2: Dijkstra</title><link href="http://localhost:4000/algorithm/dijkstra" rel="alternate" type="text/html" title="🗂️ Graph Theory 2: Dijkstra" /><published>2023-11-11T00:00:00+09:00</published><updated>2023-11-12T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/dijkstra</id><content type="html" xml:base="http://localhost:4000/algorithm/dijkstra"><![CDATA[<h3 id="-dijkstra"><code class="language-plaintext highlighter-rouge">📚 Dijkstra</code></h3>

<p>다익스트라 최단 경로 문제는 그래프 자료 구조에서 여러 개의 노드가 주어졌을 때, 특정한 노드(시작점)에서 특정한 노드(도착점)까지의 최단 경로를 구해주는 알고리즘을 설계해야 한다. 특히 다익스트라는 <code class="language-plaintext highlighter-rouge">음의 간선</code>이 없을 때 정상적으로 동작하며, 유향 &amp; 무향을 가리지 않고 적용할 수 있다. 다익스트라 알고리즘의 동작을 기술하면 아래와 같다.</p>

<ul>
  <li><strong>1) 출발 노드 설정</strong></li>
  <li><strong>2) 최단 거리 테이블 초기화(출발 노드 값은 0)</strong></li>
  <li><strong>3) 방문하지 않은 노드 중에서 현재 가장 가까운 노드를 선택(최단 거리 노드)</strong></li>
  <li><strong>4) 선택된 노드로부터 파생되는 다른 경로값 업데이트</strong></li>
  <li><strong>5) 모든 노드에 대한 계산 끝날 때까지 3~4번 반복</strong></li>
</ul>

<p>다익스트라 알고리즘을 설계하는 방법은 크게 두가지가 있다. 먼저 3번을 수행하기 위해 1) 최단 거리 테이블을 매번 선형 탐색하는 알고리즘,  2) 선형 탐색 대신에 힙 정렬을 이용해 가장 가까운 노드를 선택하는 방식이 있다. 1번의 경우 <code class="language-plaintext highlighter-rouge">O(V^2)</code> 가 되어 입력 노드가 1000개만 넘어가도 시간 초과를 당하기 때문에, 2번의 경우로 소스 코드를 작성하는 게 바람직하다. 코드 예시는 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" Dijkstra implementation """</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">h</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="n">distance</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">while</span> <span class="n">h</span><span class="p">:</span>
        <span class="n">min_cost</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="c1"># 방문한 노드 처리: cost를 기준으로 다음 노드를 선정, 따라서 cost가 distance[node]보다 크다면 이미 방문 했던 노드로 볼 수 있음
</span>        <span class="k">if</span> <span class="n">min_cost</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="n">min_cost</span> <span class="o">+</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cost</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
                <span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">cost</span>
                <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<span class="n">V</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">src</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>

<span class="c1"># 1) init graph
</span><span class="n">graph</span><span class="p">,</span> <span class="n">costs</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">V</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">costs</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">weight</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

<span class="n">dijkstra</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">costs</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">V</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span> <span class="k">else</span> <span class="s">'INF'</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Dijkstra" /><summary type="html"><![CDATA[Dijkstra Algorithm with Priority Queue]]></summary></entry><entry><title type="html">✏️  Summary of Useful Library for Coding Test</title><link href="http://localhost:4000/algorithm/useful_library" rel="alternate" type="text/html" title="✏️  Summary of Useful Library for Coding Test" /><published>2023-11-11T00:00:00+09:00</published><updated>2023-11-12T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/summary-of-useful-library</id><content type="html" xml:base="http://localhost:4000/algorithm/useful_library"><![CDATA[<h3 id="collections"><code class="language-plaintext highlighter-rouge">📚 collections</code></h3>

<h4 id="deque"><code class="language-plaintext highlighter-rouge">🪢 deque</code></h4>
<p><code class="language-plaintext highlighter-rouge">python</code>에서 <code class="language-plaintext highlighter-rouge">stack</code>이나 <code class="language-plaintext highlighter-rouge">queue</code> 자료형을 구현할 때 일반적으로 사용하는 내장 라이브러리 <code class="language-plaintext highlighter-rouge">collections</code>에 구현된 클래스다. 메서드가 아닌 객체라서 사용하려면 초기화가 필요하다. 사용 예시를 보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># collections.deque usage example
</span><span class="n">deque</span><span class="p">([</span><span class="n">iterable</span><span class="p">[,</span> <span class="n">maxlen</span><span class="p">]])</span> <span class="o">--&gt;</span> <span class="n">deque</span> <span class="nb">object</span>

<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">Counter</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span> <span class="c1"># 1)
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span>
<span class="n">deque</span><span class="p">([])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(())</span>  <span class="c1"># 2)
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span>
<span class="n">deque</span><span class="p">([])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([])</span> <span class="c1"># 3) 
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span>
<span class="n">deque</span><span class="p">([])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># 4)
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span>
<span class="n">deque</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># 5)
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span>
<span class="n">deque</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

</code></pre></div></div>

<p>객체를 초기화할 때 값을 넣어줄 것이 아니라면 리스트를 굳이 전달하지 않아도 똑같이 초기화가 된다. 다만, 특정값을 넣어줄 것이라면 반드시 <code class="language-plaintext highlighter-rouge">iterable</code> 객체를 전달해야 한다. 이 때 <code class="language-plaintext highlighter-rouge">iterable</code> 객체는 어떤 형태를 넣어도 같은 결과를 반환하게 된다. 예를 들어 리스트를 넣고 <code class="language-plaintext highlighter-rouge">deque</code>를 초기화 하나 튜플을 넣고 초기화 하나 결과는 같다는 것이다. 예시 코드의 4번과 5번 예시를 보자. 각각 리스트와 튜플을 넣고 초기화를 했지만 초기화 결과는 동일한 것을 확인할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># deque indexing &amp; slicing
</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">2</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">[:]</span>
<span class="nb">TypeError</span><span class="p">:</span> <span class="n">sequence</span> <span class="n">index</span> <span class="n">must</span> <span class="n">be</span> <span class="n">integer</span><span class="p">,</span> <span class="ow">not</span> <span class="s">'slice'</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">deque</code> 는 리스트처럼 인덱싱은 가능하지만, 슬라이싱 기능은 활용할 수 없으니 참고하자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># deqeue max_len example
</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="mi">6</span><span class="p">)</span>  <span class="c1"># 객체라서 초기화가 필요하다.
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span>
<span class="n">deque</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
</code></pre></div></div>

<p>한편, <code class="language-plaintext highlighter-rouge">max_len</code> 매개변수를 통해 선언한 객체의 최대 길이를 지정해 줄 수 있는데, 이 때 객체가 지정 길이를 넘어서면 큐의 동작처럼 가장 왼쪽에 위치한 원소를 먼저 빼고 새로운 원소를 가장 오른쪽에 추가한다.</p>

<p>만약 deque를 이용해 스택을 구현하고 싶다면 <code class="language-plaintext highlighter-rouge">deque.append</code>와 <code class="language-plaintext highlighter-rouge">deque.pop</code>을 사용하자. 정확히 선입후출 동작을 구현할 수 있다. 한편 큐를 구현하고 싶다면 <code class="language-plaintext highlighter-rouge">deque.append</code>와 <code class="language-plaintext highlighter-rouge">deque.popleft</code>를 함께 사용하자. 정확히 선입선출 구조를 만들어낼 수 있다. 한편 가장 첫번째 원소 앞에 새로운 원소를 추가하고 싶다면 <code class="language-plaintext highlighter-rouge">appendleft()</code> 역시 지원하고 있으니 참고해두면 좋을 것 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># deque stack &amp; queue 구현
</span>
<span class="s">""" stack """</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
<span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
<span class="mi">1</span>

<span class="s">""" queue """</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
<span class="mi">3</span>
</code></pre></div></div>

<h4 id="️-counter"><code class="language-plaintext highlighter-rouge">🗂️ Counter</code></h4>

<p><code class="language-plaintext highlighter-rouge">Iterable</code> 객체에 있는 <code class="language-plaintext highlighter-rouge">hashable item</code>의 개수를 세어 <code class="language-plaintext highlighter-rouge">Dict</code> 자료형으로 반환하는 역할을 한다. 아래 예시를 보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># collection.Counter example
</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">test</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span>
<span class="n">Counter</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">test</span> <span class="o">=</span> <span class="s">'aabcdacdbbbbaaaadddcccbcbcbcbcbcbbcbcbcbcbcdaadaabadbcdbcdacdbacdbacdbcadacbbcabcadb'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span>
<span class="n">Counter</span><span class="p">({</span><span class="s">'a'</span><span class="p">:</span> <span class="mi">19</span><span class="p">,</span> <span class="s">'b'</span><span class="p">:</span> <span class="mi">26</span><span class="p">,</span> <span class="s">'c'</span><span class="p">:</span> <span class="mi">24</span><span class="p">,</span> <span class="s">'d'</span><span class="p">:</span> <span class="mi">15</span><span class="p">})</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span><span class="p">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">[(</span><span class="s">'b'</span><span class="p">,</span> <span class="mi">26</span><span class="p">),</span> <span class="p">(</span><span class="s">'c'</span><span class="p">,</span> <span class="mi">24</span><span class="p">),</span> <span class="p">(</span><span class="s">'a'</span><span class="p">,</span> <span class="mi">19</span><span class="p">)]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span><span class="p">.</span><span class="n">values</span>
<span class="n">dict_values</span><span class="p">([</span><span class="mi">19</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
<span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">,</span> <span class="s">'d'</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">counter</span><span class="p">.</span><span class="n">elements</span><span class="p">()))</span>
<span class="s">'aaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbccccccccccccccccccccccccddddddddddddddd'</span>
</code></pre></div></div>

<p>이처럼 <code class="language-plaintext highlighter-rouge">Iterable</code> 객체의 원소에 접근해 다양한 일을 수행할 수 있다. <code class="language-plaintext highlighter-rouge">most_common</code>은 가장 많이 사용된 원소를 순서대로 사용자가 지정한 등수만큼 보여준다. <code class="language-plaintext highlighter-rouge">values</code> 는 개별 <code class="language-plaintext highlighter-rouge">key</code>의 값을 반환한다. <code class="language-plaintext highlighter-rouge">join</code>, <code class="language-plaintext highlighter-rouge">sorted</code> 와 함께 하면 원소를 반복하는 것도 가능하다.</p>

<h4 id="defaultdict"><code class="language-plaintext highlighter-rouge">👌 defaultdict</code></h4>

<p>사전의 <code class="language-plaintext highlighter-rouge">key</code>에 대한 <code class="language-plaintext highlighter-rouge">value</code>가 아직 없지만, 미리 <code class="language-plaintext highlighter-rouge">value</code>의 자료형을 지정해주고 싶을 때 사용하면 유용하다. 예를 들어 동물의 종류를 분류하는 사전을 만들고 싶다고 가정해보자. 0번 <code class="language-plaintext highlighter-rouge">key</code>가 조류라고 해보자. 그럼 조류에 해당되는 <code class="language-plaintext highlighter-rouge">value</code>는 참새, 비둘기 … 앵무새 등 정말 많을 것이다. 이것을 한번에 그룹핑해 조류라는 카테고리에 속한다고 표현해주기 위해 우리는 리스트를 <code class="language-plaintext highlighter-rouge">value</code>의 기본 자료형으로 지정해주는 것이다. 이 때 defaultdict을 이용하면 쉽게 구현이 가능하다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># collections.defaultdict example
</span><span class="k">from</span> <span class="n">collections</span> <span class="n">ipmort</span> <span class="n">defaultdict</span>

<span class="n">animal_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">defaultdict</code> 에 어떤 자료형을 매개변수로 전달하는가에 따라서 초기화 되는 기본 자료형이 바뀐다. 우리는 <code class="language-plaintext highlighter-rouge">list</code> 를 기본 자료형으로 지정했지만 <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">set</code> 같은 것도 가능하니 참고해두자.</p>

<h3 id="️-heapq"><strong><code class="language-plaintext highlighter-rouge">🗂️ heapq</code></strong></h3>

<p>다익스트라 최단 경로 알고리즘을 포함한 다양한 알고리즘 문제에서 우선순위 큐 기능을 구현할 때 사용하는 라이브러리로 기본적으로 최소 힙(오름차순, 파이썬 내장 정렬 알고리즘의 특성으로 모두 기본값이 오름차순) 구성으로 되어 있다. <code class="language-plaintext highlighter-rouge">heapq.heappush()</code> 로 힙에 원소를 삽입하는 기능을 구현하며, <code class="language-plaintext highlighter-rouge">heapq.heappop()</code> 을 통해서 힙으로부터 원소를 빼낸다. 아래는 힙 정렬을 구현한 코드이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Min Heapsort
</span><span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">def</span> <span class="nf">min_heapsort</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
	<span class="n">h</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="c1"># heap에 원소 삽입
</span>	<span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
		<span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
	<span class="c1"># heap으로부터 원소 빼내기
</span>	<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)):</span>
		<span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
	
	<span class="k">return</span> <span class="n">result</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">min_heapsort</span><span class="p">([])</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Max Heapsort
</span><span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">def</span> <span class="nf">max_heapsort</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
	<span class="n">h</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
		<span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">-</span><span class="n">value</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)):</span>
		<span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>

	<span class="k">return</span> <span class="n">result</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">max_heapsort</span><span class="p">([])</span>
</code></pre></div></div>

<p>구현된 힙의 모든 원소가 정렬되는 것은 아니며 현재 최대,최소 원소에 대한 정렬만 보장하기 때문에 주의가 필요하다. 개별 시점에서 최대,최소값만 필요하다면 힙정렬 사용을 고려해보자.</p>

<h3 id="️-sort--sorted"><strong><code class="language-plaintext highlighter-rouge">🗂️ sort &amp; sorted</code></strong></h3>

<p>python <code class="language-plaintext highlighter-rouge">iterable</code> 객체를 빠르게 정렬할 때 사용하는 기능이다. 두 함수 모두 기능은 같지만 적용 대상 범위가 다르며, 함수 실행 결과가 반환 방식도 다르기 때문에 사용할 때 주의해야 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># sort, sorted 차이
</span><span class="n">result</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
<span class="n">result</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># 정렬 결과가 result에 반영
</span><span class="nb">sorted</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># 정렬 결과를 result에 반영 x
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">sort</code>는 정렬 결과를 매개 변수로 입력한 <code class="language-plaintext highlighter-rouge">iterable</code> 객체에 바로 적용되는 <code class="language-plaintext highlighter-rouge">in-place</code> 연산인 반면, <code class="language-plaintext highlighter-rouge">sorted</code>는 그렇지 않다. 한편 <code class="language-plaintext highlighter-rouge">sort</code> 는 리스트 자료형(<code class="language-plaintext highlighter-rouge">mutable object</code>)만 매개 변수로 입력 가능하지만, <code class="language-plaintext highlighter-rouge">sorted</code>는 모든 <code class="language-plaintext highlighter-rouge">iterable</code> 객체를 사용 가능하다.</p>

<p><code class="language-plaintext highlighter-rouge">reverse</code>, <code class="language-plaintext highlighter-rouge">reversed</code> 역시 위와 같은 규칙을 따르는데, <code class="language-plaintext highlighter-rouge">sort</code>, <code class="language-plaintext highlighter-rouge">reverse</code> 처럼 자료형 객체 내부에 내장된 메서드인 경우는 <code class="language-plaintext highlighter-rouge">in-place</code> 연산을 지원하고 <code class="language-plaintext highlighter-rouge">sorted</code>, <code class="language-plaintext highlighter-rouge">reversed</code> 처럼 <code class="language-plaintext highlighter-rouge">global</code> 한 내장 메서드인 경우는 <code class="language-plaintext highlighter-rouge">in-place</code> 를 지원하지 않는다. 이러한 경우에는 반드시 다른 변수에 대입해줘야 하니 주의하자.</p>

<p>만약 다중 조건을 적용해 <code class="language-plaintext highlighter-rouge">Iterable</code> 객체를 정렬하고 싶다면, 아래와 같이 튜플 형태로 <code class="language-plaintext highlighter-rouge">lambda function</code> 에 적용하고 싶은 우선순위대로 기준을 입력해주면 된다. 구체적인 예시는 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" 
lecture_schedule = [시작시간, 끝시간] 
끝나는 시간을 기준으로 오름 차순 정렬하되, 끝나는 시간이 같으면, 시작 시간 오름 차순 정렬 적용 
"""</span>
<span class="n">lecture_schedule</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="n">lecture_schedule</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1"># key=lambda x:(우선순위1, 우선순위2, 우선순위3 ...)
</span><span class="n">lecture_schedule</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1"># - 붙인 정렬 조건은 현재 정렬 기준과 반대로
</span></code></pre></div></div>

<p>마지막으로 <code class="language-plaintext highlighter-rouge">-</code>를 붙인 조건은 현재 정렬 기준(오름차순, 내림차순)과 반대로 정렬을 하게 된다. 예시 코드의 3번째 라인처럼 <code class="language-plaintext highlighter-rouge">-</code> 을 붙이면 1번째는 내림 차순으로, 2번째는 오름 차순으로 정렬을 수행하게 된다. 정말 유용하니 꼭 기억해두자. 이걸 모르면, 해당 동작을 구현하기 위해 엄청난 코드 라인을 소비해야 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lambda x: x[1]과 동일한 결과
</span><span class="k">def</span> <span class="nf">second</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
	<span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="n">result</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
<span class="n">result</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">second</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># 정렬 결과가 result에 반영
</span><span class="nb">sorted</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">second</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># 정렬 결과를 result에 반영 x
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">lambda</code> 대신 직접 함수를 정의해 사용하는 것도 가능하니 꼭 기억해두자.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="collections" /><category term="Codeing Test" /><category term="Algorithm" /><summary type="html"><![CDATA[코딩 테스트 풀이에 자주 사용되는 파이썬 내장 라이브러리 사용법 정리]]></summary></entry><entry><title type="html">👩‍💻🎄 [baekjoon] 16920번: 확장게임</title><link href="http://localhost:4000/ps/baekjoon-16920" rel="alternate" type="text/html" title="👩‍💻🎄 [baekjoon] 16920번: 확장게임" /><published>2023-10-16T00:00:00+09:00</published><updated>2023-10-17T02:00:00+09:00</updated><id>http://localhost:4000/ps/baekjoon_16920</id><content type="html" xml:base="http://localhost:4000/ps/baekjoon-16920"><![CDATA[<h3 id="️solution"><strong><code class="language-plaintext highlighter-rouge">🖍️ solution</code></strong></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">():</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># direction of search
</span>    <span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">p_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span>  <span class="c1"># for matching index with player num
</span>    <span class="n">graph</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">M</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="n">player_q</span> <span class="o">=</span> <span class="p">[</span><span class="n">deque</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>  <span class="c1"># for matching index with player num
</span>
    <span class="c1"># 1) player dict 초기화
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">"."</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">"#"</span><span class="p">:</span>
                <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">now</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">now</span>
                <span class="n">player_q</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                <span class="n">scores</span><span class="p">[</span><span class="n">now</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># 2) 개별 player 탐색
</span>    <span class="n">turn</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">while</span> <span class="n">turn</span><span class="p">:</span>
        <span class="n">turn</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">player</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">P</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">player_q</span><span class="p">[</span><span class="n">player</span><span class="p">]:</span>  <span class="c1"># 이미 탐색이 종료된 플레이어 턴 스킵
</span>                <span class="k">continue</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">player_q</span><span class="p">[</span><span class="n">player</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p_list</span><span class="p">[</span><span class="n">player</span><span class="p">]):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>  <span class="c1"># 모든 플레이어들이 1개 이상 영역 확장 못하는데 최대 탐색 깊이가 매우 큰 경우, 헛돌게 된다
</span>                    <span class="k">break</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
                    <span class="n">vy</span><span class="p">,</span> <span class="n">vx</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                        <span class="n">ny</span> <span class="o">=</span> <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">vy</span>
                        <span class="n">nx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">vx</span>
                        <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="ow">and</span> <span class="n">graph</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">graph</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span> <span class="o">=</span> <span class="n">player</span>
                            <span class="n">scores</span><span class="p">[</span><span class="n">player</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">])</span>
                            <span class="n">turn</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">scores</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">solution</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="idea"><strong><code class="language-plaintext highlighter-rouge">💡 idea</code></strong></h3>

<ul>
  <li><strong>1) BFS</strong>
    <ul>
      <li><strong>1-1) <code class="language-plaintext highlighter-rouge">grid</code> 초기화</strong>
        <ul>
          <li><strong>루프 내부에 타입 캐스팅 함수 호출 방지를 위해 문자열 입력을 정수로 변환</strong></li>
          <li><strong>동시에 개별 플레이어의 초기 시작 위치를 개별 큐에 삽입(<code class="language-plaintext highlighter-rouge">player_q</code>)</strong></li>
          <li><strong>플레이어 점수 초기화 및 업데이트</strong></li>
        </ul>
      </li>
      <li><strong>1-2) <code class="language-plaintext highlighter-rouge">BFS</code> 순회</strong>
        <ul>
          <li><strong>라운드 구현: <code class="language-plaintext highlighter-rouge">while loop</code></strong></li>
          <li><strong>개별 플레이어 턴, 탐색 깊이 제한, 1회 탐색 및 동시 탐색 구현: <code class="language-plaintext highlighter-rouge">for-loop</code></strong>
            <ul>
              <li><strong>개별 플레이어 턴: <code class="language-plaintext highlighter-rouge">for player in range(1, P+1):</code></strong></li>
              <li><strong>탐색 깊이 제한: <code class="language-plaintext highlighter-rouge">for _ in range(p_list[player]):</code></strong>
                <ul>
                  <li><strong>모든 플레이어가 1개 이상 영역 확장 불가한 상황 and 최대 탐색 깊이 매우 큰 경우</strong>
                    <ul>
                      <li><strong>탐색 깊이 제한 루프를 헛돌게 되기 때문에 시간 초과 발생</strong></li>
                      <li><strong>큐가 비었다면 루프 탈출하도록 코드 추가 필요: <code class="language-plaintext highlighter-rouge">break if not q</code></strong></li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li><strong>1회 탐색 및 동시 탐색 구현: <code class="language-plaintext highlighter-rouge">for _ in range(len(q)):</code></strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="반례"><strong><code class="language-plaintext highlighter-rouge">🤔 반례</code></strong></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" 반례 케이스 """</span>

<span class="mi">4</span> <span class="mi">10</span> <span class="mi">4</span>
<span class="mi">1000000000</span> <span class="mi">1</span> <span class="mi">100</span> <span class="mi">99999</span>
<span class="mi">1</span><span class="c1">#........
#.........
</span><span class="mi">2</span><span class="c1">#.......#
</span><span class="mi">3</span><span class="c1">#......#4
</span></code></pre></div></div>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Problem Solving" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="Graph" /><category term="BFS" /><summary type="html"><![CDATA[백준 16920번: 확장게임]]></summary></entry></feed>