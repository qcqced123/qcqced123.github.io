<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-08-30T02:25:52+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">AI/Business Study Log</title><subtitle>NLP, Marketing</subtitle><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><entry><title type="html">👩‍💻🔠 [baekjoon] 17609번: 회문</title><link href="http://localhost:4000/algorithm/baekjoon-17609" rel="alternate" type="text/html" title="👩‍💻🔠 [baekjoon] 17609번: 회문" /><published>2023-08-29T00:00:00+09:00</published><updated>2023-08-30T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/baekjoon_17609</id><content type="html" xml:base="http://localhost:4000/algorithm/baekjoon-17609"><![CDATA[<h3 id="️solution"><code class="language-plaintext highlighter-rouge">🖍️ solution</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="s">"""
[시간]
1) 14:20 ~ 14:45

[요약]
1) 유사회문: 한 문자를 삭제하여 회문으로 만들 수 있는 문자열
    =&gt; 유사회문인지 아닌지 판단하는 프로그램 작성
2) 주어진 문자열의 길이는 10만, 문자열 개수는 최대 30개
    =&gt; 제한 시간이 1초라서 O(n)의 알고리즘을 설계 필요, Counter 사용 불가
[전략]
1) 슬라이싱 이용해서 원본과 뒤집은 문자열을 비교하는 과정에서 걸러내기 (루프 하나만 쓰게 만들 수 있음)
    - 각 자리를 대조하면 가장 처음 다른 문자가 등장하는 지점을 찾아재 해당 문자를 제거함.
    - 제거하는 것도 두가지 케이스가 발생, 둘 중 하나만 만족해도 유사 팰린드롬으로 판정
        =&gt; 원본의 문자 제거
        =&gt; 역본의 문자 제거
"""</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())):</span>
    <span class="n">checker1</span><span class="p">,</span> <span class="n">checker2</span> <span class="o">=</span> <span class="s">''</span><span class="p">,</span> <span class="s">''</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
    <span class="n">tmp_pal</span> <span class="o">=</span> <span class="n">text</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># pure palindrome
</span>    <span class="k">if</span> <span class="n">text</span> <span class="o">==</span> <span class="n">tmp_pal</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">continue</span>

    <span class="c1"># similar palindrome or not
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">tmp_pal</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> 
            <span class="n">checker1</span> <span class="o">=</span> <span class="n">checker1</span> <span class="o">+</span> <span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># remove original text's char
</span>            <span class="n">checker2</span> <span class="o">=</span> <span class="n">checker2</span> <span class="o">+</span> <span class="n">tmp_pal</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># remove reversed text's char
</span>            <span class="k">break</span>
        <span class="n">checker1</span> <span class="o">+=</span> <span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">checker2</span> <span class="o">+=</span> <span class="n">tmp_pal</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">checker1</span> <span class="o">==</span> <span class="n">checker1</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">checker2</span> <span class="o">==</span> <span class="n">checker2</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">print</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><code class="language-plaintext highlighter-rouge">💡 idea</code></h3>

<ul>
  <li><strong>1)  슬라이싱을 이용한 풀이</strong>
    <ul>
      <li><strong>원본과 슬라이싱으로 뒤집은 문자열을 철자 하나 하나 비교 (문자열 길이 및 시간 제한 때문에 이중 루프는 불가)</strong>
        <ul>
          <li><strong><code class="language-plaintext highlighter-rouge">linear search</code> 하면서, 처음으로 다른 철자가 등장하는 지점을 찾아 해당 문자를 제거, 제거는 두가지 케이스 발생</strong>
            <ul>
              <li><strong>원본의 철자를 제거하는 경우</strong></li>
              <li><strong>역본의 철자를 제거하는 경우</strong></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><strong>두가지 케이스 중에서 하나라도 만족한다면 유사 팰린드롬으로 판정</strong></li>
    </ul>
  </li>
</ul>

<p>시간압박이 있는 상황에서 혼합 슬라이딩 윈도우과 포인터 혼합 방식을 깔끔하게 구현하는 것이 생각보다 쉽지 않아서, 직관적으로 코드를 빠르게 만들 수 있는 <strong><code class="language-plaintext highlighter-rouge">슬라이싱 대조</code></strong> 방식을 선택하게 되었다. 혼합 방식에 비해 우아하고 느리지만, 훨씬 직관적인 풀이라고 생각한다.</p>

<p>철자 제거할 때 주의할 점은 원본과 역본 케이스 모두 고려해야 한다는 점이다. 둘 중 하나만 고려하면 반례에 걸리는게 생긴다. 필자는 처음에 무지성으로 역본의 철자만 제거하는 방식으로 코드를 서술했다가 예제 입력 3번째 문자열에 의해 원본 역시 고려해야 함을 깨닫고 수정하게 되었다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="String Handle" /><summary type="html"><![CDATA[백준 17609번 회문 풀이]]></summary></entry><entry><title type="html">👩‍💻💵 [baekjoon] 1789번: 수들의 합</title><link href="http://localhost:4000/algorithm/baekjoon-1789" rel="alternate" type="text/html" title="👩‍💻💵 [baekjoon] 1789번: 수들의 합" /><published>2023-08-29T00:00:00+09:00</published><updated>2023-08-30T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/baekjoon_1789</id><content type="html" xml:base="http://localhost:4000/algorithm/baekjoon-1789"><![CDATA[<h3 id="️solution"><code class="language-plaintext highlighter-rouge">🖍️ solution</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="s">"""
[시간]
1) 01:40 ~ 02:10
[요약]
1) S: 서로 다른 N개의 자연수들의 합
    =&gt; 이 때, 자연수 N의 최대값
[전략]
1) 자연수 개수가 최대가 되도록 만들 어야 하기 때문에 최대한 작은 수들의 합으로 S를 구성
    - 10: 1,2,3,4 =&gt; 4개
"""</span>
<span class="n">S</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>
<span class="c1"># for 1, 2
</span><span class="k">if</span> <span class="n">S</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">tmp_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">S</span> <span class="o">-</span> <span class="n">tmp_sum</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">:</span>
            <span class="n">tmp_sum</span> <span class="o">+=</span> <span class="n">num</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><code class="language-plaintext highlighter-rouge">💡 idea</code></h3>

<ul>
  <li><strong>1) 최대한 작은 수들의 합으로 S를 구성</strong>
    <ul>
      <li><strong>최대한 작은 수들로 더할수록 N이 가장 커지기 때문</strong>
        <ul>
          <li><strong>쭉 더하다가 마지막에 <code class="language-plaintext highlighter-rouge">S - 지금까지 합</code> 의 수를 포함 시켜주면 되기 때문에 해결 가능</strong>
            <ul>
              <li><strong>사실 그 마저도 구하는게 숫자의 개수라서 값을 정확히 안구해줘도 된다</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="String Handle" /><summary type="html"><![CDATA[백준 1789번 수들의 합 풀이]]></summary></entry><entry><title type="html">👩‍💻🔠 [baekjoon] 5052번: 전화번호 목록</title><link href="http://localhost:4000/algorithm/baekjoon-5052" rel="alternate" type="text/html" title="👩‍💻🔠 [baekjoon] 5052번: 전화번호 목록" /><published>2023-08-29T00:00:00+09:00</published><updated>2023-08-30T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/baekjoon_5052</id><content type="html" xml:base="http://localhost:4000/algorithm/baekjoon-5052"><![CDATA[<h3 id="️solution"><code class="language-plaintext highlighter-rouge">🖍️ solution</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="s">"""
[시간]
1) 15:20 ~ 16:00

[요약]
1) 주어진 전화번호 목록을 보고, 일관성이 여부 판단
    - 하나의 번호가 다른 번호의 접두어 X
    - 주어진 모든 번호에 동일하게 연락할 수 있어야 일관성 있다고 판단
[전략]
1) 전화번호 앞자리를 최우선 기준으로 정렬
    - 시간 제한 &amp; 입력의 길이: 이중 루프 커버 불가능
    - 숫자처럼 생긴 '문자열'을 정렬, 길이와 관계 없이 자리수에 채워진 숫자가 비슷한 번호끼리 뭉침
        =&gt; 그래서 굳이 이중 루프를 이용해 전체를 탐색할 필요가 없음
        =&gt; 애초에 비슷한 것끼리 뭉쳐 있는 상태라서, local optimal ~ global optimal 기대 가능
        =&gt; 다만, 길이를 기준으로 정렬한게 아니라서, 슬라이싱 기준을 길이로 정해 줘야 한다.
"""</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())):</span>
    <span class="n">checker</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="s">'YES'</span>
    <span class="n">num_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">()))]</span>
    <span class="n">num_list</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num_list</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))]</span> <span class="o">==</span> <span class="n">num_list</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][:</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))]:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'NO'</span><span class="p">)</span>
            <span class="n">checker</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">checker</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><code class="language-plaintext highlighter-rouge">💡 idea</code></h3>

<ul>
  <li><strong>1) 전화번호 앞자리를 최우선 기준으로 정렬</strong>
    <ul>
      <li><strong>시간 제한 &amp; 입력의 길이: 이중 루프 커버 불가능</strong></li>
      <li><strong>숫자처럼 생긴 ‘문자열’을 정렬, 길이와 관계 없이 자리수에 채워진 숫자가 비슷한 번호끼리 뭉침</strong>
        <ul>
          <li><strong>그래서 굳이 이중 루프를 이용해 전체를 탐색할 필요가 없음</strong></li>
          <li><strong>애초에 비슷한 것끼리 뭉쳐 있는 상태라서, <code class="language-plaintext highlighter-rouge">local optimal ~ global optimal</code> 기대 가능</strong></li>
          <li><strong>다만, 길이를 기준으로 정렬한게 아니라서, 슬라이싱 기준을 길이로 정해 줘야 한다.</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>무지성으로 사용하던 정렬에 대해서 다시 한 번 생각하게 된 계기가 된 문제다. 필자는 처음 이 문제를 풀이할 때, 정렬하는 대상을 숫자라고 오인해 <code class="language-plaintext highlighter-rouge">key=len</code> 을 사용해 정렬을 했다. 이렇게 하면 문제가 무조건 이중 루프를 사용해야만 한다. 그러면 시간 초과에 걸리기 때문에 문제를 해결할 수 없다.</p>

<p>문제를 틀리고 나서 생각을 해보니, 정렬하는 대상은 실제 숫자가 아니라 <code class="language-plaintext highlighter-rouge">‘숫자처럼 생긴’</code> 문자열이다. 이 점을 잘 이용하면, 앞자리의 숫자가 비슷한 것끼리 뭉치게 정렬을 해줄 수 있다. 그렇다면 굳이 이중루프를 사용할 필요가 사라지고, 바로 옆 원소와 대조만 해도 <code class="language-plaintext highlighter-rouge">global optimal</code>을 기대해볼 수 있게 된다. 하지만 길이를 기준으로 문자열을 정렬한 것은 아니기 때문에 슬라이싱 기준을 <code class="language-plaintext highlighter-rouge">min()</code>을 이용해 더 짧은 문자열로 삼아줘야 한다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="String Handle" /><summary type="html"><![CDATA[백준 5052번 전화번호 목록]]></summary></entry><entry><title type="html">👩‍💻🔠 [baekjoon] 12891번: DNA 비밀번호</title><link href="http://localhost:4000/algorithm/baekjoon-12891" rel="alternate" type="text/html" title="👩‍💻🔠 [baekjoon] 12891번: DNA 비밀번호" /><published>2023-08-28T00:00:00+09:00</published><updated>2023-08-29T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/baekjoon_12891</id><content type="html" xml:base="http://localhost:4000/algorithm/baekjoon-12891"><![CDATA[<h3 id="️solution"><code class="language-plaintext highlighter-rouge">🖍️ solution</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">deque</span>

<span class="s">"""
[시간]
1) 21:30 ~ 22:00

[요약]
1) DNA 문자열: A, C, G, T로만 구성된 문자열
    =&gt; DNA 문자열의 일부를 뽑아 비밀번호로 사용
    =&gt; 추출 기준은 서로 다른 문자의 개수가 특정 개수 이상 등장해야 함
    =&gt; 만들 수 있는 비밀번호 종류, 추출된 위치가 다르면 문자열이 같아도 다른 비밀번호로 취급
[전략]
1) collections.Counter 사용
    - 처음 슬라이딩 부분까지만 계산
"""</span>
<span class="n">S</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">dna</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
<span class="n">chars</span> <span class="o">=</span> <span class="p">[</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'G'</span><span class="p">,</span> <span class="s">'T'</span><span class="p">]</span>
<span class="n">result</span><span class="p">,</span> <span class="n">minimal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">chars</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())))}</span>

<span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">dna</span><span class="p">[:</span><span class="n">P</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">P</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">counter</span><span class="p">[</span><span class="n">dna</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">P</span><span class="p">]]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">counter</span><span class="p">[</span><span class="n">dna</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">checker</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">chars</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">counter</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minimal</span><span class="p">[</span><span class="n">char</span><span class="p">]:</span>
            <span class="n">checker</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="n">checker</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><code class="language-plaintext highlighter-rouge">💡 idea</code></h3>

<ul>
  <li><strong>1)  Sliding Window 사용</strong>
    <ul>
      <li><strong>개별 윈도우에 포함된 철자의 개수를 세어 기준치를 넘기는지 대조</strong>
        <ul>
          <li><strong><code class="language-plaintext highlighter-rouge">Time Complexity</code> 고려해, <code class="language-plaintext highlighter-rouge">collections.Counter</code>는 처음 윈도우에 한 번 사용</strong>
            <ul>
              <li><strong><code class="language-plaintext highlighter-rouge">Input</code>이 백만까지라서 모든 윈도우에 <code class="language-plaintext highlighter-rouge">Counter</code> 적용하면 <code class="language-plaintext highlighter-rouge">O(n^2)</code>으로 시간 초과 발생할 가능성 있음</strong></li>
            </ul>
          </li>
          <li><strong>이후 윈도우를 옮기면서 변화되는 철자의 개수만 수정</strong>
            <ul>
              <li><strong>맨 앞의 철자에 대한 개수를 한 개 빼주고, 앞으로 추가될 철자의 개수를 하나 늘려준다</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>비밀번호라고 판정하는 기준이 특정 철자의 개수라는 점에 유의해, 슬라이딩 윈도우를 변형하면 시간 초과되지 않고 문제를 해결할 수 있다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="String Handle" /><summary type="html"><![CDATA[백준 12891번 DNA 비밀번호 풀이]]></summary></entry><entry><title type="html">👩‍💻🔠 [baekjoon] 1969번: DNA</title><link href="http://localhost:4000/algorithm/baekjoon-1969" rel="alternate" type="text/html" title="👩‍💻🔠 [baekjoon] 1969번: DNA" /><published>2023-08-28T00:00:00+09:00</published><updated>2023-08-29T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/baekjoon_1969</id><content type="html" xml:base="http://localhost:4000/algorithm/baekjoon-1969"><![CDATA[<h3 id="️solution"><code class="language-plaintext highlighter-rouge">🖍️ solution</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="s">"""
[시간]
1) 20:00 ~ 20:30

[요약]
1) DNA를 이루는 뉴클레오티드의 첫글자를 따서 표현, 종류는 4가지
    - A, T, G, C
2)  N개의 길이 M인 DNA가 주어지면 Hamming Distance의 합이 가장 작은 DNA S를 구하기
    - Hamming Distance: 각 위치의 뉴클오티드 문자가 다른 것의 개수
    =&gt; 자기 자신을 제외한 나머지 모든 원소와 Hamming Distance를 구하고 총합이 가장 작은 아이를 리턴해라
"""</span>
<span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">dna</span> <span class="o">=</span> <span class="p">[</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="n">result</span><span class="p">,</span> <span class="n">char_list</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]</span>  <span class="c1"># for append char, count
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">tmp</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">dna</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
    <span class="n">rank_counter</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">counter</span><span class="p">.</span><span class="n">most_common</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>  <span class="c1"># - 붙인 정렬 조건은 현재 정렬 기준과 반대로
</span>    <span class="n">result</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">counter</span><span class="p">.</span><span class="n">values</span><span class="p">())</span> <span class="o">-</span> <span class="n">rank_counter</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># counting
</span>    <span class="n">char_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">rank_counter</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># append char
</span>
<span class="k">print</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">char_list</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><code class="language-plaintext highlighter-rouge">💡 idea</code></h3>

<ul>
  <li><strong>1)  <code class="language-plaintext highlighter-rouge">linear search</code> 하면서 한 개라도 철자가 다른 자리수 찾기</strong>
    <ul>
      <li><strong>빈도수가 가장 높은 철자를 해당 자리의 문자로 결정, <code class="language-plaintext highlighter-rouge">collections.Counter</code> 이용</strong>
        <ul>
          <li><strong>최빈값이 여러개인 상황 (사전식 우선)</strong>
            <ul>
              <li><strong>다중 정렬 사용해 최빈값 &amp; 사전식 정렬 동시 적용</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>문제 풀이에 필요한 아이디어보다 다중 정렬 사용법을 정확히 아는 것이 해결에 더 중요했던 문제다. 코드 주석에 써있는대로 <code class="language-plaintext highlighter-rouge">-</code> 붙인 조건은 현재 정렬 기준과 반대로 정렬할 수 있다. 이걸 모르면 해결하기 꽤나 까다로운 문제라고 생각한다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="String Handle" /><summary type="html"><![CDATA[백준 1969번 괄호 풀이]]></summary></entry><entry><title type="html">👩‍💻🔠 [baekjoon] 1254번: 팰린드롬 만들기</title><link href="http://localhost:4000/algorithm/baekjoon-1254" rel="alternate" type="text/html" title="👩‍💻🔠 [baekjoon] 1254번: 팰린드롬 만들기" /><published>2023-08-24T00:00:00+09:00</published><updated>2023-08-25T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/baekjoon_1254</id><content type="html" xml:base="http://localhost:4000/algorithm/baekjoon-1254"><![CDATA[<h3 id="️solution"><code class="language-plaintext highlighter-rouge">🖍️ solution</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="s">"""
[풀이 시간]
1) 17:00 ~ 17:30

[요약]
1) 규완이가 적어놓고 간 문자열 S에 0개 이상의 문자를 문자열 뒤에 추가해서 팰린드롬을 만들려고 한다.
    - 가능한 짧은 문자열을 추가해 펠린드롬을 만들고 싶음
[전략]
1) 그냥 무식 단순 루프 돌리기
"""</span>
<span class="n">text</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
<span class="n">result</span><span class="p">,</span> <span class="n">slicer</span> <span class="o">=</span> <span class="mi">99999</span><span class="p">,</span> <span class="mi">1</span>

<span class="c1"># input is palindrome
</span><span class="k">if</span> <span class="n">text</span> <span class="o">==</span> <span class="n">text</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)):</span>
        <span class="n">tmp_text</span> <span class="o">=</span> <span class="n">text</span> <span class="o">+</span> <span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tmp_text</span> <span class="o">==</span> <span class="n">tmp_text</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_text</span><span class="p">)</span>
            <span class="k">break</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><code class="language-plaintext highlighter-rouge">💡 idea</code></h3>

<ul>
  <li><strong>1)  주어진 입력의 하위 시퀀스를 입력에 덧붙여 팰린드롬 여부 판단</strong>
    <ul>
      <li><strong>추가 시퀀스를 최소한으로 사용하는게 목적이라 1글자짜리부터 시작</strong>
        <ul>
          <li><strong>짧은 시퀀스부터 루프를 시작했기 때문에, 팰린드롬으로 판정되는 순간 루프 종료</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>좀 예쁘게 풀어보고 싶었으나, 아이디어가 딱히 떠오르지 않아 무식하게 루프를 돌렸다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="String Handle" /><summary type="html"><![CDATA[백준 1254번 괄호 풀이]]></summary></entry><entry><title type="html">👩‍💻🔠 [baekjoon] 14425번: 문자열 집합</title><link href="http://localhost:4000/algorithm/baekjoon-14425" rel="alternate" type="text/html" title="👩‍💻🔠 [baekjoon] 14425번: 문자열 집합" /><published>2023-08-24T00:00:00+09:00</published><updated>2023-08-25T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/baekjoon_14425</id><content type="html" xml:base="http://localhost:4000/algorithm/baekjoon-14425"><![CDATA[<h3 id="️solution"><code class="language-plaintext highlighter-rouge">🖍️ solution</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="s">"""
[풀이 시간]
1) 16:30 ~ 16:50

[요약]
1) N개의 문자열로 이루어진 집합 S가 주어진다.
    - 입력으로 주어지는 M개의 문자열 중에서 집합 S에 포함되어 있는 것이 총 몇 개인지 구하는 프로그램 작성
[전략]
1) 세트 교차 방식 (시간 효율성 GOOD)
    - 집합 S에 중복 문자열은 없지만, M개의 문자열 속에는 중복 문자열 존재 가능
    - 중복 문자열까지 모두 세어주도록 코드를 작성해야 함
    =&gt; 그게 까다로우니까 사전 대조 방식으로 문제를 해결하자
2) 사전 대조 방식 (공간 효율성 GOOD)
"""</span>
<span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">result</span><span class="p">,</span> <span class="n">str_dict</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">str_dict</span><span class="p">[</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()]</span> <span class="o">=</span> <span class="bp">True</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">str_tmp</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">str_dict</span><span class="p">[</span><span class="n">str_tmp</span><span class="p">]:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span> <span class="nb">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">pass</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><code class="language-plaintext highlighter-rouge">💡 idea</code></h3>

<ul>
  <li><strong>1) 사전 대조 방식 이용</strong>
    <ul>
      <li><strong>집합 S에 속하는 모든 문자열을 사전에 투입,  <code class="language-plaintext highlighter-rouge">value</code>는 <code class="language-plaintext highlighter-rouge">True</code>로 초기화</strong></li>
      <li><strong>예외 처리 구문 이용, M개의 문자열이 사전에 존재하는지 대조</strong>
        <ul>
          <li><strong>이미 있다면, 교집합 처리</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>문제에서 집합 S에는 중복 문자열이 없다고 언급하지만, M개의 문자열에 대해서는 그런 조건이 없다. 즉, 중복 문자열이 존재할 수 있다는 말이다. 그래서 세트 자료형 방식으로 문제를 풀게 되면 중복 문자열 처리를 해주는게 까다로워진다. 따라서 사전 대조 방식을 선택해 문제를 해결했다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="String Handle" /><summary type="html"><![CDATA[백준 14425번 괄호 풀이]]></summary></entry><entry><title type="html">👩‍💻🔠 [baekjoon] 1764번: 듣보잡</title><link href="http://localhost:4000/algorithm/baekjoon-1764" rel="alternate" type="text/html" title="👩‍💻🔠 [baekjoon] 1764번: 듣보잡" /><published>2023-08-24T00:00:00+09:00</published><updated>2023-08-25T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/baekjoon_1764</id><content type="html" xml:base="http://localhost:4000/algorithm/baekjoon-1764"><![CDATA[<h3 id="️solution-1"><code class="language-plaintext highlighter-rouge">🖍️ solution 1</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="s">"""
[풀이 시간]
1) 15:50 ~ 16:10

[요약]
1) 명단 A, 명단 B의 교집합 구하는 문제

[전략]
1) 두 명단을 세트 자료형에 넣고 교집합을 구해주기
"""</span>
<span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">set_a</span><span class="p">,</span> <span class="n">set_b</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">()</span>

<span class="c1"># 듣도 못한 사람 명단
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">set_a</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">())</span>

<span class="c1"># 보도 못한 사람 명단
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">set_b</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">())</span>

<span class="n">result_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">set_a</span> <span class="o">&amp;</span> <span class="n">set_b</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result_list</span><span class="p">))</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">result_list</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea-1"><code class="language-plaintext highlighter-rouge">💡 idea 1</code></h3>

<ul>
  <li><strong>1) 두 명단을 개별 세트 자료형에 넣고 교집합 확인</strong></li>
</ul>

<h3 id="️solution-2"><code class="language-plaintext highlighter-rouge">🖍️ solution 2</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="s">"""
[풀이 시간]
1) 15:50 ~ 16:10

[요약]
1) 명단 A, 명단 B의 교집합 구하는 문제

[전략]
1) 명단 A의 애들을 전부 사전에 넣어 주자
"""</span>
<span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">result_list</span><span class="p">,</span> <span class="n">name_dict</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">{}</span>

<span class="c1"># 듣도 못한 사람 명단
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">name_dict</span><span class="p">[</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()]</span> <span class="o">=</span> <span class="bp">True</span>

<span class="c1"># 보도 못한 사람 명단
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">tmp_name</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name_dict</span><span class="p">[</span><span class="n">tmp_name</span><span class="p">]:</span>
            <span class="n">result_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp_name</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="n">result_list</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result_list</span><span class="p">))</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">result_list</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea-2"><code class="language-plaintext highlighter-rouge">💡 idea 2</code></h3>

<ul>
  <li><strong>1) 한쪽 명단을 모두 사전에 넣기</strong>
    <ul>
      <li><strong>사전의 <code class="language-plaintext highlighter-rouge">value</code>는 <code class="language-plaintext highlighter-rouge">True</code>로 모두 초기화</strong></li>
    </ul>
  </li>
  <li><strong>2) 다음 명단의 개별 사람들을 이미 사전에 있는지 대조</strong>
    <ul>
      <li><strong>예외 처리 구문을 이용, 사전에 이미 등재된 사람이라면 결과 리스트에 추가</strong></li>
    </ul>
  </li>
</ul>

<h3 id="-comparison"><code class="language-plaintext highlighter-rouge">😇 Comparison</code></h3>

<p align="center">
<img src="/assets/images/algorithm/test_result.png" alt="결과 비교" class="align-center image-caption" width="85%&quot;, height=&quot;50%" />
<strong><em>결과 비교</em></strong>
</p>

<p>제일 상단의 제출 결과가 <code class="language-plaintext highlighter-rouge">solution 1</code>, 하단의 결과가 <code class="language-plaintext highlighter-rouge">solution 2</code>에 해당 된다. 시간 복잡도는 전자가, 공간 복잡도는 후자가 더 효율적인 것으로 나타난다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="String Handle" /><summary type="html"><![CDATA[백준 1764번 괄호 풀이]]></summary></entry><entry><title type="html">👩‍💻🔠 [baekjoon] 5430번: AC</title><link href="http://localhost:4000/algorithm/baekjoon-5430" rel="alternate" type="text/html" title="👩‍💻🔠 [baekjoon] 5430번: AC" /><published>2023-08-24T00:00:00+09:00</published><updated>2023-08-25T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/baekjoon_5430</id><content type="html" xml:base="http://localhost:4000/algorithm/baekjoon-5430"><![CDATA[<h3 id="️solution"><code class="language-plaintext highlighter-rouge">🖍️ solution</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="s">"""
[시간]
1) 18:25 ~ 18:55

[요약]
1) 새로운 언어 AC: AC는 정수 배열에 연산을 하기 위해 만든 언어
    - R(뒤집기): 배열에 있는 수의 순서를 뒤집는 함수 =&gt; reversed
    - D(버리기): D는 첫 번째 수를 버리는 함수 =&gt; queue
2) 특정 동작을 의미하는 문자열을 입력 받아 의도한 처리를 하는 프로그램을 만들기
[전략]
1) 무식하게 만들자
"""</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())):</span>
    <span class="n">method_seq</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">())</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">target_list</span><span class="p">,</span> <span class="n">checker</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">()),</span> <span class="n">deque</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">())),</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">method_seq</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">'R'</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">target_list</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">target_list</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'error'</span><span class="p">)</span>
            <span class="n">checker</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">break</span>
            
    <span class="k">if</span> <span class="ow">not</span> <span class="n">checker</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s">'['</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">(</span><span class="n">target_list</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'[]'</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">count</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">target_list</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="o">+</span> <span class="s">','</span>
            <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s">']'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">target_list</span><span class="p">)):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="o">+</span> <span class="s">','</span>
            <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s">']'</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><code class="language-plaintext highlighter-rouge">💡 idea</code></h3>

<ul>
  <li><strong>1)  문자열 리스트 to Python List</strong>
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">eval()</code> , <code class="language-plaintext highlighter-rouge">ast.literal_eval()</code> 을 적용해 파이썬의 리스트로 변환</strong></li>
    </ul>
  </li>
  <li><strong>2) <code class="language-plaintext highlighter-rouge">reverse</code> 연산 대체</strong>
    <ul>
      <li><strong>파이썬으로 풀면 시간 제한 때문에 루프마다 <code class="language-plaintext highlighter-rouge">reverse</code>를 수행할 수 없는 문제 발생</strong>
        <ul>
          <li><strong><code class="language-plaintext highlighter-rouge">popleft</code>, <code class="language-plaintext highlighter-rouge">pop</code> 동시에 가지고 있는 <code class="language-plaintext highlighter-rouge">collections.deque</code> 이용해서 루프 내부에서 <code class="language-plaintext highlighter-rouge">reverse</code> 수행을 피함</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>3) 출력 문자열</strong>
    <ul>
      <li><strong>예제 출력을 보면 리스트의 원소 사이에 공백이 없음</strong>
        <ul>
          <li><strong>파이썬 내장 리스트를 그대로 출력하면 원소 사이의 공백 때문에 문제를 틀리게 된다</strong></li>
          <li><strong>루프 돌려서 내장 리스트를 다시 문자열 리스트로 변환</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>풀이 필요한 아이디어가 복잡하기보다 여러 함정을 잘 피해야 풀 수 있는 문제다. 문자열로 주어지는 리스트를 <code class="language-plaintext highlighter-rouge">eval()</code> , <code class="language-plaintext highlighter-rouge">ast.literal_eval()</code>같은 내장 메서드를 이용해 효율적으로 파이썬 리스트로 인식시키는 것부터 마지막에 출력에 공백을 없애주는 것까지 출제자가 맘먹고 함정을 여러개 파놨다. 실제 시험에 나오면 솔직히 틀릴 것 같다. 실전에서 이렇게 여러 함정을 과연 잘 피해갈 수 있을지…</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="String Handle" /><summary type="html"><![CDATA[백준 5430번 괄호 풀이]]></summary></entry><entry><title type="html">👩‍💻🔠 [baekjoon] 1316번: 그룹 단어 체커</title><link href="http://localhost:4000/algorithm/baekjoon-1316" rel="alternate" type="text/html" title="👩‍💻🔠 [baekjoon] 1316번: 그룹 단어 체커" /><published>2023-08-20T00:00:00+09:00</published><updated>2023-08-21T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/baekjoon_1316</id><content type="html" xml:base="http://localhost:4000/algorithm/baekjoon-1316"><![CDATA[<h3 id="️solution"><code class="language-plaintext highlighter-rouge">🖍️ solution</code></h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="s">"""
[풀이 시간]
1) 16:30 ~ 17:50

[요약]
1) 그룹 문자: ccazzzzbb, kin
    - 아닌 경우: aabbbccb (b가 혼자 떨어져 있기 때문에 그룹 문자열이 아님)
"""</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">N</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">word_set</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">}</span>
    <span class="n">word</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">word</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">in</span> <span class="n">word_set</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="ow">and</span> <span class="n">word</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">word</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">word_set</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><code class="language-plaintext highlighter-rouge">💡 idea</code></h3>

<ul>
  <li><strong>1) 선형으로 문자열을 탐색</strong>
    <ul>
      <li><strong>탐색 도중, 현재 철자가 세트 자료형에 이미 있는 경우</strong>
        <ul>
          <li><strong>현재 문자열은 비그룹 단어로 간주</strong></li>
        </ul>
      </li>
      <li><strong>탐색 도중, 현재 철자와 바로 다음 시점 철자가 다른 경우</strong>
        <ul>
          <li><strong>세트 자료형에 현재 철자 추가</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="String Handle" /><summary type="html"><![CDATA[백준 1316 그룹 단어 체커 풀이]]></summary></entry></feed>