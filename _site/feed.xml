<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-11-15T16:20:22+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">AI/Business Study Log</title><subtitle>NLP, Marketing</subtitle><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><entry><title type="html">🍎 Newton-Raphson Method for Optimization</title><link href="http://localhost:4000/optimization-theory/newton-raphson" rel="alternate" type="text/html" title="🍎 Newton-Raphson Method for Optimization" /><published>2023-11-15T00:00:00+09:00</published><updated>2023-11-16T02:00:00+09:00</updated><id>http://localhost:4000/optimization-theory/newton_raphson</id><content type="html" xml:base="http://localhost:4000/optimization-theory/newton-raphson"><![CDATA[<h3 id="zero-find-ver"><code class="language-plaintext highlighter-rouge">🤔 Zero-Find Ver</code></h3>

<p>비선형 방정식의 근사해를 찾거나 최적화 문제를 해결하는 방식으로, 같은 과정을 반복해 최적값에 수렴한다는 점에서 경사하강법이랑 근본이 같다. 반면, 경사하강에 비해 빠른 수렴 속도를 자랑하고 풀이 방식이 매우 간단하다는 장점이 있다. 하지만 여러 제약 조건과 더불어 해당 알고리즘이 잘 작동하는 상황이 비현실적인 부분이 많아 경사하강에 비해 자주 사용되지는 않고 있다. 뉴턴-랩슨 방식은 근사해를 찾거나, 최적화 문제를 푸는 두 가지 버젼이 있는데 먼저 해를 찾는 버전부터 살펴보자. 알고리즘의 수식은 다음과 같다.</p>

\[x_{n+1}:= x_n - \frac{f(x_n)}{f'(x_n)}\]

<p>반복법을 사용하기 때문에 수식의 생김새가 상당히 경사하강법과 비슷하다. 왜 이런 수식이 등장하게 되었을까?? 일단 뉴턴-랩슨 방식의 풀이 과정을 살펴보자. 먼저 초기값을 설정한다. 그 다음 해당 점을 지나는 접선의 방정식을 세운다. 이제 접선의 방정식의 $x$절편을 구하고 이것을 다음 초기값으로 사용한다. 이제 $f(x_n) \approx 0$이 될 때까지 위 과정을 지속적으로 반복하면 된다. 아래 그래프와 함께 다시 살펴보자.</p>

<p align="center">
<img src="/assets/images/optimization/zero_find.png" alt="Newton-Raphson for Zero Find" class="align-center image-caption" width="60%&quot;, height=&quot;50%" />
<strong><em><a href="">Newton-Raphson for Zero Find</a></em></strong>
</p>

<p>초기값은 $x_0=3$이다. 시작점 $(x_0, f(x_0))$을 지나는 접선의 방정식을 세우고 해당 방정식의 $x$절편을 구하는 수식을 작성하면 아래와 같다.</p>

\[f'(x_0)(x-x_n) + f(x_0) = 0\]

<p>이제 이것을 예쁘게 잘 정리해서 다음 초기값 $x_1$을 구해보자.</p>

\[x = x_0 - \frac{f(x_0)}{f'(x_0)}\]

<p>이번 포스트 맨 처음에 봤던 뉴턴-랩슨 방법의 수식과 똑같다는 것을 알 수 있다. 다시 말해 뉴턴-랩슨의 Zero-Find 버전은 접선의 방정식의 $x$절편을 활용해 목적 함수의 해를 찾아가는 방식인 것이다.</p>

<p>지금까지 근사해를 찾아주는 뉴턴-랩슨 메서드를 살펴보았다. 하지만 머신러닝처럼 현실의 최적화 문제를 풀어야 하는 우리 입장에서는 단순 목적 함수의 근을 찾는 것만으로는 주어진 문제를 해결할 수 없다. 머신러닝의 최적화 대상인 비용 함수는 거의 모든 경우에 근이 없기(베이지안 오차까지 고려하면 사실상 불가능) 때문에 일단 알고리즘의 가정 자체가 성립하지 않는다. 이러한 한계점을 극복하고자 최적화 버전의 뉴턴-랩슨 메서드가 등장하게 된다.</p>

<h3 id="optimization-ver"><code class="language-plaintext highlighter-rouge">📉 Optimization Ver</code></h3>

\[x_{n+1}:= x_n - \frac{f'(x_n)}{f''(x_n)}\]

<p>최적화 버전의 뉴턴 랩슨 메서드는 이계도함수를 사용한다. 원함수(비용함수)가 근이 없을지라도, 함수의 극점이 존재하는한 도함수의 근은 항상 존재한다는 가정에서 출발한다. 근을 찾는 행위는 동일하게 하되, 이번에는 원함수의 근이 아니라 도함수의 근을 찾는다. 도함수의 근사해를 찾으면, 해당 위치는 국소/전역 최적값에 근접한 수치일 것이라고 기대해볼 수 있다.</p>

<p>하지만 최적화 버전의 뉴턴 랩슨 메서드 역시 여전히 많은 단점을 갖고 있다. 일단 먼저 계산량이 지나치게 많아진다. 예시를 모두 스칼라 형태로 들어서 간단해 보이지만, 다변수함수에 적용하면 과정이 매우 매우 복잡해진다. 모든 <code class="language-plaintext highlighter-rouge">iteration</code> 마다 자코비안, 헤시안 행렬을 구해줘야 한다. 도함수만 이용하는 경사 하강에 비해 연산 부담이 상당히 커질 수 밖에 없는 것이다. 그리고 결정적으로 헤시안 행렬이 <code class="language-plaintext highlighter-rouge">invertible</code> 해야한다. 이게 개인적으로 <code class="language-plaintext highlighter-rouge">뉴턴-랩슨</code> 방식의 가장 큰 단점이라고 생각한다. 헤시안 행렬의 역행렬이 존재하려면 반드시 원함수는 <code class="language-plaintext highlighter-rouge">Convex Function</code>이어야 하기 때문이다. 따라서 상당히 비현실적인 풀이 방식이라고 볼 수 있다.</p>

<p>한편, 위 모든 제약 조건을 만족한다면 최적화 버전의 뉴턴-랩슨 방식은 경사하강에 비해 상당히 빠른 수렴 속도를 갖는데 그 이유를 간단히 살펴보자. 결과부터 설명하면 뉴턴-랩슨 방식이 사실상 <code class="language-plaintext highlighter-rouge">Least Square Method(최소 자승법)</code> 와 동치라서 그렇다. 목적함수 $f(x)$를 <code class="language-plaintext highlighter-rouge">MSE</code> 로 두고 선형 회귀 문제를 푸는 상황을 가정해보자.</p>

\[Z = Ax+n \\
f(x) = (Z-Ax)^T(Z-Ax)\]

<p>목적함수를 정의했기 때문에 우리는 이제 목적함수의 도함수와 이계도함수를 구할 수 있다.</p>

\[f'(x) = -2A^T(Z-Ax)\\
f''(x) = 2A^tA\]

<p>도함수와 이계도 함수를 뉴턴—랩슨 수식에 대입하면 다음과 같다.</p>

\[x_{n+1} := x_n + \frac{A^T(Z-Ax)} {A^TA} = x_n + (A^TA)^{-1}A^T(Z-Ax)\]

<p>분모는 헤시안 행렬과 동치다. 행렬로 어떤 수를 나눌 수는 없기 때문에 나눗셈 표현 대신 역행렬로 표기했다. 그리고 수식이 상당히 더럽기 때문에 정리를 위해 전개를 해보려 한다. 전개 결과는 다음과 같다.</p>

\[x_{n+1} := x_n + (A^TA)^{-1}A^TZ - (A^TA)^{-1}A^TAx_n = (A^TA)^{-1}A^TZ\]

<p>헤시안 행렬이 <code class="language-plaintext highlighter-rouge">invertible</code> 해야한다라는 제약 조건이 여기서 등장한다. 만약 헤시안 행렬이 <code class="language-plaintext highlighter-rouge">invertible</code> 이라면, 다 날라가고 우변의 항만 남게 된다. 우변의 항을 자세히 살펴보면, <code class="language-plaintext highlighter-rouge">Least Square Method(최소 자승법)</code> 의 수식과 동일하다는 것을 알 수 있다. 경사하강과는 다르게 $x_n$과 관련된 항이 수식에 전혀 남아있지 않기 때문에, 최소 자승법 수식을 한 번 풀어내는 것만으로 극점에 도달하여 수렴속도가 훨씬 빠르게 되는 것이다.</p>

<p align="center">
<img src="/assets/images/optimization/gd_nr_1.png" alt="Newton-Raphson for Optimization" class="align-center image-caption" width="60%&quot;, height=&quot;50%" />
<strong><em><a href="">Newton-Raphson for Optimization</a></em></strong>
</p>

<p>두 방식이 최적화 문제를 풀어나가는 과정을 비교하기 위해 시각화를 시도해봤다. 필자의 시각화 실력이 매우 좋지 못해 그 차이가 직관적으로 잘 안보인다… 빨간 직선은 뉴턴-랩슨 방식이고 파란 직선은 경사 하강 방법이다. 전자는 위에서 살펴본 것처럼 한번에 극소점으로 이동하는 것을 볼 수 있다. 한편 후자는 수많은 <code class="language-plaintext highlighter-rouge">Iteration</code> 을 거쳐 극소점에 도달한다. 필자의 시각화 자료가 상당히 좋지 못하다고 생각해 하단에 <a href="https://www.youtube.com/watch?v=MlZoafOnMS0&amp;list=PL_iJu012NOxeMJ5TPPW1JZKec7rhjKXUy&amp;index=6&amp;ab_channel=%ED%98%81%ED%8E%9C%ED%95%98%EC%9E%84%7CAI%26%EB%94%A5%EB%9F%AC%EB%8B%9D%EA%B0%95%EC%9D%98">혁펜하임</a>님의 자료도 함께 첨부했으니 참고하자. 훨씬 직관적으로 잘 보인다.</p>

<p align="center">
<img src="/assets/images/optimization/gradient_vs_newton.png" alt="Newton-Raphson vs Gradient-Descent" class="align-center image-caption" width="60%&quot;, height=&quot;50%" />
<strong><em><a href="https://ibb.co/VjvkYL7">Newton-Raphson vs Gradient-Descent</a></em></strong>
</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Optimization Theory" /><category term="Optimization Theory" /><category term="Newton-Raphson" /><summary type="html"><![CDATA[최적화 문제를 위한 뉴턴-랩슨 메서드 설명]]></summary></entry><entry><title type="html">🗂️ Convex Optimization Problem</title><link href="http://localhost:4000/optimization-theory/convex" rel="alternate" type="text/html" title="🗂️ Convex Optimization Problem" /><published>2023-11-13T00:00:00+09:00</published><updated>2023-11-14T02:00:00+09:00</updated><id>http://localhost:4000/optimization-theory/convex_problem</id><content type="html" xml:base="http://localhost:4000/optimization-theory/convex"><![CDATA[<h3 id="convex-optimization-problem"><code class="language-plaintext highlighter-rouge">❓ Convex Optimization Problem</code></h3>

\[f(wx_1 + (1-w)x_2)≤ wf(x_1) + (1-w)f(x_2),\ \ w \in [0,1] \\
f''(x) ≥ 0\]

<p><code class="language-plaintext highlighter-rouge">Convex Problem</code> 이란, 목적 함수 $f(x)$가 <code class="language-plaintext highlighter-rouge">Convex Function</code> 이면서 <code class="language-plaintext highlighter-rouge">Feasible Set</code> 역시 <code class="language-plaintext highlighter-rouge">Convex Set</code> 이 되는 문제 상황을 일컫는다. <code class="language-plaintext highlighter-rouge">Convex Problem</code> 는 수학적 최적화에서 매우 중요한 개념인데, 그 이유는 해당 조건을 만족하면 <code class="language-plaintext highlighter-rouge">국소 최적해</code>가 <code class="language-plaintext highlighter-rouge">전역 최적해</code>와 동치가 되어 최적화 난이도가 급격히 낮아지기 때문이다. 또한 <code class="language-plaintext highlighter-rouge">Convex Problem</code>을 해결해 국소 최적해를 구하는 알고리즘은 이미 많이 개발 되어 있기 때문에 주어진 최적화 문제를 <code class="language-plaintext highlighter-rouge">Convex Problem</code>으로 치환해 해결하는게 가장 효율적이다. 한편, 여기서 <code class="language-plaintext highlighter-rouge">Feasible Set</code> 이란, 함수의 <code class="language-plaintext highlighter-rouge">실행 가능 영역•정의역</code>이라고 생각하면 된다. 아래 그림, 빨간 직선의 영역에 해당한다. 세트라는 명칭은 무한한 직선이 아닌 유한한 선분을 표현하는 용어라고 생각하면 된다.</p>

<p>위에 서술한 두개의 수식은 어떤 문제 상황이 <code class="language-plaintext highlighter-rouge">Convex Problem</code> 인지 아닌지 구분해주는 판별식의 역할을 한다. 왜 두 수식을 만족하면 <code class="language-plaintext highlighter-rouge">Convex Problem</code>이 되는지 살펴보고 마지막에는 <code class="language-plaintext highlighter-rouge">Convex Problem</code> 에서 왜 <code class="language-plaintext highlighter-rouge">국소 최적해</code>가 <code class="language-plaintext highlighter-rouge">전역 최적해</code>와 동치가 되는지 그 증명을 해보려 한다.</p>

<p align="center">
<img src="/assets/images/optimization/convex_function.png" alt="Convex Function" class="align-center image-caption" width="60%&quot;, height=&quot;50%" />
<strong><em><a href="">Convex Function</a></em></strong>
</p>

<h3 id="-jensens-inequality"><code class="language-plaintext highlighter-rouge">﹤ Jensen’s Inequality</code></h3>

<p>첫번째 수식을 보자. 우리는 이것을 <code class="language-plaintext highlighter-rouge">얀센 부등식</code>이라고 부른다. <code class="language-plaintext highlighter-rouge">얀센 부등식</code> 은 어떤 함수 $f(x)$의 <code class="language-plaintext highlighter-rouge">Convex Function</code> 여부를 판정 하는데 사용된다. 좌변은 <code class="language-plaintext highlighter-rouge">Feasible Set</code> 에 해당되는 데이터 포인트의 함수값을 의미하며 그림 상에서 초록색 곡선으로 표현된다. 한편, 우변은 <code class="language-plaintext highlighter-rouge">Feasible Set</code>의 평균변화율을 기울기로 하면서 구간 양쪽 끝을 지나는 선분을 일컫는다. 그림에서 파란색 직선이 바로 부등식의 우변이다.</p>

<p>그렇다면 위 부등식을 항상 만족하려면 함수 $f(x)$는 어떤 형태를 가져야 할까?? 먼저 오목 함수인 <code class="language-plaintext highlighter-rouge">Concave Function</code>부터 생각해보자. 위 그림을 뒤집어서 생각해보면 되는데, 함수가 정의되는 전체 정의역에서 위 부등식을 만족하는 구간(파란색 직선이 초록색 곡선보다 위에 있는)을 전혀 찾아볼 수 없다. 따라서 얀센 부등식을 만족하려면 <code class="language-plaintext highlighter-rouge">Feasible Set</code> 의 구간이 반드시 <code class="language-plaintext highlighter-rouge">Convex Set</code> 이어야 하고, 해당 구간에서 목적함수는 반드시 <code class="language-plaintext highlighter-rouge">Convex Function</code>의 형태를 띄고 있어야 한다.</p>

<p>그렇다면 목적함수가 <code class="language-plaintext highlighter-rouge">Convex</code>인지는 어떻게 판별할 수 있을까?? 주어진 모든 상황에서 위 그림처럼 쉽게 함수의 그래프를 그릴 수는 없을 것이다. 그래서 수식으로 어떤 목적함수가 <code class="language-plaintext highlighter-rouge">Convex</code>인지 판별할 수 있어야 한다. 드디어 제시된 두번째 수식을 활용할 차례다.</p>

<h3 id="second-derivative"><code class="language-plaintext highlighter-rouge">📈 Second Derivative</code></h3>

<p>두번째 수식을 흔히 이계도함수라고 부른다. 아마 수능 수학에서 21, 30번과 같은 킬러 문제를 풀 때 가끔씩 사용하던 기억이 날 것이다. 이계도함수는 도함수를 한 번 더 미분한 것으로 원함수의 곡선이 얼마나 빠르게 변하는지 혹은 곡선의 곡률에 대한 정보를 알려준다. 이를 통해 원함수의 극대, 극소는 물론 변곡점의 위치를 알아낼 수 있다. 그래서 어떤 이차함수를 예시로 들어보자. 2차항의 부호가 양수라면 이계도함수의 값은 항상 양수가 될 것이고, 음수라면 항상 음수가 될 것이다. 그런데 우리는 이미 직관적으로 2차함수에서 최고차항의 부호가 양수면 아래로 볼록한 함수, 반대의 경우 위로 오목한 오목함수가 된다는 것을 알고 있다. 따라서 이계도 함수의 값이 항상 양수라면 해당 함수는 <code class="language-plaintext highlighter-rouge">Convex Function</code>이 된다.</p>

<p>지금까지는 단변수 함수에 대한 케이스만 살펴보았다. 그렇다면 이것을 다변수로 확장할 수는 없을까?? 물론 가능하다. 어떤 다변수 함수가 <code class="language-plaintext highlighter-rouge">Convex</code>인지 판정하는 것도 위와 동일한 조건을 통해 판별한다. 이 때 등장하는게 바로 헤시안 행렬이다. 헤시안 행렬이란, 어떤 다변수 함수의 이계도함수값을 행렬로 나타낸 것이다. 단변수 함수의 이계도함수 역할과 동일하다. 그래서 어떤 다변수 함수가 컨백스 함수이려면, 헤시안 행렬이 <code class="language-plaintext highlighter-rouge">Positive Semi-Define</code> 조건을 만족해야 한다. 헤시안 행렬과 <code class="language-plaintext highlighter-rouge">Positive Semi-Define</code>에 대해서는 다른 포스트에서 자세히 다루도록 하겠다.</p>

<h3 id="-proof-local-minimum-same-as-global-minimum-in-convex"><code class="language-plaintext highlighter-rouge">🪪 Proof: local minimum same as global minimum in Convex</code></h3>

<p>이제 드디어 목적함수가 컨백스 함수일 때, 국소 최적해가 전역 최적해와 동치가 되는지를 증명해보려 한다. 먼저 증명은 귀류법을 사용한다. 귀류법이란, 수학, 논리학, 철학 등에서 주장이 부정됨을 보이기 위해 모순 또는 부정된 가정을 유도하는 논증 기법으로, 특정 주장이 참임을 증명하기보다는 그 반대인 부정된 주장이 거짓임을 보이는 데 사용한다. 그래서 귀류법을 활용해 다음과 같은 명제가 거짓임을 증명해보려 한다.</p>

<p>어떤 함수 $f(x)$는 Convex면서 Feasible Set이 Convex Set임을 만족하는 동시에 아래 수식을 만족한다고 한다.</p>

\[f(x^@) &lt; f(x^!)\]

<p>부등식의 우변은 국소 최적해를 의미하고, 좌변은 국소 최적해보다 작은 함수값이 존재한다고 가정한 것이다. 이제 이 명제가 틀림을 증명하면 우리는 자연스럽게 국소 최적해가 전역 최적해와 동치가 된다는 것을 확인할 수 있게 된다.</p>

<p>우리는 함수 $f(x)$가 <code class="language-plaintext highlighter-rouge">Convex</code>면서 <code class="language-plaintext highlighter-rouge">Feasible Set</code>이 <code class="language-plaintext highlighter-rouge">Convex Set</code>이라고 가정했기 때문에, $\alpha x^! + (1-\alpha)x^@$ 역시 <code class="language-plaintext highlighter-rouge">Feasible Set</code>이 될 것이다. 이러한 사실을 활용해 두 점($x^!, x^@$)을 얀센 부등식에 넣어보자.</p>

\[f(wx^! + (1-w)x^@)≤ wf(x^!) + f(x^!) - f(x^!) + (1-w)f(x^@) \\
f(wx^! + (1-w)x^@)≤ f(x^!) +(1-w)(f(x^@) -f(x^!))\]

<p>우변부터 함께 살펴보자. $(1-w)$는 반드시 양수가 된다. 얀센 부등식 정의상 $w \in [0,1]$을 만족하기 때문이다. 한편, $f(x^@) -f(x^!)$는 음수가 된다. 증명을 시작하면서 $f(x^@)$가 $f(x^!)$보다 작다고 가정했기 때문이다. 따라서 우변은 $f(x^!)$보다 아주 조금 작은 값(w→1)이 될 것이다. 이제 좌변을 살펴보자. 마찬가지로 w→1을 해주면 좌변은 $f(x^!)$의 매우 근접한 위치의 함수값을 보자는 의미가 된다. 좌변을 $\alpha$, 우변을 $\beta$로 치환해 지금까지 증명 과정을 다시 부등식으로 표현하면 다음과 같다.</p>

\[\alpha ≤ \beta &lt; f(x^!)\]

<p>우리는 $f(x^!)$가 지역 최소값이라고 정의한 바 있다. 지역 최소값이라는 것은 그 주변에서 가장 작은값이라는 의미를 갖는다. 그런데 $f(x^!)$의 주변값인 $\alpha$가 지역 최소값보다 작다고 부등식은 말하고 있기 때문에, 지역 최소값 정의에 위배되어 위 명제는 거짓이 된다.</p>

<p>정리하자면, 어떤 함수 $f(x)$가 컨백스 성질을 만족하면서, Feasible Set 역시 Convex Set인 경우에 국소 최소값이 전역 최소값이 아닐 경우, 국소 최적이 국소 최적이 아닌 경우가 발생하기 떄문에 반드시 위 조건에서 국소 최적값은 전역 최적값이 되어야 한다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Optimization Theory" /><category term="Optimization Theory" /><category term="Convex Optimization" /><summary type="html"><![CDATA[컨백스 최적화 문제 증명]]></summary></entry><entry><title type="html">🗂️ Graph Theory 5: MST with Kruskal &amp;amp; Prim</title><link href="http://localhost:4000/algorithm/mst" rel="alternate" type="text/html" title="🗂️ Graph Theory 5: MST with Kruskal &amp;amp; Prim" /><published>2023-11-11T00:00:00+09:00</published><updated>2023-11-12T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/mst</id><content type="html" xml:base="http://localhost:4000/algorithm/mst"><![CDATA[<h3 id="spanning-tree"><code class="language-plaintext highlighter-rouge">🎡 Spanning Tree</code></h3>

<p>그래프 내부에 포함된 모든 노드를 포함하는 트리를 의미한다. 모든 정점을 포함하긴 하지만 근본은 트리라서 사이클이 발생하면 안되며, 최소의 간선을 사용해 모든 노드를 연결해야 한다. 따라서 <code class="language-plaintext highlighter-rouge">Spanning Tree</code> 의 간선 개수는 <code class="language-plaintext highlighter-rouge">노드 개수-1</code>에 해당한다.</p>

<h3 id="minimum-spanning-tree"><code class="language-plaintext highlighter-rouge">💵 Minimum Spanning Tree</code></h3>

<p>그래프 상에서 발생할 수 있는 여러 <code class="language-plaintext highlighter-rouge">Spanning Tree</code> 중에서 간선들의 가중치 합이 최소인 트리를 의미한다. <code class="language-plaintext highlighter-rouge">MST</code>를 구현하는 알고리즘은 대표적으로 <code class="language-plaintext highlighter-rouge">Kruskal</code>, <code class="language-plaintext highlighter-rouge">Prim</code>알고리즘이 있다. 전자의 시간 복잡도는 <code class="language-plaintext highlighter-rouge">O(ElogE)</code>, 후자는 기본적으로 <code class="language-plaintext highlighter-rouge">O(N^2)</code>이라서 노드에 비해 간선 개수가 적은 희소 그래프의 경우는 Kruskal을, 노드에 비해 간선이 많은 밀집 그래프의 경우는 Prim을 사용하는게 시간 복잡도 측면에서 유리하다. 한편, Prim은 구현시에 선택하는 자료구조에 따라서 시간 복잡도를 최적화할 수 있다. 자세한 내용은 개별 알고리즘에 대한 설명에서 다루도록 하겠다.</p>

<h3 id="kruskal-algorithm-간선-선택"><code class="language-plaintext highlighter-rouge">🍃 Kruskal Algorithm (간선 선택)</code></h3>

<p>그리디하게 그래프의 모든 정점을 최소 비용으로 연결하는 방법이다. 구체적으로는 개별 시점에서 사이클을 이루지 않으면서 최소 비용인 간선을 경로로 선택한다. 그리디를 기반으로 하기 때문에 이전 결과, 미래 결과를 고려하지 않고 현재 최소 비용이 되는 간선만을 선택한다. 알고리즘의 구체적인 동작 과정은 다음과 같다.</p>

<ul>
  <li>1) 그래프의 간선들을 오름차순으로 정렬, 가중치 기준</li>
  <li>2) 사이클을 발생시키는지 여부를 체크하면서 순서대로 선택
    <ul>
      <li>가장 낮은 가중치부터 접근해 체크</li>
      <li>사이클 발생 X라면 선택</li>
    </ul>
  </li>
  <li>3) 선택한 간선을 <code class="language-plaintext highlighter-rouge">MST</code>집합에 추가</li>
</ul>

<p>사이클을 발생시키는지 여부를 체크하는 부분이 구현할 때 까다로울 수 있는데, Union-Find 알고리즘을 도입하면 수월하게 만들어 낼 수 있다. Union-Find를 도입한 Kruskal Algorithm을 Python 코드로 작성하면 다음과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" kruskal algorithm example: baekjoon 1043 """</span>

<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="s">""" method for finding root node """</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="s">""" method for union-find """</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>

<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>  <span class="c1"># number of nodes
</span><span class="n">M</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>  <span class="c1"># number of edges
</span><span class="n">graph</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># 0-0) 간선 연결 정보 초기화, 정렬
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">src</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">graph</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">cost</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
<span class="n">graph</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>

<span class="c1"># 0-1) 연결 정보 초기화
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

<span class="c1"># 1) Kruskal Algorithm
</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">weight</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">final</span><span class="p">):</span>
        <span class="n">union</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">weight</span>

<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<p>find 메서드는 입력한 노드의 루트 노드를 찾아 반환한다. 이것을 활용해 서로 다른 노드가 같은 집합(트리)에 속하는지 손쉽게 판정할 수 있으며 이것은 바꿔 생각해보면 선택된 두 노드가 사이클을 발생시키는지 여부를 알아 낼 수 있다는 것이다. 만약 두 노드가 같은 루트 노드값을 갖는다면, 결국 같은 집합(트리)에 속한다는 것을 의미하며, 이것은 사이클을 유발하게 되는 것이다. 따라서 사이클을 유발하는 정점은 선택하지 않으며, 트리의 성질을 유지할 수 있는 노드를 선택해 <code class="language-plaintext highlighter-rouge">union</code> 연산에 대입한다.</p>

<h3 id="prim-algorithm-정점-선택"><code class="language-plaintext highlighter-rouge">🔴 Prim Algorithm (정점 선택)</code></h3>

<p>특정 정점에서 시작해서 가중치가 작은 간선들 순서대로 트리를 확장해나가는 방법이다. 시작점을 지정한다는 점에서 다익스트라와 유사하며, 간선의 숫자가 많은 밀집 그래프 상황에서 <code class="language-plaintext highlighter-rouge">Kruskal</code>보다 빠르다. 구체적인 동작 방식은 다음과 같다.</p>

<ul>
  <li><strong>1) 선택 노드를 MST 집합에 추가</strong></li>
  <li><strong>2) MST 집합에 포함된 노드들에 인접한 정점들 탐색</strong>
    <ul>
      <li><strong>사이클 발생 여부 확인</strong>
        <ul>
          <li><strong>사이클 발생 X: 최소 가중치의 간선을 선택</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>3) 전체 간선의 개수가 N-1개가 될 때까지, 1 &amp; 2 과정  <code class="language-plaintext highlighter-rouge">Iteration</code></strong></li>
</ul>

<p>기본적으로는 <code class="language-plaintext highlighter-rouge">O(N^2)</code>의 시간복잡도를 기록한다. 하지만 자료구조 최적화에 따라서 <code class="language-plaintext highlighter-rouge">Kruskal</code>과 비슷한 시간복잡도인 <code class="language-plaintext highlighter-rouge">O(ElogE)</code>정도로까지 만들어 낼 수 있다. 최소 힙정렬과 우선순위 큐를 이용하면 된다. 힙정렬을 이용해 그래프 연결 정보를 가중치를 기준으로 오름차순 정렬을 한 뒤에, 사이클을 발생시키지 않는 인접 노드를 선택하도록 만든다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" prim algorithm example: baekjoon 1197 """</span>

<span class="kn">import</span> <span class="nn">sys</span><span class="p">,</span> <span class="n">heapq</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="s">"""
[풀이]
1) Prim with 우선순위 큐 (힙)
    - 시작점 선택, MST 집합에 추가
    - MST 집합의 노드들에 인접한 모든 정점 탐색
        - 사이클 발생 여부 확인: 방문 여부로 판정
        - 사이클 발생 X: 최소 가중치 간선 선택 (heapify를 통해 개별 노드마다 간선들을 가중치 기준 오름차순 정렬)
"""</span>

<span class="k">def</span> <span class="nf">prim</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">],</span> <span class="n">visit</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">visit</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>  <span class="c1"># 선택된 노드에 대한 모든 인접 간선 추출
</span>    <span class="n">heapq</span><span class="p">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>  <span class="c1"># 이미 생성되어 있는 자료구조에 대해서는 heapq.heapify를 사용하면 힙 성질을 만족하도록 할 수 있다
</span>    <span class="n">mst</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">tmp</span><span class="p">:</span>
        <span class="n">weight</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visit</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>  <span class="c1"># 미방문 노드로의 간선만 선택하는 방식으로, 사이클 발생 여부 판정하는 알고리즘을 구현
</span>            <span class="n">visit</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">mst</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">weight</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">visit</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]]:</span>
                    <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">total</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">():</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">prim</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 시작 노드를 어떤 것으로 설정해도 상관 없음
</span>    <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">sys</span><span class="p">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">V</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">graph</span><span class="p">,</span> <span class="n">visited</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">V</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
        <span class="n">src</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">src</span><span class="p">].</span><span class="n">append</span><span class="p">([</span><span class="n">cost</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">end</span><span class="p">])</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">end</span><span class="p">].</span><span class="n">append</span><span class="p">([</span><span class="n">cost</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">src</span><span class="p">])</span>
    <span class="n">solution</span><span class="p">()</span>
</code></pre></div></div>

<p>시작 정점은 아무거나 선택해도 상관없다. 그리고 가장 주목할 부분은 노드 선택시 사이클 여부를 판정하는 방법을 어떻게 구현했는가이다. 개별 노드에 대한 방문여부를 기록하는 배열을 따로 생성한 뒤, 방문(해당 노드와 연결되는 간선 선택)할 때 마다 방문 기록을 저장한다. 그리고 만약 어떤 노드를 선택했을 때, 이미 방문한 노드라면 해당 노드와 연결하는 간선의 가중치가 현재 가장 최소에 해당하더라도 사이클을 발생시키기 때문에 선택하지 않도록 사이클 여부를 판정하게 만들었다.<br />
<code class="language-plaintext highlighter-rouge">Kruskal</code>처럼 전체 모든 간선을 알고 있는 상태가 아님에도 최소 스패닝 트리의 조건을 만족하는 결과를 만들어 낼 수 있는 이유는 미리 개별 노드별 간선들을 가중치 기준으로 오름차순 정렬 해뒀기 때문이다. 이것 때문에 지역 최적들의 합이 전역 최적이 되어야 하는 그리디의 제약 조건을 만족시킬 수 있게 된다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="MST" /><category term="Kruskal" /><category term="Prim" /><summary type="html"><![CDATA[MST with Kruskal & Prim Algorithm]]></summary></entry><entry><title type="html">🗂️ Graph Theory 3: Floyd-Warshall</title><link href="http://localhost:4000/algorithm/floyd-warshell" rel="alternate" type="text/html" title="🗂️ Graph Theory 3: Floyd-Warshall" /><published>2023-11-11T00:00:00+09:00</published><updated>2023-11-12T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/floyd-warshell</id><content type="html" xml:base="http://localhost:4000/algorithm/floyd-warshell"><![CDATA[<h3 id="-floyd-warshall"><code class="language-plaintext highlighter-rouge">📚 Floyd-Warshall</code></h3>

<p><code class="language-plaintext highlighter-rouge">Floyd-Warshall</code>은 모든 지점에서 다른 모든 지점까지의 최단 경로를 구하는 알고리즘이다. 지정된 출발점에서 나머지 다른 지점가지의 최단 경로를 구하는 다익스트라 알고리즘과는 차이가 있다. 따라서 솔루션을 도출하는 방식에도 살짝 차이가 생기는데, <code class="language-plaintext highlighter-rouge">Floyd-Warshall</code> 은 그리디하게 매번 최단 경로에 있는 노드를 구할 필요가 없다. 이유는 모든 지점에서 다른 모든 지점까지의 경로를 구해야 하기 때문에 그리디 대신 <code class="language-plaintext highlighter-rouge">DP Tabulation</code>으로 문제를 풀기 때문이다.</p>

<p><code class="language-plaintext highlighter-rouge">Floyd-Warshall</code> 은 주어진 $N$ 개의 노드에 대해서 매번 $N^2$ 번의 연산을 통해 최단 거리를 갱신한다. 따라서 최종적으로 $O(N^3)$ 의 시간 복잡도를 갖게 된다. 연산은 직선 경로와 경유 경로를 비교하는 형태로 이뤄진다. 둘 중에서 더 작은 값이 <code class="language-plaintext highlighter-rouge">DP Table</code>에 저장된다. 여기서 경유 경로란 전체 $N$ 개의 노드에 대한 <code class="language-plaintext highlighter-rouge">iteration</code> 중에서 $i$ 번째 노드를 경유하는 경로를 말한다. 만약 직선 경로가 [$d, k$]라면 경유 경로는 [$d, i$] + [$i, k$] 가 된다. 우리는 테이블에 직선 경로와 경유 경로중에서 최단 거리만 저장하고 있기 때문에, 이렇게 하나의 노드에 대해서만 경유하는 경우만 고려해도 괜찮다. 만약 3개의 중간 노드를 경유해야만 최단 거리가 되는 경로가 있다고 가정해보자. 최적의 솔루션인 전체 경로의 부분 경로 역시 중간에 최단 경로로 선택되어 이미 테이블 어딘가에 값으로 자리 잡고 있게 된다. 따라서 결국엔 부분 집합의 합으로 전체 최적 솔루션인 경로를 도출해낼 수 있게 된다. 이러한 경우의 수를 고려하기 위해 <code class="language-plaintext highlighter-rouge">DP  Table</code>을 사용하게 된 것이라 생각한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" Floyd-Warshall Implementation """</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="s">"""
[Floyd-Warshall]
1) DP Table init
2) triple-loop
    - dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])
3) print result
"""</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>  <span class="c1"># 노드 개수
</span><span class="n">M</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>  <span class="c1"># 간선 개수
</span><span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

<span class="c1"># 1) DP Table init
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">src</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">dp</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>

<span class="c1"># 2) triple-loop
</span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>

<span class="c1"># 3) print result
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'INF'</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">' '</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="s">' '</span><span class="p">)</span>
    <span class="k">print</span><span class="p">()</span>
</code></pre></div></div>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Floyd-Warshall" /><summary type="html"><![CDATA[Floyd-Warshall Algorithm with DP Tabulation]]></summary></entry><entry><title type="html">🗂️ Graph Theory 2: Dijkstra</title><link href="http://localhost:4000/algorithm/dijkstra" rel="alternate" type="text/html" title="🗂️ Graph Theory 2: Dijkstra" /><published>2023-11-11T00:00:00+09:00</published><updated>2023-11-12T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/dijkstra</id><content type="html" xml:base="http://localhost:4000/algorithm/dijkstra"><![CDATA[<h3 id="-dijkstra"><code class="language-plaintext highlighter-rouge">📚 Dijkstra</code></h3>

<p>다익스트라 최단 경로 문제는 그래프 자료 구조에서 여러 개의 노드가 주어졌을 때, 특정한 노드(시작점)에서 특정한 노드(도착점)까지의 최단 경로를 구해주는 알고리즘을 설계해야 한다. 특히 다익스트라는 <code class="language-plaintext highlighter-rouge">음의 간선</code>이 없을 때 정상적으로 동작하며, 유향 &amp; 무향을 가리지 않고 적용할 수 있다. 다익스트라 알고리즘의 동작을 기술하면 아래와 같다.</p>

<ul>
  <li><strong>1) 출발 노드 설정</strong></li>
  <li><strong>2) 최단 거리 테이블 초기화(출발 노드 값은 0)</strong></li>
  <li><strong>3) 방문하지 않은 노드 중에서 현재 가장 가까운 노드를 선택(최단 거리 노드)</strong></li>
  <li><strong>4) 선택된 노드로부터 파생되는 다른 경로값 업데이트</strong></li>
  <li><strong>5) 모든 노드에 대한 계산 끝날 때까지 3~4번 반복</strong></li>
</ul>

<p>다익스트라 알고리즘을 설계하는 방법은 크게 두가지가 있다. 먼저 3번을 수행하기 위해 1) 최단 거리 테이블을 매번 선형 탐색하는 알고리즘,  2) 선형 탐색 대신에 힙 정렬을 이용해 가장 가까운 노드를 선택하는 방식이 있다. 1번의 경우 <code class="language-plaintext highlighter-rouge">O(V^2)</code> 가 되어 입력 노드가 1000개만 넘어가도 시간 초과를 당하기 때문에, 2번의 경우로 소스 코드를 작성하는 게 바람직하다. 코드 예시는 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" Dijkstra implementation """</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">h</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="n">distance</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">while</span> <span class="n">h</span><span class="p">:</span>
        <span class="n">min_cost</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="c1"># 방문한 노드 처리: cost를 기준으로 다음 노드를 선정, 따라서 cost가 distance[node]보다 크다면 이미 방문 했던 노드로 볼 수 있음
</span>        <span class="k">if</span> <span class="n">min_cost</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="n">min_cost</span> <span class="o">+</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cost</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
                <span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">cost</span>
                <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<span class="n">V</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">src</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>

<span class="c1"># 1) init graph
</span><span class="n">graph</span><span class="p">,</span> <span class="n">costs</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">V</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">costs</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">weight</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

<span class="n">dijkstra</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">costs</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">V</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span> <span class="k">else</span> <span class="s">'INF'</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Dijkstra" /><summary type="html"><![CDATA[Dijkstra Algorithm with Priority Queue]]></summary></entry><entry><title type="html">✏️  Summary of Useful Library for Coding Test</title><link href="http://localhost:4000/algorithm/useful_library" rel="alternate" type="text/html" title="✏️  Summary of Useful Library for Coding Test" /><published>2023-11-11T00:00:00+09:00</published><updated>2023-11-12T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/summary-of-useful-library</id><content type="html" xml:base="http://localhost:4000/algorithm/useful_library"><![CDATA[<h3 id="collections"><code class="language-plaintext highlighter-rouge">📚 collections</code></h3>

<h4 id="deque"><code class="language-plaintext highlighter-rouge">🪢 deque</code></h4>
<p><code class="language-plaintext highlighter-rouge">python</code>에서 <code class="language-plaintext highlighter-rouge">stack</code>이나 <code class="language-plaintext highlighter-rouge">queue</code> 자료형을 구현할 때 일반적으로 사용하는 내장 라이브러리 <code class="language-plaintext highlighter-rouge">collections</code>에 구현된 클래스다. 메서드가 아닌 객체라서 사용하려면 초기화가 필요하다. 사용 예시를 보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># collections.deque usage example
</span><span class="n">deque</span><span class="p">([</span><span class="n">iterable</span><span class="p">[,</span> <span class="n">maxlen</span><span class="p">]])</span> <span class="o">--&gt;</span> <span class="n">deque</span> <span class="nb">object</span>

<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">Counter</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span> <span class="c1"># 1)
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span>
<span class="n">deque</span><span class="p">([])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(())</span>  <span class="c1"># 2)
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span>
<span class="n">deque</span><span class="p">([])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([])</span> <span class="c1"># 3) 
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span>
<span class="n">deque</span><span class="p">([])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># 4)
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span>
<span class="n">deque</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># 5)
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span>
<span class="n">deque</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

</code></pre></div></div>

<p>객체를 초기화할 때 값을 넣어줄 것이 아니라면 리스트를 굳이 전달하지 않아도 똑같이 초기화가 된다. 다만, 특정값을 넣어줄 것이라면 반드시 <code class="language-plaintext highlighter-rouge">iterable</code> 객체를 전달해야 한다. 이 때 <code class="language-plaintext highlighter-rouge">iterable</code> 객체는 어떤 형태를 넣어도 같은 결과를 반환하게 된다. 예를 들어 리스트를 넣고 <code class="language-plaintext highlighter-rouge">deque</code>를 초기화 하나 튜플을 넣고 초기화 하나 결과는 같다는 것이다. 예시 코드의 4번과 5번 예시를 보자. 각각 리스트와 튜플을 넣고 초기화를 했지만 초기화 결과는 동일한 것을 확인할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># deque indexing &amp; slicing
</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">2</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">[:]</span>
<span class="nb">TypeError</span><span class="p">:</span> <span class="n">sequence</span> <span class="n">index</span> <span class="n">must</span> <span class="n">be</span> <span class="n">integer</span><span class="p">,</span> <span class="ow">not</span> <span class="s">'slice'</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">deque</code> 는 리스트처럼 인덱싱은 가능하지만, 슬라이싱 기능은 활용할 수 없으니 참고하자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># deqeue max_len example
</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="mi">6</span><span class="p">)</span>  <span class="c1"># 객체라서 초기화가 필요하다.
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span>
<span class="n">deque</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
</code></pre></div></div>

<p>한편, <code class="language-plaintext highlighter-rouge">max_len</code> 매개변수를 통해 선언한 객체의 최대 길이를 지정해 줄 수 있는데, 이 때 객체가 지정 길이를 넘어서면 큐의 동작처럼 가장 왼쪽에 위치한 원소를 먼저 빼고 새로운 원소를 가장 오른쪽에 추가한다.</p>

<p>만약 deque를 이용해 스택을 구현하고 싶다면 <code class="language-plaintext highlighter-rouge">deque.append</code>와 <code class="language-plaintext highlighter-rouge">deque.pop</code>을 사용하자. 정확히 선입후출 동작을 구현할 수 있다. 한편 큐를 구현하고 싶다면 <code class="language-plaintext highlighter-rouge">deque.append</code>와 <code class="language-plaintext highlighter-rouge">deque.popleft</code>를 함께 사용하자. 정확히 선입선출 구조를 만들어낼 수 있다. 한편 가장 첫번째 원소 앞에 새로운 원소를 추가하고 싶다면 <code class="language-plaintext highlighter-rouge">appendleft()</code> 역시 지원하고 있으니 참고해두면 좋을 것 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># deque stack &amp; queue 구현
</span>
<span class="s">""" stack """</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
<span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
<span class="mi">1</span>

<span class="s">""" queue """</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
<span class="mi">3</span>
</code></pre></div></div>

<h4 id="️-counter"><code class="language-plaintext highlighter-rouge">🗂️ Counter</code></h4>

<p><code class="language-plaintext highlighter-rouge">Iterable</code> 객체에 있는 <code class="language-plaintext highlighter-rouge">hashable item</code>의 개수를 세어 <code class="language-plaintext highlighter-rouge">Dict</code> 자료형으로 반환하는 역할을 한다. 아래 예시를 보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># collection.Counter example
</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">test</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span>
<span class="n">Counter</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">test</span> <span class="o">=</span> <span class="s">'aabcdacdbbbbaaaadddcccbcbcbcbcbcbbcbcbcbcbcdaadaabadbcdbcdacdbacdbacdbcadacbbcabcadb'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span>
<span class="n">Counter</span><span class="p">({</span><span class="s">'a'</span><span class="p">:</span> <span class="mi">19</span><span class="p">,</span> <span class="s">'b'</span><span class="p">:</span> <span class="mi">26</span><span class="p">,</span> <span class="s">'c'</span><span class="p">:</span> <span class="mi">24</span><span class="p">,</span> <span class="s">'d'</span><span class="p">:</span> <span class="mi">15</span><span class="p">})</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span><span class="p">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">[(</span><span class="s">'b'</span><span class="p">,</span> <span class="mi">26</span><span class="p">),</span> <span class="p">(</span><span class="s">'c'</span><span class="p">,</span> <span class="mi">24</span><span class="p">),</span> <span class="p">(</span><span class="s">'a'</span><span class="p">,</span> <span class="mi">19</span><span class="p">)]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span><span class="p">.</span><span class="n">values</span>
<span class="n">dict_values</span><span class="p">([</span><span class="mi">19</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
<span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">,</span> <span class="s">'d'</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">counter</span><span class="p">.</span><span class="n">elements</span><span class="p">()))</span>
<span class="s">'aaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbccccccccccccccccccccccccddddddddddddddd'</span>
</code></pre></div></div>

<p>이처럼 <code class="language-plaintext highlighter-rouge">Iterable</code> 객체의 원소에 접근해 다양한 일을 수행할 수 있다. <code class="language-plaintext highlighter-rouge">most_common</code>은 가장 많이 사용된 원소를 순서대로 사용자가 지정한 등수만큼 보여준다. <code class="language-plaintext highlighter-rouge">values</code> 는 개별 <code class="language-plaintext highlighter-rouge">key</code>의 값을 반환한다. <code class="language-plaintext highlighter-rouge">join</code>, <code class="language-plaintext highlighter-rouge">sorted</code> 와 함께 하면 원소를 반복하는 것도 가능하다.</p>

<h4 id="defaultdict"><code class="language-plaintext highlighter-rouge">👌 defaultdict</code></h4>

<p>사전의 <code class="language-plaintext highlighter-rouge">key</code>에 대한 <code class="language-plaintext highlighter-rouge">value</code>가 아직 없지만, 미리 <code class="language-plaintext highlighter-rouge">value</code>의 자료형을 지정해주고 싶을 때 사용하면 유용하다. 예를 들어 동물의 종류를 분류하는 사전을 만들고 싶다고 가정해보자. 0번 <code class="language-plaintext highlighter-rouge">key</code>가 조류라고 해보자. 그럼 조류에 해당되는 <code class="language-plaintext highlighter-rouge">value</code>는 참새, 비둘기 … 앵무새 등 정말 많을 것이다. 이것을 한번에 그룹핑해 조류라는 카테고리에 속한다고 표현해주기 위해 우리는 리스트를 <code class="language-plaintext highlighter-rouge">value</code>의 기본 자료형으로 지정해주는 것이다. 이 때 defaultdict을 이용하면 쉽게 구현이 가능하다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># collections.defaultdict example
</span><span class="k">from</span> <span class="n">collections</span> <span class="n">ipmort</span> <span class="n">defaultdict</span>

<span class="n">animal_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">defaultdict</code> 에 어떤 자료형을 매개변수로 전달하는가에 따라서 초기화 되는 기본 자료형이 바뀐다. 우리는 <code class="language-plaintext highlighter-rouge">list</code> 를 기본 자료형으로 지정했지만 <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">set</code> 같은 것도 가능하니 참고해두자.</p>

<h3 id="️-heapq"><strong><code class="language-plaintext highlighter-rouge">🗂️ heapq</code></strong></h3>

<p>다익스트라 최단 경로 알고리즘을 포함한 다양한 알고리즘 문제에서 우선순위 큐 기능을 구현할 때 사용하는 라이브러리로 기본적으로 최소 힙(오름차순, 파이썬 내장 정렬 알고리즘의 특성으로 모두 기본값이 오름차순) 구성으로 되어 있다. <code class="language-plaintext highlighter-rouge">heapq.heappush()</code> 로 힙에 원소를 삽입하는 기능을 구현하며, <code class="language-plaintext highlighter-rouge">heapq.heappop()</code> 을 통해서 힙으로부터 원소를 빼낸다. 아래는 힙 정렬을 구현한 코드이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Min Heapsort
</span><span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">def</span> <span class="nf">min_heapsort</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
	<span class="n">h</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="c1"># heap에 원소 삽입
</span>	<span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
		<span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
	<span class="c1"># heap으로부터 원소 빼내기
</span>	<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)):</span>
		<span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
	
	<span class="k">return</span> <span class="n">result</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">min_heapsort</span><span class="p">([])</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Max Heapsort
</span><span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">def</span> <span class="nf">max_heapsort</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
	<span class="n">h</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
		<span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">-</span><span class="n">value</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)):</span>
		<span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>

	<span class="k">return</span> <span class="n">result</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">max_heapsort</span><span class="p">([])</span>
</code></pre></div></div>

<p>구현된 힙의 모든 원소가 정렬되는 것은 아니며 현재 최대,최소 원소에 대한 정렬만 보장하기 때문에 주의가 필요하다. 개별 시점에서 최대,최소값만 필요하다면 힙정렬 사용을 고려해보자.</p>

<h3 id="️-sort--sorted"><strong><code class="language-plaintext highlighter-rouge">🗂️ sort &amp; sorted</code></strong></h3>

<p>python <code class="language-plaintext highlighter-rouge">iterable</code> 객체를 빠르게 정렬할 때 사용하는 기능이다. 두 함수 모두 기능은 같지만 적용 대상 범위가 다르며, 함수 실행 결과가 반환 방식도 다르기 때문에 사용할 때 주의해야 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># sort, sorted 차이
</span><span class="n">result</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
<span class="n">result</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># 정렬 결과가 result에 반영
</span><span class="nb">sorted</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># 정렬 결과를 result에 반영 x
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">sort</code>는 정렬 결과를 매개 변수로 입력한 <code class="language-plaintext highlighter-rouge">iterable</code> 객체에 바로 적용되는 <code class="language-plaintext highlighter-rouge">in-place</code> 연산인 반면, <code class="language-plaintext highlighter-rouge">sorted</code>는 그렇지 않다. 한편 <code class="language-plaintext highlighter-rouge">sort</code> 는 리스트 자료형(<code class="language-plaintext highlighter-rouge">mutable object</code>)만 매개 변수로 입력 가능하지만, <code class="language-plaintext highlighter-rouge">sorted</code>는 모든 <code class="language-plaintext highlighter-rouge">iterable</code> 객체를 사용 가능하다.</p>

<p><code class="language-plaintext highlighter-rouge">reverse</code>, <code class="language-plaintext highlighter-rouge">reversed</code> 역시 위와 같은 규칙을 따르는데, <code class="language-plaintext highlighter-rouge">sort</code>, <code class="language-plaintext highlighter-rouge">reverse</code> 처럼 자료형 객체 내부에 내장된 메서드인 경우는 <code class="language-plaintext highlighter-rouge">in-place</code> 연산을 지원하고 <code class="language-plaintext highlighter-rouge">sorted</code>, <code class="language-plaintext highlighter-rouge">reversed</code> 처럼 <code class="language-plaintext highlighter-rouge">global</code> 한 내장 메서드인 경우는 <code class="language-plaintext highlighter-rouge">in-place</code> 를 지원하지 않는다. 이러한 경우에는 반드시 다른 변수에 대입해줘야 하니 주의하자.</p>

<p>만약 다중 조건을 적용해 <code class="language-plaintext highlighter-rouge">Iterable</code> 객체를 정렬하고 싶다면, 아래와 같이 튜플 형태로 <code class="language-plaintext highlighter-rouge">lambda function</code> 에 적용하고 싶은 우선순위대로 기준을 입력해주면 된다. 구체적인 예시는 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" 
lecture_schedule = [시작시간, 끝시간] 
끝나는 시간을 기준으로 오름 차순 정렬하되, 끝나는 시간이 같으면, 시작 시간 오름 차순 정렬 적용 
"""</span>
<span class="n">lecture_schedule</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="n">lecture_schedule</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1"># key=lambda x:(우선순위1, 우선순위2, 우선순위3 ...)
</span><span class="n">lecture_schedule</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1"># - 붙인 정렬 조건은 현재 정렬 기준과 반대로
</span></code></pre></div></div>

<p>마지막으로 <code class="language-plaintext highlighter-rouge">-</code>를 붙인 조건은 현재 정렬 기준(오름차순, 내림차순)과 반대로 정렬을 하게 된다. 예시 코드의 3번째 라인처럼 <code class="language-plaintext highlighter-rouge">-</code> 을 붙이면 1번째는 내림 차순으로, 2번째는 오름 차순으로 정렬을 수행하게 된다. 정말 유용하니 꼭 기억해두자. 이걸 모르면, 해당 동작을 구현하기 위해 엄청난 코드 라인을 소비해야 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lambda x: x[1]과 동일한 결과
</span><span class="k">def</span> <span class="nf">second</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
	<span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="n">result</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
<span class="n">result</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">second</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># 정렬 결과가 result에 반영
</span><span class="nb">sorted</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">second</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># 정렬 결과를 result에 반영 x
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">lambda</code> 대신 직접 함수를 정의해 사용하는 것도 가능하니 꼭 기억해두자.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="collections" /><category term="Codeing Test" /><category term="Algorithm" /><summary type="html"><![CDATA[코딩 테스트 풀이에 자주 사용되는 파이썬 내장 라이브러리 사용법 정리]]></summary></entry><entry><title type="html">🗂️ Graph Theory 4: Union-Find (Disjoint Set)</title><link href="http://localhost:4000/algorithm/union-find" rel="alternate" type="text/html" title="🗂️ Graph Theory 4: Union-Find (Disjoint Set)" /><published>2023-11-11T00:00:00+09:00</published><updated>2023-11-12T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/union-find</id><content type="html" xml:base="http://localhost:4000/algorithm/union-find"><![CDATA[<h3 id="disjoint-set"><code class="language-plaintext highlighter-rouge">🙅 Disjoint Set</code></h3>

<p>서로 공통된 원소를 가지고 있지 않은 여러 집합들을 지칭하는 용어다. 개별 원소가 정확히 하나의 집합에 속하며, 어떤 집합도 서로 공통 원소를 가지고 있지 않아야 한다. 서로소 집합 자료구조를 사용하면 서로 다른 원소들이 같은 집합군에 속해 있는가 판별하는 것과 같은 작업을 쉽게 할 수 있다. 그렇다면 이제부터 자료구조로서 서로소 집합을 효과적으로 표현하고 조작할 수 있는 <code class="language-plaintext highlighter-rouge">Makeset</code>, <code class="language-plaintext highlighter-rouge">Union</code>, <code class="language-plaintext highlighter-rouge">Find</code> 연산에 대해서 알아보자.</p>

<h3 id="️makeset"><code class="language-plaintext highlighter-rouge">🗂️ Makeset</code></h3>

<p>트리 자료구조를 활용해 집합을 표현하는 방법 중 하나로, 주어진 요소만 중복없이 포함하는 집합을 생성하는 연산이다. 실제 코드상 구현으로는 배열, 리스트 자료구조를 활용한다. 배열의 인덱스를 개별 원소의 식별자로 간주하고 해당 위치의 값에는 부모 원소의 인덱스를 채워 넣는다. 만약 인덱스와 원소값이 동일하다면 해당 원소가 포함된 집합에서 현재 원소가 루트 노드임을 의미한다. 이렇게 특정 인덱스의 원소값을 타고 거슬러 올라가다면 만나게 되는 루트 노드의 값을 이용해 우리는 서로 다른 두 원소가 같은 집합에 속하는지 혹은 다른 집합에 속하는지 구별할 수 있게 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" Disjoint Makeset Example """</span>

<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span> <span class="c1"># 노드 개수
</span><span class="n">M</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span> <span class="c1"># 엣지 개수
</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># 1) Makeset Array Init
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
</code></pre></div></div>

<p>배열의 인덱스를 개별 노드의 식별자로 사용하기 위해, 전체 그래프 상의 노드 개수만큼 배열의 크기를 초기화 해주고 있다. 그리고 초기에는 아직 노드 사이의 연결 정보에 대해서 주어진게 전혀 없기 때문에 개별 노드 자신이 루트 노드가 되도록 초기화를 해주는게 일반적이다. 이렇게 초기화한 배열은 <code class="language-plaintext highlighter-rouge">Union</code>, <code class="language-plaintext highlighter-rouge">Find</code> 연산에 활용된다.</p>

<h3 id="find"><code class="language-plaintext highlighter-rouge">🔬 Find</code></h3>

<p>어떤 원소가 속한 집합의 루트 노드 값을 반환하는 연산이다. <code class="language-plaintext highlighter-rouge">Find</code> 연산은 앞서 초기화한 <code class="language-plaintext highlighter-rouge">Makeset Array</code> 를 해당 집합(트리)의 루트 노드를 만날 때까지 재귀적으로 순회한다. 실제로는 단순 루트 노드를 반환하는 용도로 사용하지 않고, 특정 두 원소가 같은 집합(트리)에 속하는지 아니면 서로 다른 집합에 속하는지 판정하는데 사용된다. 서로 다른 두 원소를 <code class="language-plaintext highlighter-rouge">Find</code> 연산자에 넣어주면 각각의 루트 노드를 구할 수 있는데, 이 때 서로 같은 루트 노드값을 반환한다면 같은 집합이라고 간주하고 다르다면 서로 서로소 관계에 있다고 판단할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" find method """</span>

<span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="s">""" method for finding root node """</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

<span class="c1"># 1) Kruskal Algorithm
</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">weight</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">final</span><span class="p">):</span>
        <span class="n">union</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">weight</span>
</code></pre></div></div>

<p>위 소스코드처럼 <code class="language-plaintext highlighter-rouge">Kruskal</code> Algorithm처럼 최소 스패닝 트리가 필요한 상황에 자주 사용된다. 또한 근본이 트리 자료구조에 대한 연산이라는 점을 활용해, 특정 그래프의 사이클 여부를 판정하는 알고리즘으로도 많이 사용되고 있다.</p>

<h3 id="union"><code class="language-plaintext highlighter-rouge">👩‍👩‍👧‍👦 Union</code></h3>

<p>두 개의 집합을 하나로 합치는 연산이다. 집합의 루트 노드를 다른 집합의 루트 노드 아래에 연결하는 방식으로 합친다. 합치는 방식에는 다양한 방법론이 존재하는데, 일반적으로 루트 노드의 번호가 더 작은 쪽에 더 큰 쪽의 집합(트리)를 붙여주는 <code class="language-plaintext highlighter-rouge">Union by Rank</code> 방식을 많이 사용한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" union method """</span>

<span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="s">""" method for union-find """</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>

<span class="c1"># 1) Kruskal Algorithm
</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">weight</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">final</span><span class="p">):</span>
        <span class="n">union</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">weight</span>

<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<p>역시 마찬가지로 최소 스패닝 트리가 필요한 상황에 자주 사용되고 있으며, 주로 Find를 통해 서로소 집합 관계에 놓인 집합들을 판정하고, 그들을 하나로 통합시키는데 자주 쓰인다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Union-Find" /><summary type="html"><![CDATA[Union-Find Algorithm with Disjoint Set]]></summary></entry><entry><title type="html">👩‍💻🎄 [baekjoon] 16920번: 확장게임</title><link href="http://localhost:4000/ps/baekjoon-16920" rel="alternate" type="text/html" title="👩‍💻🎄 [baekjoon] 16920번: 확장게임" /><published>2023-10-16T00:00:00+09:00</published><updated>2023-10-17T02:00:00+09:00</updated><id>http://localhost:4000/ps/baekjoon_16920</id><content type="html" xml:base="http://localhost:4000/ps/baekjoon-16920"><![CDATA[<h3 id="️solution"><strong><code class="language-plaintext highlighter-rouge">🖍️ solution</code></strong></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">():</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># direction of search
</span>    <span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">p_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span>  <span class="c1"># for matching index with player num
</span>    <span class="n">graph</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">M</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="n">player_q</span> <span class="o">=</span> <span class="p">[</span><span class="n">deque</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>  <span class="c1"># for matching index with player num
</span>
    <span class="c1"># 1) player dict 초기화
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">"."</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">"#"</span><span class="p">:</span>
                <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">now</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">now</span>
                <span class="n">player_q</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                <span class="n">scores</span><span class="p">[</span><span class="n">now</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># 2) 개별 player 탐색
</span>    <span class="n">turn</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">while</span> <span class="n">turn</span><span class="p">:</span>
        <span class="n">turn</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">player</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">P</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">player_q</span><span class="p">[</span><span class="n">player</span><span class="p">]:</span>  <span class="c1"># 이미 탐색이 종료된 플레이어 턴 스킵
</span>                <span class="k">continue</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">player_q</span><span class="p">[</span><span class="n">player</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p_list</span><span class="p">[</span><span class="n">player</span><span class="p">]):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>  <span class="c1"># 모든 플레이어들이 1개 이상 영역 확장 못하는데 최대 탐색 깊이가 매우 큰 경우, 헛돌게 된다
</span>                    <span class="k">break</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
                    <span class="n">vy</span><span class="p">,</span> <span class="n">vx</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                        <span class="n">ny</span> <span class="o">=</span> <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">vy</span>
                        <span class="n">nx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">vx</span>
                        <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="ow">and</span> <span class="n">graph</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">graph</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span> <span class="o">=</span> <span class="n">player</span>
                            <span class="n">scores</span><span class="p">[</span><span class="n">player</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">])</span>
                            <span class="n">turn</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">scores</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">solution</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="idea"><strong><code class="language-plaintext highlighter-rouge">💡 idea</code></strong></h3>

<ul>
  <li><strong>1) BFS</strong>
    <ul>
      <li><strong>1-1) <code class="language-plaintext highlighter-rouge">grid</code> 초기화</strong>
        <ul>
          <li><strong>루프 내부에 타입 캐스팅 함수 호출 방지를 위해 문자열 입력을 정수로 변환</strong></li>
          <li><strong>동시에 개별 플레이어의 초기 시작 위치를 개별 큐에 삽입(<code class="language-plaintext highlighter-rouge">player_q</code>)</strong></li>
          <li><strong>플레이어 점수 초기화 및 업데이트</strong></li>
        </ul>
      </li>
      <li><strong>1-2) <code class="language-plaintext highlighter-rouge">BFS</code> 순회</strong>
        <ul>
          <li><strong>라운드 구현: <code class="language-plaintext highlighter-rouge">while loop</code></strong></li>
          <li><strong>개별 플레이어 턴, 탐색 깊이 제한, 1회 탐색 및 동시 탐색 구현: <code class="language-plaintext highlighter-rouge">for-loop</code></strong>
            <ul>
              <li><strong>개별 플레이어 턴: <code class="language-plaintext highlighter-rouge">for player in range(1, P+1):</code></strong></li>
              <li><strong>탐색 깊이 제한: <code class="language-plaintext highlighter-rouge">for _ in range(p_list[player]):</code></strong>
                <ul>
                  <li><strong>모든 플레이어가 1개 이상 영역 확장 불가한 상황 and 최대 탐색 깊이 매우 큰 경우</strong>
                    <ul>
                      <li><strong>탐색 깊이 제한 루프를 헛돌게 되기 때문에 시간 초과 발생</strong></li>
                      <li><strong>큐가 비었다면 루프 탈출하도록 코드 추가 필요: <code class="language-plaintext highlighter-rouge">break if not q</code></strong></li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li><strong>1회 탐색 및 동시 탐색 구현: <code class="language-plaintext highlighter-rouge">for _ in range(len(q)):</code></strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="반례"><strong><code class="language-plaintext highlighter-rouge">🤔 반례</code></strong></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" 반례 케이스 """</span>

<span class="mi">4</span> <span class="mi">10</span> <span class="mi">4</span>
<span class="mi">1000000000</span> <span class="mi">1</span> <span class="mi">100</span> <span class="mi">99999</span>
<span class="mi">1</span><span class="c1">#........
#.........
</span><span class="mi">2</span><span class="c1">#.......#
</span><span class="mi">3</span><span class="c1">#......#4
</span></code></pre></div></div>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Problem Solving" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="Graph" /><category term="BFS" /><summary type="html"><![CDATA[백준 16920번: 확장게임]]></summary></entry><entry><title type="html">👩‍💻🎄 [baekjoon] 15558번: 점프 게임</title><link href="http://localhost:4000/ps/baekjoon-15558" rel="alternate" type="text/html" title="👩‍💻🎄 [baekjoon] 15558번: 점프 게임" /><published>2023-10-16T00:00:00+09:00</published><updated>2023-10-17T02:00:00+09:00</updated><id>http://localhost:4000/ps/baekjoon_15558</id><content type="html" xml:base="http://localhost:4000/ps/baekjoon-15558"><![CDATA[<h3 id="️solution"><strong><code class="language-plaintext highlighter-rouge">🖍️ solution</code></strong></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">time</span><span class="p">,</span> <span class="n">flag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">False</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]])</span>
    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
            <span class="n">vy</span><span class="p">,</span> <span class="n">vx</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">vx</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">N</span> <span class="ow">or</span> <span class="n">vx</span><span class="o">+</span><span class="n">K</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">:</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">graph</span><span class="p">[</span><span class="n">vy</span><span class="p">][</span><span class="n">vx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">vy</span><span class="p">][</span><span class="n">vx</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># 앞으로 한 칸 이동
</span>                <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">vy</span><span class="p">,</span> <span class="n">vx</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">vy</span><span class="p">][</span><span class="n">vx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="k">if</span> <span class="n">vx</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">time</span><span class="o">+</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">graph</span><span class="p">[</span><span class="n">vy</span><span class="p">][</span><span class="n">vx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">vy</span><span class="p">][</span><span class="n">vx</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># 뒤로 한 칸 이동, 갈 수 없는 구역을 미리 예상해서 풀어야 함
</span>                <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">vy</span><span class="p">,</span> <span class="n">vx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">vy</span><span class="p">][</span><span class="n">vx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="k">if</span> <span class="n">graph</span><span class="p">[(</span><span class="n">vy</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">][</span><span class="n">vx</span><span class="o">+</span><span class="n">K</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[(</span><span class="n">vy</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">][</span><span class="n">vx</span><span class="o">+</span><span class="n">K</span><span class="p">]:</span>  <span class="c1"># 앞으로 한 칸 이동
</span>                <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">([(</span><span class="n">vy</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="n">vx</span><span class="o">+</span><span class="n">K</span><span class="p">])</span>
                <span class="n">visited</span><span class="p">[(</span><span class="n">vy</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">][</span><span class="n">vx</span><span class="o">+</span><span class="n">K</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">time</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">flag</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
    <span class="k">print</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">bfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="k">print</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><strong><code class="language-plaintext highlighter-rouge">💡 idea</code></strong></h3>

<ul>
  <li><strong>매초마다 블럭 사라지는 기능 필요</strong>
    <ul>
      <li><strong>매초 단위로 큐입력을 끊기</strong></li>
      <li><strong>while &amp; for-loop는 초단위로 큐입력 끊어내는 구현하기 매우 어려움</strong></li>
      <li><strong>일반적인 bfs 구현체 대신 if-else 구문으로 큐 하나에 대한 모든 경우의 수가 한 번에 처리 되도록 구현</strong></li>
      <li><strong>뒤로 가능 경우에 대해서만 예외처리</strong>
      - <strong>시간 초마다 블럭을 삭제하는 방법 X, 뒤로 가려는 블럭이 다음번에 삭제 예정인지 판단</strong>
          - <strong>사라질 예정이면 큐에 삽입하지 않고 <code class="language-plaintext highlighter-rouge">pass</code></strong></li>
    </ul>
  </li>
</ul>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Problem Solving" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="Graph" /><category term="BFS" /><summary type="html"><![CDATA[백준 15558번: 점프 게임 풀이]]></summary></entry><entry><title type="html">👨‍💻🐍 [Python] Function Argument</title><link href="http://localhost:4000/python/func_argu" rel="alternate" type="text/html" title="👨‍💻🐍 [Python] Function Argument" /><published>2023-10-14T00:00:00+09:00</published><updated>2023-10-15T02:00:00+09:00</updated><id>http://localhost:4000/python/python_function_arg</id><content type="html" xml:base="http://localhost:4000/python/func_argu"><![CDATA[<h3 id="function-argument"><strong><code class="language-plaintext highlighter-rouge">👨‍👩‍👧‍👦 Function Argument</code></strong></h3>

<p>파이썬의 모든 메서드는 기본적으로 인자를 <code class="language-plaintext highlighter-rouge">call by value</code> 형태로 전달해야 한다. 하지만 <code class="language-plaintext highlighter-rouge">call by value</code> 라고 해서 함수의 동작과 원본 변수가 완전히 독립적인 것은 아니다. 이것은 인자로 어떤 데이터 타입을 전달하는가에 따라 달라진다. 만약 인자로 <code class="language-plaintext highlighter-rouge">mutable(dynamic)</code> 객체인 리스트 변수를 전달했다면, 함수의 동작에 따른 결과가 그대로 변수에 반영된다. <code class="language-plaintext highlighter-rouge">mutable</code> 객체는 함수 스코프 내부 지역 변수에 카피 되지 않기 때문에 이런 현상이 발생한다. 따라서 인자로 리스트와 같은 <code class="language-plaintext highlighter-rouge">mutable</code> 객체를 전달하는 것은 수많은 부작용을 불러오기 때문에 지양하는게 좋다. 아래 예시 코드를 보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" function argument experiment with mutable vs immutable """</span>
<span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="n">args</span> <span class="o">+=</span> <span class="s">'in runtime'</span>
    <span class="k">print</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

<span class="c1"># immutable object string
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">immutable</span> <span class="o">=</span> <span class="s">'immutable'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">function</span><span class="p">(</span><span class="n">immutable</span><span class="p">)</span>
<span class="n">immutable</span> <span class="ow">in</span> <span class="n">runtime</span> 

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">mmutable</span><span class="p">)</span>
<span class="n">immutable</span>

<span class="c1"># mutable object list
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">mutable</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">'mutable'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">function</span><span class="p">(</span><span class="n">mutable</span><span class="p">)</span>
<span class="p">[</span><span class="s">'m'</span><span class="p">,</span> <span class="s">'u'</span><span class="p">,</span> <span class="s">'t'</span><span class="p">,</span> <span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'l'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">,</span> <span class="s">' '</span><span class="p">,</span> <span class="s">'i'</span><span class="p">,</span> <span class="s">'n'</span><span class="p">,</span> <span class="s">' '</span><span class="p">,</span> <span class="s">'r'</span><span class="p">,</span> <span class="s">'u'</span><span class="p">,</span> <span class="s">'n'</span><span class="p">,</span> <span class="s">'t'</span><span class="p">,</span> <span class="s">'i'</span><span class="p">,</span> <span class="s">'m'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">mutable</span><span class="p">)</span>
<span class="p">[</span><span class="s">'m'</span><span class="p">,</span> <span class="s">'u'</span><span class="p">,</span> <span class="s">'t'</span><span class="p">,</span> <span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'l'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">,</span> <span class="s">' '</span><span class="p">,</span> <span class="s">'i'</span><span class="p">,</span> <span class="s">'n'</span><span class="p">,</span> <span class="s">' '</span><span class="p">,</span> <span class="s">'r'</span><span class="p">,</span> <span class="s">'u'</span><span class="p">,</span> <span class="s">'n'</span><span class="p">,</span> <span class="s">'t'</span><span class="p">,</span> <span class="s">'i'</span><span class="p">,</span> <span class="s">'m'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">]</span>
</code></pre></div></div>

<p>동일한 함수에 동일하게 인자로 사용했지만, <code class="language-plaintext highlighter-rouge">immutable</code> 객체인 문자열은 함수의 실행 결과와 전혀 무관한 모습이다. 하지만 <code class="language-plaintext highlighter-rouge">mutable</code> 객체인 리스트는 함수의 실행 결과가 스코프 바깥의 원본 변수에 그대로 반영되었음을 확인할 수 있다. 이것은 리스트가 기본적으로 컨테이너 내부에 실제 값이 아닌 주소 값을 갖고 있고, <code class="language-plaintext highlighter-rouge">Resize()</code> 연산을 통해 수정이 가능하기 때문이다. 한편, <code class="language-plaintext highlighter-rouge">immutable</code> 객체의 경우 원본 수정이 불가하기 때문에 관련 연산 혹은 명령을 만나면 <code class="language-plaintext highlighter-rouge">deepcopy</code> 가 발생한다.</p>

<h3 id="packingunpacking"><strong><code class="language-plaintext highlighter-rouge">📦 Packing/Unpacking</code></strong></h3>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Python" /><category term="Python" /><category term="Function" /><category term="Argument" /><category term="mutable" /><category term="CS" /><summary type="html"><![CDATA[함수 인자 전달 메커니즘에 대한 이해]]></summary></entry></feed>