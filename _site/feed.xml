<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-11-11T22:37:51+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">AI/Business Study Log</title><subtitle>NLP, Marketing</subtitle><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><entry><title type="html">🗂️ Graph Theory 4: Union-Find (Disjoint Set)</title><link href="http://localhost:4000/algorithm/union-find" rel="alternate" type="text/html" title="🗂️ Graph Theory 4: Union-Find (Disjoint Set)" /><published>2023-11-11T00:00:00+09:00</published><updated>2023-11-12T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/union-find</id><content type="html" xml:base="http://localhost:4000/algorithm/union-find"><![CDATA[<h3 id="disjoint-set"><code class="language-plaintext highlighter-rouge">🙅 Disjoint Set</code></h3>

<p>서로 공통된 원소를 가지고 있지 않은 여러 집합들을 지칭하는 용어다. 개별 원소가 정확히 하나의 집합에 속하며, 어떤 집합도 서로 공통 원소를 가지고 있지 않아야 한다. 서로소 집합 자료구조를 사용하면 서로 다른 원소들이 같은 집합군에 속해 있는가 판별하는 것과 같은 작업을 쉽게 할 수 있다. 그렇다면 이제부터 자료구조로서 서로소 집합을 효과적으로 표현하고 조작할 수 있는 <code class="language-plaintext highlighter-rouge">Makeset</code>, <code class="language-plaintext highlighter-rouge">Union</code>, <code class="language-plaintext highlighter-rouge">Find</code> 연산에 대해서 알아보자.</p>

<h3 id="️makeset"><code class="language-plaintext highlighter-rouge">🗂️ Makeset</code></h3>

<p>트리 자료구조를 활용해 집합을 표현하는 방법 중 하나로, 주어진 요소만 중복없이 포함하는 집합을 생성하는 연산이다. 실제 코드상 구현으로는 배열, 리스트 자료구조를 활용한다. 배열의 인덱스를 개별 원소의 식별자로 간주하고 해당 위치의 값에는 부모 원소의 인덱스를 채워 넣는다. 만약 인덱스와 원소값이 동일하다면 해당 원소가 포함된 집합에서 현재 원소가 루트 노드임을 의미한다. 이렇게 특정 인덱스의 원소값을 타고 거슬러 올라가다면 만나게 되는 루트 노드의 값을 이용해 우리는 서로 다른 두 원소가 같은 집합에 속하는지 혹은 다른 집합에 속하는지 구별할 수 있게 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" Disjoint Makeset Example """</span>

<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span> <span class="c1"># 노드 개수
</span><span class="n">M</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span> <span class="c1"># 엣지 개수
</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># 1) Makeset Array Init
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
</code></pre></div></div>

<p>배열의 인덱스를 개별 노드의 식별자로 사용하기 위해, 전체 그래프 상의 노드 개수만큼 배열의 크기를 초기화 해주고 있다. 그리고 초기에는 아직 노드 사이의 연결 정보에 대해서 주어진게 전혀 없기 때문에 개별 노드 자신이 루트 노드가 되도록 초기화를 해주는게 일반적이다. 이렇게 초기화한 배열은 <code class="language-plaintext highlighter-rouge">Union</code>, <code class="language-plaintext highlighter-rouge">Find</code> 연산에 활용된다.</p>

<h3 id="find"><code class="language-plaintext highlighter-rouge">🔬 Find</code></h3>

<p>어떤 원소가 속한 집합의 루트 노드 값을 반환하는 연산이다. <code class="language-plaintext highlighter-rouge">Find</code> 연산은 앞서 초기화한 <code class="language-plaintext highlighter-rouge">Makeset Array</code> 를 해당 집합(트리)의 루트 노드를 만날 때까지 재귀적으로 순회한다. 실제로는 단순 루트 노드를 반환하는 용도로 사용하지 않고, 특정 두 원소가 같은 집합(트리)에 속하는지 아니면 서로 다른 집합에 속하는지 판정하는데 사용된다. 서로 다른 두 원소를 <code class="language-plaintext highlighter-rouge">Find</code> 연산자에 넣어주면 각각의 루트 노드를 구할 수 있는데, 이 때 서로 같은 루트 노드값을 반환한다면 같은 집합이라고 간주하고 다르다면 서로 서로소 관계에 있다고 판단할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" find method """</span>

<span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="s">""" method for finding root node """</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

<span class="c1"># 1) Kruskal Algorithm
</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">weight</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">final</span><span class="p">):</span>
        <span class="n">union</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">weight</span>
</code></pre></div></div>

<p>위 소스코드처럼 <code class="language-plaintext highlighter-rouge">Kruskal</code> Algorithm처럼 최소 스패닝 트리가 필요한 상황에 자주 사용된다. 또한 근본이 트리 자료구조에 대한 연산이라는 점을 활용해, 특정 그래프의 사이클 여부를 판정하는 알고리즘으로도 많이 사용되고 있다.</p>

<h3 id="union"><code class="language-plaintext highlighter-rouge">👩‍👩‍👧‍👦 Union</code></h3>

<p>두 개의 집합을 하나로 합치는 연산이다. 집합의 루트 노드를 다른 집합의 루트 노드 아래에 연결하는 방식으로 합친다. 합치는 방식에는 다양한 방법론이 존재하는데, 일반적으로 루트 노드의 번호가 더 작은 쪽에 더 큰 쪽의 집합(트리)를 붙여주는 <code class="language-plaintext highlighter-rouge">Union by Rank</code> 방식을 많이 사용한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" union method """</span>

<span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="s">""" method for union-find """</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>

<span class="c1"># 1) Kruskal Algorithm
</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">weight</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">final</span><span class="p">):</span>
        <span class="n">union</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">weight</span>

<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<p>역시 마찬가지로 최소 스패닝 트리가 필요한 상황에 자주 사용되고 있으며, 주로 Find를 통해 서로소 집합 관계에 놓인 집합들을 판정하고, 그들을 하나로 통합시키는데 자주 쓰인다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Union-Find" /><summary type="html"><![CDATA[Union-Find Algorithm with Disjoint Set]]></summary></entry><entry><title type="html">🗂️ Graph Theory 5: MST with Kruskal &amp;amp; Prim</title><link href="http://localhost:4000/algorithm/mst" rel="alternate" type="text/html" title="🗂️ Graph Theory 5: MST with Kruskal &amp;amp; Prim" /><published>2023-11-11T00:00:00+09:00</published><updated>2023-11-12T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/mst</id><content type="html" xml:base="http://localhost:4000/algorithm/mst"><![CDATA[<h3 id="spanning-tree"><code class="language-plaintext highlighter-rouge">🎡 Spanning Tree</code></h3>

<p>그래프 내부에 포함된 모든 노드를 포함하는 트리를 의미한다. 모든 정점을 포함하긴 하지만 근본은 트리라서 사이클이 발생하면 안되며, 최소의 간선을 사용해 모든 노드를 연결해야 한다. 따라서 <code class="language-plaintext highlighter-rouge">Spanning Tree</code> 의 간선 개수는 <code class="language-plaintext highlighter-rouge">노드 개수-1</code>에 해당한다.</p>

<h3 id="minimum-spanning-tree"><code class="language-plaintext highlighter-rouge">💵 Minimum Spanning Tree</code></h3>

<p>그래프 상에서 발생할 수 있는 여러 <code class="language-plaintext highlighter-rouge">Spanning Tree</code> 중에서 간선들의 가중치 합이 최소인 트리를 의미한다. <code class="language-plaintext highlighter-rouge">MST</code>를 구현하는 알고리즘은 대표적으로 <code class="language-plaintext highlighter-rouge">Kruskal</code>, <code class="language-plaintext highlighter-rouge">Prim</code>알고리즘이 있다. 전자의 시간 복잡도는 <code class="language-plaintext highlighter-rouge">O(ElogE)</code>, 후자는 기본적으로 <code class="language-plaintext highlighter-rouge">O(N^2)</code>이라서 노드에 비해 간선 개수가 적은 희소 그래프의 경우는 Kruskal을, 노드에 비해 간선이 많은 밀집 그래프의 경우는 Prim을 사용하는게 시간 복잡도 측면에서 유리하다. 한편, Prim은 구현시에 선택하는 자료구조에 따라서 시간 복잡도를 최적화할 수 있다. 자세한 내용은 개별 알고리즘에 대한 설명에서 다루도록 하겠다.</p>

<h3 id="kruskal-algorithm-간선-선택"><code class="language-plaintext highlighter-rouge">🍃 Kruskal Algorithm (간선 선택)</code></h3>

<p>그리디하게 그래프의 모든 정점을 최소 비용으로 연결하는 방법이다. 구체적으로는 개별 시점에서 사이클을 이루지 않으면서 최소 비용인 간선을 경로로 선택한다. 그리디를 기반으로 하기 때문에 이전 결과, 미래 결과를 고려하지 않고 현재 최소 비용이 되는 간선만을 선택한다. 알고리즘의 구체적인 동작 과정은 다음과 같다.</p>

<ul>
  <li>1) 그래프의 간선들을 오름차순으로 정렬, 가중치 기준</li>
  <li>2) 사이클을 발생시키는지 여부를 체크하면서 순서대로 선택
    <ul>
      <li>가장 낮은 가중치부터 접근해 체크</li>
      <li>사이클 발생 X라면 선택</li>
    </ul>
  </li>
  <li>3) 선택한 간선을 <code class="language-plaintext highlighter-rouge">MST</code>집합에 추가</li>
</ul>

<p>사이클을 발생시키는지 여부를 체크하는 부분이 구현할 때 까다로울 수 있는데, Union-Find 알고리즘을 도입하면 수월하게 만들어 낼 수 있다. Union-Find를 도입한 Kruskal Algorithm을 Python 코드로 작성하면 다음과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" kruskal algorithm example: baekjoon 1043 """</span>

<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="s">""" method for finding root node """</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="s">""" method for union-find """</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>

<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>  <span class="c1"># number of nodes
</span><span class="n">M</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>  <span class="c1"># number of edges
</span><span class="n">graph</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># 0-0) 간선 연결 정보 초기화, 정렬
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">src</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">graph</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">cost</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
<span class="n">graph</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>

<span class="c1"># 0-1) 연결 정보 초기화
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

<span class="c1"># 1) Kruskal Algorithm
</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">weight</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">final</span><span class="p">):</span>
        <span class="n">union</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">weight</span>

<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<p>find 메서드는 입력한 노드의 루트 노드를 찾아 반환한다. 이것을 활용해 서로 다른 노드가 같은 집합(트리)에 속하는지 손쉽게 판정할 수 있으며 이것은 바꿔 생각해보면 선택된 두 노드가 사이클을 발생시키는지 여부를 알아 낼 수 있다는 것이다. 만약 두 노드가 같은 루트 노드값을 갖는다면, 결국 같은 집합(트리)에 속한다는 것을 의미하며, 이것은 사이클을 유발하게 되는 것이다. 따라서 사이클을 유발하는 정점은 선택하지 않으며, 트리의 성질을 유지할 수 있는 노드를 선택해 <code class="language-plaintext highlighter-rouge">union</code> 연산에 대입한다.</p>

<h3 id="prim-algorithm-정점-선택"><code class="language-plaintext highlighter-rouge">🔴 Prim Algorithm (정점 선택)</code></h3>

<p>특정 정점에서 시작해서 가중치가 작은 간선들 순서대로 트리를 확장해나가는 방법이다. 시작점을 지정한다는 점에서 다익스트라와 유사하며, 간선의 숫자가 많은 밀집 그래프 상황에서 <code class="language-plaintext highlighter-rouge">Kruskal</code>보다 빠르다. 구체적인 동작 방식은 다음과 같다.</p>

<ul>
  <li><strong>1) 선택 노드를 MST 집합에 추가</strong></li>
  <li><strong>2) MST 집합에 포함된 노드들에 인접한 정점들 탐색</strong>
    <ul>
      <li><strong>사이클 발생 여부 확인</strong>
        <ul>
          <li><strong>사이클 발생 X: 최소 가중치의 간선을 선택</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>3) 전체 간선의 개수가 N-1개가 될 때까지, 1 &amp; 2 과정  <code class="language-plaintext highlighter-rouge">Iteration</code></strong></li>
</ul>

<p>기본적으로는 <code class="language-plaintext highlighter-rouge">O(N^2)</code>의 시간복잡도를 기록한다. 하지만 자료구조 최적화에 따라서 <code class="language-plaintext highlighter-rouge">Kruskal</code>과 비슷한 시간복잡도인 <code class="language-plaintext highlighter-rouge">O(ElogE)</code>정도로까지 만들어 낼 수 있다. 최소 힙정렬과 우선순위 큐를 이용하면 된다. 힙정렬을 이용해 그래프 연결 정보를 가중치를 기준으로 오름차순 정렬을 한 뒤에, 사이클을 발생시키지 않는 인접 노드를 선택하도록 만든다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" prim algorithm example: baekjoon 1197 """</span>

<span class="kn">import</span> <span class="nn">sys</span><span class="p">,</span> <span class="n">heapq</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="s">"""
[풀이]
1) Prim with 우선순위 큐 (힙)
    - 시작점 선택, MST 집합에 추가
    - MST 집합의 노드들에 인접한 모든 정점 탐색
        - 사이클 발생 여부 확인: 방문 여부로 판정
        - 사이클 발생 X: 최소 가중치 간선 선택 (heapify를 통해 개별 노드마다 간선들을 가중치 기준 오름차순 정렬)
"""</span>

<span class="k">def</span> <span class="nf">prim</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">],</span> <span class="n">visit</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">visit</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>  <span class="c1"># 선택된 노드에 대한 모든 인접 간선 추출
</span>    <span class="n">heapq</span><span class="p">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>  <span class="c1"># 이미 생성되어 있는 자료구조에 대해서는 heapq.heapify를 사용하면 힙 성질을 만족하도록 할 수 있다
</span>    <span class="n">mst</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">tmp</span><span class="p">:</span>
        <span class="n">weight</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visit</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>  <span class="c1"># 미방문 노드로의 간선만 선택하는 방식으로, 사이클 발생 여부 판정하는 알고리즘을 구현
</span>            <span class="n">visit</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">mst</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">weight</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">visit</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]]:</span>
                    <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">total</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">():</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">prim</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 시작 노드를 어떤 것으로 설정해도 상관 없음
</span>    <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">sys</span><span class="p">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">V</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">graph</span><span class="p">,</span> <span class="n">visited</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">V</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
        <span class="n">src</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">src</span><span class="p">].</span><span class="n">append</span><span class="p">([</span><span class="n">cost</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">end</span><span class="p">])</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">end</span><span class="p">].</span><span class="n">append</span><span class="p">([</span><span class="n">cost</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">src</span><span class="p">])</span>
    <span class="n">solution</span><span class="p">()</span>
</code></pre></div></div>

<p>시작 정점은 아무거나 선택해도 상관없다. 그리고 가장 주목할 부분은 노드 선택시 사이클 여부를 판정하는 방법을 어떻게 구현했는가이다. 개별 노드에 대한 방문여부를 기록하는 배열을 따로 생성한 뒤, 방문(해당 노드와 연결되는 간선 선택)할 때 마다 방문 기록을 저장한다. 그리고 만약 어떤 노드를 선택했을 때, 이미 방문한 노드라면 해당 노드와 연결하는 간선의 가중치가 현재 가장 최소에 해당하더라도 사이클을 발생시키기 때문에 선택하지 않도록 사이클 여부를 판정하게 만들었다.<br />
<code class="language-plaintext highlighter-rouge">Kruskal</code>처럼 전체 모든 간선을 알고 있는 상태가 아님에도 최소 스패닝 트리의 조건을 만족하는 결과를 만들어 낼 수 있는 이유는 미리 개별 노드별 간선들을 가중치 기준으로 오름차순 정렬 해뒀기 때문이다. 이것 때문에 지역 최적들의 합이 전역 최적이 되어야 하는 그리디의 제약 조건을 만족시킬 수 있게 된다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="MST" /><category term="Kruskal" /><category term="Prim" /><summary type="html"><![CDATA[MST with Kruskal & Prim Algorithm]]></summary></entry><entry><title type="html">🗂️ Graph Theory 3: Floyd-Warshall</title><link href="http://localhost:4000/algorithm/floyd-warshell" rel="alternate" type="text/html" title="🗂️ Graph Theory 3: Floyd-Warshall" /><published>2023-11-11T00:00:00+09:00</published><updated>2023-11-12T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/floyd-warshell</id><content type="html" xml:base="http://localhost:4000/algorithm/floyd-warshell"><![CDATA[<h3 id="-floyd-warshall"><code class="language-plaintext highlighter-rouge">📚 Floyd-Warshall</code></h3>

<p><code class="language-plaintext highlighter-rouge">Floyd-Warshall</code>은 모든 지점에서 다른 모든 지점까지의 최단 경로를 구하는 알고리즘이다. 지정된 출발점에서 나머지 다른 지점가지의 최단 경로를 구하는 다익스트라 알고리즘과는 차이가 있다. 따라서 솔루션을 도출하는 방식에도 살짝 차이가 생기는데, <code class="language-plaintext highlighter-rouge">Floyd-Warshall</code> 은 그리디하게 매번 최단 경로에 있는 노드를 구할 필요가 없다. 이유는 모든 지점에서 다른 모든 지점까지의 경로를 구해야 하기 때문에 그리디 대신 <code class="language-plaintext highlighter-rouge">DP Tabulation</code>으로 문제를 풀기 때문이다.</p>

<p><code class="language-plaintext highlighter-rouge">Floyd-Warshall</code> 은 주어진 $N$ 개의 노드에 대해서 매번 $N^2$ 번의 연산을 통해 최단 거리를 갱신한다. 따라서 최종적으로 $O(N^3)$ 의 시간 복잡도를 갖게 된다. 연산은 직선 경로와 경유 경로를 비교하는 형태로 이뤄진다. 둘 중에서 더 작은 값이 <code class="language-plaintext highlighter-rouge">DP Table</code>에 저장된다. 여기서 경유 경로란 전체 $N$ 개의 노드에 대한 <code class="language-plaintext highlighter-rouge">iteration</code> 중에서 $i$ 번째 노드를 경유하는 경로를 말한다. 만약 직선 경로가 [$d, k$]라면 경유 경로는 [$d, i$] + [$i, k$] 가 된다. 우리는 테이블에 직선 경로와 경유 경로중에서 최단 거리만 저장하고 있기 때문에, 이렇게 하나의 노드에 대해서만 경유하는 경우만 고려해도 괜찮다. 만약 3개의 중간 노드를 경유해야만 최단 거리가 되는 경로가 있다고 가정해보자. 최적의 솔루션인 전체 경로의 부분 경로 역시 중간에 최단 경로로 선택되어 이미 테이블 어딘가에 값으로 자리 잡고 있게 된다. 따라서 결국엔 부분 집합의 합으로 전체 최적 솔루션인 경로를 도출해낼 수 있게 된다. 이러한 경우의 수를 고려하기 위해 <code class="language-plaintext highlighter-rouge">DP  Table</code>을 사용하게 된 것이라 생각한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" Floyd-Warshall Implementation """</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="s">"""
[Floyd-Warshall]
1) DP Table init
2) triple-loop
    - dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])
3) print result
"""</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>  <span class="c1"># 노드 개수
</span><span class="n">M</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>  <span class="c1"># 간선 개수
</span><span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

<span class="c1"># 1) DP Table init
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">src</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">dp</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>

<span class="c1"># 2) triple-loop
</span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>

<span class="c1"># 3) print result
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'INF'</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">' '</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="s">' '</span><span class="p">)</span>
    <span class="k">print</span><span class="p">()</span>
</code></pre></div></div>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Floyd-Warshall" /><summary type="html"><![CDATA[Floyd-Warshall Algorithm with DP Tabulation]]></summary></entry><entry><title type="html">🗂️ Graph Theory 2: Dijkstra</title><link href="http://localhost:4000/algorithm/dijkstra" rel="alternate" type="text/html" title="🗂️ Graph Theory 2: Dijkstra" /><published>2023-11-11T00:00:00+09:00</published><updated>2023-11-12T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/dijkstra</id><content type="html" xml:base="http://localhost:4000/algorithm/dijkstra"><![CDATA[<h3 id="-dijkstra"><code class="language-plaintext highlighter-rouge">📚 Dijkstra</code></h3>

<p>다익스트라 최단 경로 문제는 그래프 자료 구조에서 여러 개의 노드가 주어졌을 때, 특정한 노드(시작점)에서 특정한 노드(도착점)까지의 최단 경로를 구해주는 알고리즘을 설계해야 한다. 특히 다익스트라는 <code class="language-plaintext highlighter-rouge">음의 간선</code>이 없을 때 정상적으로 동작하며, 유향 &amp; 무향을 가리지 않고 적용할 수 있다. 다익스트라 알고리즘의 동작을 기술하면 아래와 같다.</p>

<ul>
  <li><strong>1) 출발 노드 설정</strong></li>
  <li><strong>2) 최단 거리 테이블 초기화(출발 노드 값은 0)</strong></li>
  <li><strong>3) 방문하지 않은 노드 중에서 현재 가장 가까운 노드를 선택(최단 거리 노드)</strong></li>
  <li><strong>4) 선택된 노드로부터 파생되는 다른 경로값 업데이트</strong></li>
  <li><strong>5) 모든 노드에 대한 계산 끝날 때까지 3~4번 반복</strong></li>
</ul>

<p>다익스트라 알고리즘을 설계하는 방법은 크게 두가지가 있다. 먼저 3번을 수행하기 위해 1) 최단 거리 테이블을 매번 선형 탐색하는 알고리즘,  2) 선형 탐색 대신에 힙 정렬을 이용해 가장 가까운 노드를 선택하는 방식이 있다. 1번의 경우 <code class="language-plaintext highlighter-rouge">O(V^2)</code> 가 되어 입력 노드가 1000개만 넘어가도 시간 초과를 당하기 때문에, 2번의 경우로 소스 코드를 작성하는 게 바람직하다. 코드 예시는 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" Dijkstra implementation """</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">h</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="n">distance</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">while</span> <span class="n">h</span><span class="p">:</span>
        <span class="n">min_cost</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="c1"># 방문한 노드 처리: cost를 기준으로 다음 노드를 선정, 따라서 cost가 distance[node]보다 크다면 이미 방문 했던 노드로 볼 수 있음
</span>        <span class="k">if</span> <span class="n">min_cost</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="n">min_cost</span> <span class="o">+</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cost</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
                <span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">cost</span>
                <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<span class="n">V</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">src</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>

<span class="c1"># 1) init graph
</span><span class="n">graph</span><span class="p">,</span> <span class="n">costs</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">V</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">costs</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">weight</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

<span class="n">dijkstra</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">costs</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">V</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span> <span class="k">else</span> <span class="s">'INF'</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Dijkstra" /><summary type="html"><![CDATA[Dijkstra Algorithm with Priority Queue]]></summary></entry><entry><title type="html">✏️  Summary of Useful Library for Coding Test</title><link href="http://localhost:4000/algorithm/useful_library" rel="alternate" type="text/html" title="✏️  Summary of Useful Library for Coding Test" /><published>2023-11-11T00:00:00+09:00</published><updated>2023-11-12T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/summary-of-useful-library</id><content type="html" xml:base="http://localhost:4000/algorithm/useful_library"><![CDATA[<h3 id="collections"><code class="language-plaintext highlighter-rouge">📚 collections</code></h3>

<h4 id="deque"><code class="language-plaintext highlighter-rouge">🪢 deque</code></h4>
<p><code class="language-plaintext highlighter-rouge">python</code>에서 <code class="language-plaintext highlighter-rouge">stack</code>이나 <code class="language-plaintext highlighter-rouge">queue</code> 자료형을 구현할 때 일반적으로 사용하는 내장 라이브러리 <code class="language-plaintext highlighter-rouge">collections</code>에 구현된 클래스다. 메서드가 아닌 객체라서 사용하려면 초기화가 필요하다. 사용 예시를 보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># collections.deque usage example
</span><span class="n">deque</span><span class="p">([</span><span class="n">iterable</span><span class="p">[,</span> <span class="n">maxlen</span><span class="p">]])</span> <span class="o">--&gt;</span> <span class="n">deque</span> <span class="nb">object</span>

<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">Counter</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span> <span class="c1"># 1)
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span>
<span class="n">deque</span><span class="p">([])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(())</span>  <span class="c1"># 2)
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span>
<span class="n">deque</span><span class="p">([])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([])</span> <span class="c1"># 3) 
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span>
<span class="n">deque</span><span class="p">([])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># 4)
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span>
<span class="n">deque</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># 5)
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span>
<span class="n">deque</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

</code></pre></div></div>

<p>객체를 초기화할 때 값을 넣어줄 것이 아니라면 리스트를 굳이 전달하지 않아도 똑같이 초기화가 된다. 다만, 특정값을 넣어줄 것이라면 반드시 <code class="language-plaintext highlighter-rouge">iterable</code> 객체를 전달해야 한다. 이 때 <code class="language-plaintext highlighter-rouge">iterable</code> 객체는 어떤 형태를 넣어도 같은 결과를 반환하게 된다. 예를 들어 리스트를 넣고 <code class="language-plaintext highlighter-rouge">deque</code>를 초기화 하나 튜플을 넣고 초기화 하나 결과는 같다는 것이다. 예시 코드의 4번과 5번 예시를 보자. 각각 리스트와 튜플을 넣고 초기화를 했지만 초기화 결과는 동일한 것을 확인할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># deque indexing &amp; slicing
</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">2</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">[:]</span>
<span class="nb">TypeError</span><span class="p">:</span> <span class="n">sequence</span> <span class="n">index</span> <span class="n">must</span> <span class="n">be</span> <span class="n">integer</span><span class="p">,</span> <span class="ow">not</span> <span class="s">'slice'</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">deque</code> 는 리스트처럼 인덱싱은 가능하지만, 슬라이싱 기능은 활용할 수 없으니 참고하자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># deqeue max_len example
</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="mi">6</span><span class="p">)</span>  <span class="c1"># 객체라서 초기화가 필요하다.
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span>
<span class="n">deque</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
</code></pre></div></div>

<p>한편, <code class="language-plaintext highlighter-rouge">max_len</code> 매개변수를 통해 선언한 객체의 최대 길이를 지정해 줄 수 있는데, 이 때 객체가 지정 길이를 넘어서면 큐의 동작처럼 가장 왼쪽에 위치한 원소를 먼저 빼고 새로운 원소를 가장 오른쪽에 추가한다.</p>

<p>만약 deque를 이용해 스택을 구현하고 싶다면 <code class="language-plaintext highlighter-rouge">deque.append</code>와 <code class="language-plaintext highlighter-rouge">deque.pop</code>을 사용하자. 정확히 선입후출 동작을 구현할 수 있다. 한편 큐를 구현하고 싶다면 <code class="language-plaintext highlighter-rouge">deque.append</code>와 <code class="language-plaintext highlighter-rouge">deque.popleft</code>를 함께 사용하자. 정확히 선입선출 구조를 만들어낼 수 있다. 한편 가장 첫번째 원소 앞에 새로운 원소를 추가하고 싶다면 <code class="language-plaintext highlighter-rouge">appendleft()</code> 역시 지원하고 있으니 참고해두면 좋을 것 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># deque stack &amp; queue 구현
</span>
<span class="s">""" stack """</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
<span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
<span class="mi">1</span>

<span class="s">""" queue """</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
<span class="mi">3</span>
</code></pre></div></div>

<h4 id="️-counter"><code class="language-plaintext highlighter-rouge">🗂️ Counter</code></h4>

<p><code class="language-plaintext highlighter-rouge">Iterable</code> 객체에 있는 <code class="language-plaintext highlighter-rouge">hashable item</code>의 개수를 세어 <code class="language-plaintext highlighter-rouge">Dict</code> 자료형으로 반환하는 역할을 한다. 아래 예시를 보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># collection.Counter example
</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">test</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span>
<span class="n">Counter</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">test</span> <span class="o">=</span> <span class="s">'aabcdacdbbbbaaaadddcccbcbcbcbcbcbbcbcbcbcbcdaadaabadbcdbcdacdbacdbacdbcadacbbcabcadb'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span>
<span class="n">Counter</span><span class="p">({</span><span class="s">'a'</span><span class="p">:</span> <span class="mi">19</span><span class="p">,</span> <span class="s">'b'</span><span class="p">:</span> <span class="mi">26</span><span class="p">,</span> <span class="s">'c'</span><span class="p">:</span> <span class="mi">24</span><span class="p">,</span> <span class="s">'d'</span><span class="p">:</span> <span class="mi">15</span><span class="p">})</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span><span class="p">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">[(</span><span class="s">'b'</span><span class="p">,</span> <span class="mi">26</span><span class="p">),</span> <span class="p">(</span><span class="s">'c'</span><span class="p">,</span> <span class="mi">24</span><span class="p">),</span> <span class="p">(</span><span class="s">'a'</span><span class="p">,</span> <span class="mi">19</span><span class="p">)]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span><span class="p">.</span><span class="n">values</span>
<span class="n">dict_values</span><span class="p">([</span><span class="mi">19</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
<span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">,</span> <span class="s">'d'</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">counter</span><span class="p">.</span><span class="n">elements</span><span class="p">()))</span>
<span class="s">'aaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbccccccccccccccccccccccccddddddddddddddd'</span>
</code></pre></div></div>

<p>이처럼 <code class="language-plaintext highlighter-rouge">Iterable</code> 객체의 원소에 접근해 다양한 일을 수행할 수 있다. <code class="language-plaintext highlighter-rouge">most_common</code>은 가장 많이 사용된 원소를 순서대로 사용자가 지정한 등수만큼 보여준다. <code class="language-plaintext highlighter-rouge">values</code> 는 개별 <code class="language-plaintext highlighter-rouge">key</code>의 값을 반환한다. <code class="language-plaintext highlighter-rouge">join</code>, <code class="language-plaintext highlighter-rouge">sorted</code> 와 함께 하면 원소를 반복하는 것도 가능하다.</p>

<h4 id="defaultdict"><code class="language-plaintext highlighter-rouge">👌 defaultdict</code></h4>

<p>사전의 <code class="language-plaintext highlighter-rouge">key</code>에 대한 <code class="language-plaintext highlighter-rouge">value</code>가 아직 없지만, 미리 <code class="language-plaintext highlighter-rouge">value</code>의 자료형을 지정해주고 싶을 때 사용하면 유용하다. 예를 들어 동물의 종류를 분류하는 사전을 만들고 싶다고 가정해보자. 0번 <code class="language-plaintext highlighter-rouge">key</code>가 조류라고 해보자. 그럼 조류에 해당되는 <code class="language-plaintext highlighter-rouge">value</code>는 참새, 비둘기 … 앵무새 등 정말 많을 것이다. 이것을 한번에 그룹핑해 조류라는 카테고리에 속한다고 표현해주기 위해 우리는 리스트를 <code class="language-plaintext highlighter-rouge">value</code>의 기본 자료형으로 지정해주는 것이다. 이 때 defaultdict을 이용하면 쉽게 구현이 가능하다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># collections.defaultdict example
</span><span class="k">from</span> <span class="n">collections</span> <span class="n">ipmort</span> <span class="n">defaultdict</span>

<span class="n">animal_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">defaultdict</code> 에 어떤 자료형을 매개변수로 전달하는가에 따라서 초기화 되는 기본 자료형이 바뀐다. 우리는 <code class="language-plaintext highlighter-rouge">list</code> 를 기본 자료형으로 지정했지만 <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">set</code> 같은 것도 가능하니 참고해두자.</p>

<h3 id="️-heapq"><strong><code class="language-plaintext highlighter-rouge">🗂️ heapq</code></strong></h3>

<p>다익스트라 최단 경로 알고리즘을 포함한 다양한 알고리즘 문제에서 우선순위 큐 기능을 구현할 때 사용하는 라이브러리로 기본적으로 최소 힙(오름차순, 파이썬 내장 정렬 알고리즘의 특성으로 모두 기본값이 오름차순) 구성으로 되어 있다. <code class="language-plaintext highlighter-rouge">heapq.heappush()</code> 로 힙에 원소를 삽입하는 기능을 구현하며, <code class="language-plaintext highlighter-rouge">heapq.heappop()</code> 을 통해서 힙으로부터 원소를 빼낸다. 아래는 힙 정렬을 구현한 코드이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Min Heapsort
</span><span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">def</span> <span class="nf">min_heapsort</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
	<span class="n">h</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="c1"># heap에 원소 삽입
</span>	<span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
		<span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
	<span class="c1"># heap으로부터 원소 빼내기
</span>	<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)):</span>
		<span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
	
	<span class="k">return</span> <span class="n">result</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">min_heapsort</span><span class="p">([])</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Max Heapsort
</span><span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">def</span> <span class="nf">max_heapsort</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
	<span class="n">h</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
		<span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">-</span><span class="n">value</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)):</span>
		<span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>

	<span class="k">return</span> <span class="n">result</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">max_heapsort</span><span class="p">([])</span>
</code></pre></div></div>

<p>구현된 힙의 모든 원소가 정렬되는 것은 아니며 현재 최대,최소 원소에 대한 정렬만 보장하기 때문에 주의가 필요하다. 개별 시점에서 최대,최소값만 필요하다면 힙정렬 사용을 고려해보자.</p>

<h3 id="️-sort--sorted"><strong><code class="language-plaintext highlighter-rouge">🗂️ sort &amp; sorted</code></strong></h3>

<p>python <code class="language-plaintext highlighter-rouge">iterable</code> 객체를 빠르게 정렬할 때 사용하는 기능이다. 두 함수 모두 기능은 같지만 적용 대상 범위가 다르며, 함수 실행 결과가 반환 방식도 다르기 때문에 사용할 때 주의해야 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># sort, sorted 차이
</span><span class="n">result</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
<span class="n">result</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># 정렬 결과가 result에 반영
</span><span class="nb">sorted</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># 정렬 결과를 result에 반영 x
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">sort</code>는 정렬 결과를 매개 변수로 입력한 <code class="language-plaintext highlighter-rouge">iterable</code> 객체에 바로 적용되는 <code class="language-plaintext highlighter-rouge">in-place</code> 연산인 반면, <code class="language-plaintext highlighter-rouge">sorted</code>는 그렇지 않다. 한편 <code class="language-plaintext highlighter-rouge">sort</code> 는 리스트 자료형(<code class="language-plaintext highlighter-rouge">mutable object</code>)만 매개 변수로 입력 가능하지만, <code class="language-plaintext highlighter-rouge">sorted</code>는 모든 <code class="language-plaintext highlighter-rouge">iterable</code> 객체를 사용 가능하다.</p>

<p><code class="language-plaintext highlighter-rouge">reverse</code>, <code class="language-plaintext highlighter-rouge">reversed</code> 역시 위와 같은 규칙을 따르는데, <code class="language-plaintext highlighter-rouge">sort</code>, <code class="language-plaintext highlighter-rouge">reverse</code> 처럼 자료형 객체 내부에 내장된 메서드인 경우는 <code class="language-plaintext highlighter-rouge">in-place</code> 연산을 지원하고 <code class="language-plaintext highlighter-rouge">sorted</code>, <code class="language-plaintext highlighter-rouge">reversed</code> 처럼 <code class="language-plaintext highlighter-rouge">global</code> 한 내장 메서드인 경우는 <code class="language-plaintext highlighter-rouge">in-place</code> 를 지원하지 않는다. 이러한 경우에는 반드시 다른 변수에 대입해줘야 하니 주의하자.</p>

<p>만약 다중 조건을 적용해 <code class="language-plaintext highlighter-rouge">Iterable</code> 객체를 정렬하고 싶다면, 아래와 같이 튜플 형태로 <code class="language-plaintext highlighter-rouge">lambda function</code> 에 적용하고 싶은 우선순위대로 기준을 입력해주면 된다. 구체적인 예시는 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" 
lecture_schedule = [시작시간, 끝시간] 
끝나는 시간을 기준으로 오름 차순 정렬하되, 끝나는 시간이 같으면, 시작 시간 오름 차순 정렬 적용 
"""</span>
<span class="n">lecture_schedule</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="n">lecture_schedule</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1"># key=lambda x:(우선순위1, 우선순위2, 우선순위3 ...)
</span><span class="n">lecture_schedule</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1"># - 붙인 정렬 조건은 현재 정렬 기준과 반대로
</span></code></pre></div></div>

<p>마지막으로 <code class="language-plaintext highlighter-rouge">-</code>를 붙인 조건은 현재 정렬 기준(오름차순, 내림차순)과 반대로 정렬을 하게 된다. 예시 코드의 3번째 라인처럼 <code class="language-plaintext highlighter-rouge">-</code> 을 붙이면 1번째는 내림 차순으로, 2번째는 오름 차순으로 정렬을 수행하게 된다. 정말 유용하니 꼭 기억해두자. 이걸 모르면, 해당 동작을 구현하기 위해 엄청난 코드 라인을 소비해야 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lambda x: x[1]과 동일한 결과
</span><span class="k">def</span> <span class="nf">second</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
	<span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="n">result</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
<span class="n">result</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">second</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># 정렬 결과가 result에 반영
</span><span class="nb">sorted</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">second</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># 정렬 결과를 result에 반영 x
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">lambda</code> 대신 직접 함수를 정의해 사용하는 것도 가능하니 꼭 기억해두자.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="collections" /><category term="Codeing Test" /><category term="Algorithm" /><summary type="html"><![CDATA[코딩 테스트 풀이에 자주 사용되는 파이썬 내장 라이브러리 사용법 정리]]></summary></entry><entry><title type="html">👩‍💻🎄 [baekjoon] 16920번: 확장게임</title><link href="http://localhost:4000/ps/baekjoon-16920" rel="alternate" type="text/html" title="👩‍💻🎄 [baekjoon] 16920번: 확장게임" /><published>2023-10-16T00:00:00+09:00</published><updated>2023-10-17T02:00:00+09:00</updated><id>http://localhost:4000/ps/baekjoon_16920</id><content type="html" xml:base="http://localhost:4000/ps/baekjoon-16920"><![CDATA[<h3 id="️solution"><strong><code class="language-plaintext highlighter-rouge">🖍️ solution</code></strong></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">():</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># direction of search
</span>    <span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">p_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span>  <span class="c1"># for matching index with player num
</span>    <span class="n">graph</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">M</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="n">player_q</span> <span class="o">=</span> <span class="p">[</span><span class="n">deque</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>  <span class="c1"># for matching index with player num
</span>
    <span class="c1"># 1) player dict 초기화
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">"."</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">"#"</span><span class="p">:</span>
                <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">now</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">now</span>
                <span class="n">player_q</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                <span class="n">scores</span><span class="p">[</span><span class="n">now</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># 2) 개별 player 탐색
</span>    <span class="n">turn</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">while</span> <span class="n">turn</span><span class="p">:</span>
        <span class="n">turn</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">player</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">P</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">player_q</span><span class="p">[</span><span class="n">player</span><span class="p">]:</span>  <span class="c1"># 이미 탐색이 종료된 플레이어 턴 스킵
</span>                <span class="k">continue</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">player_q</span><span class="p">[</span><span class="n">player</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p_list</span><span class="p">[</span><span class="n">player</span><span class="p">]):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>  <span class="c1"># 모든 플레이어들이 1개 이상 영역 확장 못하는데 최대 탐색 깊이가 매우 큰 경우, 헛돌게 된다
</span>                    <span class="k">break</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
                    <span class="n">vy</span><span class="p">,</span> <span class="n">vx</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                        <span class="n">ny</span> <span class="o">=</span> <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">vy</span>
                        <span class="n">nx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">vx</span>
                        <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="ow">and</span> <span class="n">graph</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">graph</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span> <span class="o">=</span> <span class="n">player</span>
                            <span class="n">scores</span><span class="p">[</span><span class="n">player</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">])</span>
                            <span class="n">turn</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">scores</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">solution</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="idea"><strong><code class="language-plaintext highlighter-rouge">💡 idea</code></strong></h3>

<ul>
  <li><strong>1) BFS</strong>
    <ul>
      <li><strong>1-1) <code class="language-plaintext highlighter-rouge">grid</code> 초기화</strong>
        <ul>
          <li><strong>루프 내부에 타입 캐스팅 함수 호출 방지를 위해 문자열 입력을 정수로 변환</strong></li>
          <li><strong>동시에 개별 플레이어의 초기 시작 위치를 개별 큐에 삽입(<code class="language-plaintext highlighter-rouge">player_q</code>)</strong></li>
          <li><strong>플레이어 점수 초기화 및 업데이트</strong></li>
        </ul>
      </li>
      <li><strong>1-2) <code class="language-plaintext highlighter-rouge">BFS</code> 순회</strong>
        <ul>
          <li><strong>라운드 구현: <code class="language-plaintext highlighter-rouge">while loop</code></strong></li>
          <li><strong>개별 플레이어 턴, 탐색 깊이 제한, 1회 탐색 및 동시 탐색 구현: <code class="language-plaintext highlighter-rouge">for-loop</code></strong>
            <ul>
              <li><strong>개별 플레이어 턴: <code class="language-plaintext highlighter-rouge">for player in range(1, P+1):</code></strong></li>
              <li><strong>탐색 깊이 제한: <code class="language-plaintext highlighter-rouge">for _ in range(p_list[player]):</code></strong>
                <ul>
                  <li><strong>모든 플레이어가 1개 이상 영역 확장 불가한 상황 and 최대 탐색 깊이 매우 큰 경우</strong>
                    <ul>
                      <li><strong>탐색 깊이 제한 루프를 헛돌게 되기 때문에 시간 초과 발생</strong></li>
                      <li><strong>큐가 비었다면 루프 탈출하도록 코드 추가 필요: <code class="language-plaintext highlighter-rouge">break if not q</code></strong></li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li><strong>1회 탐색 및 동시 탐색 구현: <code class="language-plaintext highlighter-rouge">for _ in range(len(q)):</code></strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="반례"><strong><code class="language-plaintext highlighter-rouge">🤔 반례</code></strong></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" 반례 케이스 """</span>

<span class="mi">4</span> <span class="mi">10</span> <span class="mi">4</span>
<span class="mi">1000000000</span> <span class="mi">1</span> <span class="mi">100</span> <span class="mi">99999</span>
<span class="mi">1</span><span class="c1">#........
#.........
</span><span class="mi">2</span><span class="c1">#.......#
</span><span class="mi">3</span><span class="c1">#......#4
</span></code></pre></div></div>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Problem Solving" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="Graph" /><category term="BFS" /><summary type="html"><![CDATA[백준 16920번: 확장게임]]></summary></entry><entry><title type="html">👩‍💻🎄 [baekjoon] 15558번: 점프 게임</title><link href="http://localhost:4000/ps/baekjoon-15558" rel="alternate" type="text/html" title="👩‍💻🎄 [baekjoon] 15558번: 점프 게임" /><published>2023-10-16T00:00:00+09:00</published><updated>2023-10-17T02:00:00+09:00</updated><id>http://localhost:4000/ps/baekjoon_15558</id><content type="html" xml:base="http://localhost:4000/ps/baekjoon-15558"><![CDATA[<h3 id="️solution"><strong><code class="language-plaintext highlighter-rouge">🖍️ solution</code></strong></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">time</span><span class="p">,</span> <span class="n">flag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">False</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]])</span>
    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
            <span class="n">vy</span><span class="p">,</span> <span class="n">vx</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">vx</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">N</span> <span class="ow">or</span> <span class="n">vx</span><span class="o">+</span><span class="n">K</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">:</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">graph</span><span class="p">[</span><span class="n">vy</span><span class="p">][</span><span class="n">vx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">vy</span><span class="p">][</span><span class="n">vx</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># 앞으로 한 칸 이동
</span>                <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">vy</span><span class="p">,</span> <span class="n">vx</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">vy</span><span class="p">][</span><span class="n">vx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="k">if</span> <span class="n">vx</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">time</span><span class="o">+</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">graph</span><span class="p">[</span><span class="n">vy</span><span class="p">][</span><span class="n">vx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">vy</span><span class="p">][</span><span class="n">vx</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># 뒤로 한 칸 이동, 갈 수 없는 구역을 미리 예상해서 풀어야 함
</span>                <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">vy</span><span class="p">,</span> <span class="n">vx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">vy</span><span class="p">][</span><span class="n">vx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="k">if</span> <span class="n">graph</span><span class="p">[(</span><span class="n">vy</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">][</span><span class="n">vx</span><span class="o">+</span><span class="n">K</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[(</span><span class="n">vy</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">][</span><span class="n">vx</span><span class="o">+</span><span class="n">K</span><span class="p">]:</span>  <span class="c1"># 앞으로 한 칸 이동
</span>                <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">([(</span><span class="n">vy</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="n">vx</span><span class="o">+</span><span class="n">K</span><span class="p">])</span>
                <span class="n">visited</span><span class="p">[(</span><span class="n">vy</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">][</span><span class="n">vx</span><span class="o">+</span><span class="n">K</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">time</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">flag</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
    <span class="k">print</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">bfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="k">print</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><strong><code class="language-plaintext highlighter-rouge">💡 idea</code></strong></h3>

<ul>
  <li><strong>매초마다 블럭 사라지는 기능 필요</strong>
    <ul>
      <li><strong>매초 단위로 큐입력을 끊기</strong></li>
      <li><strong>while &amp; for-loop는 초단위로 큐입력 끊어내는 구현하기 매우 어려움</strong></li>
      <li><strong>일반적인 bfs 구현체 대신 if-else 구문으로 큐 하나에 대한 모든 경우의 수가 한 번에 처리 되도록 구현</strong></li>
      <li><strong>뒤로 가능 경우에 대해서만 예외처리</strong>
      - <strong>시간 초마다 블럭을 삭제하는 방법 X, 뒤로 가려는 블럭이 다음번에 삭제 예정인지 판단</strong>
          - <strong>사라질 예정이면 큐에 삽입하지 않고 <code class="language-plaintext highlighter-rouge">pass</code></strong></li>
    </ul>
  </li>
</ul>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Problem Solving" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="Graph" /><category term="BFS" /><summary type="html"><![CDATA[백준 15558번: 점프 게임 풀이]]></summary></entry><entry><title type="html">👨‍💻🐍 [Python] Function Argument</title><link href="http://localhost:4000/python/func_argu" rel="alternate" type="text/html" title="👨‍💻🐍 [Python] Function Argument" /><published>2023-10-14T00:00:00+09:00</published><updated>2023-10-15T02:00:00+09:00</updated><id>http://localhost:4000/python/python_function_arg</id><content type="html" xml:base="http://localhost:4000/python/func_argu"><![CDATA[<h3 id="function-argument"><strong><code class="language-plaintext highlighter-rouge">👨‍👩‍👧‍👦 Function Argument</code></strong></h3>

<p>파이썬의 모든 메서드는 기본적으로 인자를 <code class="language-plaintext highlighter-rouge">call by value</code> 형태로 전달해야 한다. 하지만 <code class="language-plaintext highlighter-rouge">call by value</code> 라고 해서 함수의 동작과 원본 변수가 완전히 독립적인 것은 아니다. 이것은 인자로 어떤 데이터 타입을 전달하는가에 따라 달라진다. 만약 인자로 <code class="language-plaintext highlighter-rouge">mutable(dynamic)</code> 객체인 리스트 변수를 전달했다면, 함수의 동작에 따른 결과가 그대로 변수에 반영된다. <code class="language-plaintext highlighter-rouge">mutable</code> 객체는 함수 스코프 내부 지역 변수에 카피 되지 않기 때문에 이런 현상이 발생한다. 따라서 인자로 리스트와 같은 <code class="language-plaintext highlighter-rouge">mutable</code> 객체를 전달하는 것은 수많은 부작용을 불러오기 때문에 지양하는게 좋다. 아래 예시 코드를 보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" function argument experiment with mutable vs immutable """</span>
<span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="n">args</span> <span class="o">+=</span> <span class="s">'in runtime'</span>
    <span class="k">print</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

<span class="c1"># immutable object string
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">immutable</span> <span class="o">=</span> <span class="s">'immutable'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">function</span><span class="p">(</span><span class="n">immutable</span><span class="p">)</span>
<span class="n">immutable</span> <span class="ow">in</span> <span class="n">runtime</span> 

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">mmutable</span><span class="p">)</span>
<span class="n">immutable</span>

<span class="c1"># mutable object list
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">mutable</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">'mutable'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">function</span><span class="p">(</span><span class="n">mutable</span><span class="p">)</span>
<span class="p">[</span><span class="s">'m'</span><span class="p">,</span> <span class="s">'u'</span><span class="p">,</span> <span class="s">'t'</span><span class="p">,</span> <span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'l'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">,</span> <span class="s">' '</span><span class="p">,</span> <span class="s">'i'</span><span class="p">,</span> <span class="s">'n'</span><span class="p">,</span> <span class="s">' '</span><span class="p">,</span> <span class="s">'r'</span><span class="p">,</span> <span class="s">'u'</span><span class="p">,</span> <span class="s">'n'</span><span class="p">,</span> <span class="s">'t'</span><span class="p">,</span> <span class="s">'i'</span><span class="p">,</span> <span class="s">'m'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">mutable</span><span class="p">)</span>
<span class="p">[</span><span class="s">'m'</span><span class="p">,</span> <span class="s">'u'</span><span class="p">,</span> <span class="s">'t'</span><span class="p">,</span> <span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'l'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">,</span> <span class="s">' '</span><span class="p">,</span> <span class="s">'i'</span><span class="p">,</span> <span class="s">'n'</span><span class="p">,</span> <span class="s">' '</span><span class="p">,</span> <span class="s">'r'</span><span class="p">,</span> <span class="s">'u'</span><span class="p">,</span> <span class="s">'n'</span><span class="p">,</span> <span class="s">'t'</span><span class="p">,</span> <span class="s">'i'</span><span class="p">,</span> <span class="s">'m'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">]</span>
</code></pre></div></div>

<p>동일한 함수에 동일하게 인자로 사용했지만, <code class="language-plaintext highlighter-rouge">immutable</code> 객체인 문자열은 함수의 실행 결과와 전혀 무관한 모습이다. 하지만 <code class="language-plaintext highlighter-rouge">mutable</code> 객체인 리스트는 함수의 실행 결과가 스코프 바깥의 원본 변수에 그대로 반영되었음을 확인할 수 있다. 이것은 리스트가 기본적으로 컨테이너 내부에 실제 값이 아닌 주소 값을 갖고 있고, <code class="language-plaintext highlighter-rouge">Resize()</code> 연산을 통해 수정이 가능하기 때문이다. 한편, <code class="language-plaintext highlighter-rouge">immutable</code> 객체의 경우 원본 수정이 불가하기 때문에 관련 연산 혹은 명령을 만나면 <code class="language-plaintext highlighter-rouge">deepcopy</code> 가 발생한다.</p>

<h3 id="packingunpacking"><strong><code class="language-plaintext highlighter-rouge">📦 Packing/Unpacking</code></strong></h3>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Python" /><category term="Python" /><category term="Function" /><category term="Argument" /><category term="mutable" /><category term="CS" /><summary type="html"><![CDATA[함수 인자 전달 메커니즘에 대한 이해]]></summary></entry><entry><title type="html">👨‍💻🐍 [Python] List &amp;amp; Tuple</title><link href="http://localhost:4000/python/list_tuple" rel="alternate" type="text/html" title="👨‍💻🐍 [Python] List &amp;amp; Tuple" /><published>2023-10-14T00:00:00+09:00</published><updated>2023-10-15T02:00:00+09:00</updated><id>http://localhost:4000/python/python_array</id><content type="html" xml:base="http://localhost:4000/python/list_tuple"><![CDATA[<h3 id="️concept-of-array-in-python"><strong><code class="language-plaintext highlighter-rouge">🗂️ Concept of Array in Python</code></strong></h3>

<p>C, C++, Java 같은 언어를 배울 때 가장 먼저 배우는 자료구조는 바로 배열이다. 그러나 파이썬을 배울 때는 조금 양상이 다르다. 배열이라는 표현의 자료구조는 언급도 없고 리스트, 튜플, 딕셔너리와 같은 형태의 자료구조에 대해서만 배우게 된다. 그렇다면 파이썬에 배열은 없는 것일까??</p>

<p>반은 맞고 반은 틀린 질문이라고 할 수 있다. 엄밀하게 말하면 앞에 나열한 언어들과 동일한 개념의 배열은 파이썬에 존재하지 않는다. 앞의 언어에서 배열이란 컨테이너 안에 값을 직접 담는 형태로 사용되지만, 순수한 파이썬의 배열은 값을 직접 담지 않고, 값의 래퍼런스를 담는 형태로 사용된다. 다시 말해 컨테이너에 값 대신 값이 위치한 곳의 주소를 담는다는 것이다. 덕분에 파이썬은 배열 형태의 자료구조에 데이터를 입력할 때, <code class="language-plaintext highlighter-rouge">type casting</code> 에서 자유롭다. 그래서 배열을 선언할 때 미리 배열의 자료형을 선언해줄 필요가 없는 것이다.</p>

<p>하지만 단점도 명확하다. 값 대신 주소를 담기 때문에 배열의 특정 위치값에 접근하려면 한단계를 더 거쳐야 하는 것이다. 주소를 갖고 있기 때문에, 물리 메모리 상에서 다닥다닥 붙어 있을 필요가 사라지고, 물리 메모리 공간 여기 저기에 흩어져 있다. 결국 다닥다닥 서로 붙어 있는 다른 언어의 배열보다 동작 속도는 필연적으로 느릴 수 밖에 없다. 배열의 동작 속도를 높이기 위해 넘파이나, 파이토치, 텐서플로와 같은 수학 연산 프레임워크는 C/C++의 배열을 파이썬 API로 호출하는 형식을 사용하고 있다. 덕분에 순수 파이썬 배열 자료구조보다 훨씬 빠른 동작속도를 자랑한다.</p>

<p>여기까지 파이썬의 배열에 해당되는 자료구조에 대한 공통적인 특징에 대해서 살펴보았다. 파이썬에서 배열 역할을 하는 자료구조는 무엇이 있을까?? 바로 리스트와 튜플인데, 리스트는 <code class="language-plaintext highlighter-rouge">mutable(dynamic) array</code>, 튜플은 <code class="language-plaintext highlighter-rouge">immutable(static) array</code> 의 역할을 한다. 리스트는 수정이 가능한 배열, 튜플은 선언 이후 수정이 불가한 배열이라고 생각하면 된다. 덕분에 객체 내부에 내장된 매직 메서드에 차이가 생긴다.</p>

<p>전자는 수정 사항을 반영해야 하기 때문에 <code class="language-plaintext highlighter-rouge">Resize()</code> 연산을 위해 별도의 매직 메서드가 구현되어 있으며, 이를 위해 현재 리스트의 길이 정보를 리스트 내부에 저장한다. 한편, 같은 크기의 데이터를 각각 리스트, 튜플에 넣더라도 리스트의 메모리가 더 크게 잡히게 된다. 그 이유는 <code class="language-plaintext highlighter-rouge">mutable</code> 한 특성을 고려해 인터프리터가 메모리 요청을 위해 커널과 커뮤니케이션 하는 횟수를 줄이기 위해 여유분까지 추가해두기 때문이다.</p>

<p>반면 튜플은 선언 시점에 고정되기 때문에 굳이 런타임 때 커널에 메모리를 요청할 필요가 없다. 따라서 운영체제를 거치지 않기 때문에 리스트보다 빠르다. 또한 크기가 20 이하의 튜플이라면 최대 2만개까지는 래퍼런싱이 풀려도 <code class="language-plaintext highlighter-rouge">python gc(메모리 관리)</code> 가 곧바로 삭제하지 않고 캐시에 저장해둔다. 때문에 같은 크기의 튜플이 다시 필요해지면 메모리를 새로이 할당할 필요 없이 저장되어 있던 튜플을 재활용할 수 있어서 훨씬 효율적이다. 리스트 경우처럼 인터프리터가 운영체제에 메모리를 구걸할 필요가 없기 때문에 튜플의 생성 및 할당 속도가 훨씬 빨라진다.</p>

<p>따라서 저장하려는 데이터의 특성(가변, 불변)을 잘 파악해 자료구조를 선택하는 것이 파이썬 코드의 성능 개선에 매우 중요하다. 이제부터는 리스트와 튜플 각각에 대한 특성을 살펴보자.</p>

<h3 id="️-features-of-list"><strong><code class="language-plaintext highlighter-rouge">⭐️ Features of list</code></strong></h3>

<p>앞서 리스트는 <code class="language-plaintext highlighter-rouge">array + resize()</code> 이라고 언급했다. 그렇다면 리스트가 동적 속성을 어떻게 구현하고 있는지 살펴보자. 리스트는 동적 배열이라고 이름 붙었지만 사실 진짜 실시간으로 배열의 크기가 증가하는 것은 아니다. 튜플과 마찬가지로 선언 시점에 특정한 크기에 맞는 공간을 할당 받는다. 다만 이후 수정될 것을 고려해 같은 데이터라도 좀 더 큰 공간을 할당 받을 뿐이다. 만약 어떤 입력 $A$에 대해서 튜플이 $N$의 공간을 할당 받는다면, 같은 입력에 대해 리스트는 $M (M &gt;N)$의 공간을 할당 받는 것이다. 만약 데이터가 추가될 때, 리스트의 전체 공간 크기를 점진적으로 늘리지 않고 남은 공간($M-N)$에 할당만 하다가, $N==M$이 되는 시점에 더 이상 추가하지 않고 크기가 $M$보다 큰 새로운 리스트를 메모리에 할당한다. 그 다음 기존 리스트를 그대로 복사해 <strong>새롭게 할당한 리스트에 복사</strong>한 뒤, 래퍼런싱이 사라진 이전 리스트는 <code class="language-plaintext highlighter-rouge">python gc</code> 가 삭제한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" Time Consuming """</span>
<span class="o">&gt;&gt;&gt;</span> <span class="o">%</span><span class="n">timeit</span> <span class="p">[[</span><span class="n">i</span><span class="o">*</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">)]</span>
<span class="mf">3.85</span> <span class="n">s</span> <span class="err">±</span> <span class="mf">44.5</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span> <span class="p">(</span><span class="n">mean</span> <span class="err">±</span> <span class="n">std</span><span class="p">.</span> <span class="n">dev</span><span class="p">.</span> <span class="n">of</span> <span class="mi">7</span> <span class="n">runs</span><span class="p">,</span> <span class="mi">1</span> <span class="n">loop</span> <span class="n">each</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="o">%</span><span class="n">timeit</span> <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span>         <span class="n">t</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">j</span><span class="p">)</span>
<span class="mf">13.3</span> <span class="n">ns</span> <span class="err">±</span> <span class="mf">0.0774</span> <span class="n">ns</span> <span class="n">per</span> <span class="n">loop</span> <span class="p">(</span><span class="n">mean</span> <span class="err">±</span> <span class="n">std</span><span class="p">.</span> <span class="n">dev</span><span class="p">.</span> <span class="n">of</span> <span class="mi">7</span> <span class="n">runs</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span><span class="mi">000</span><span class="p">,</span><span class="mi">000</span> <span class="n">loops</span> <span class="n">each</span><span class="p">)</span>

<span class="s">""" Memory Consuming """</span>
<span class="o">&gt;&gt;&gt;</span> <span class="o">%</span><span class="n">memit</span> <span class="p">[[</span><span class="n">i</span><span class="o">*</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">)]</span>
<span class="n">peak</span> <span class="n">memory</span><span class="p">:</span> <span class="mf">4323.73</span> <span class="n">MiB</span><span class="p">,</span> <span class="n">increment</span><span class="p">:</span> <span class="mf">3161.28</span> <span class="n">MiB</span>

<span class="o">&gt;&gt;&gt;</span>  <span class="o">%</span><span class="n">memit</span> <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span>  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span>         <span class="n">t</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">j</span><span class="p">)</span>
<span class="n">peak</span> <span class="n">memory</span><span class="p">:</span> <span class="mf">1297.91</span> <span class="n">MiB</span><span class="p">,</span> <span class="n">increment</span><span class="p">:</span> <span class="mf">0.02</span> <span class="n">MiB</span>
</code></pre></div></div>

<p>정리하면, 리스트는 실시간으로 배열 크기를 증가시키는게 아니라, 생성할 때 필요한 양보다 일부러 좀 더 많이 땡겨놓고 데이터를 계속 추가 하다가 빈공간이 없으면 더 큰 공간에 리스트를 새롭게 할당해 동적인 속성을 구현한다.</p>

<p>따라서 이미 선언된 리스트(특히 꽉찬)에 <code class="language-plaintext highlighter-rouge">append()</code> 를 통해 데이터를 추가하게 되면 메모리 재할당이 지속적으로 일어나 메모리도 많이 잡아먹고 생성 시간도 매우 느려지게 된다. 이것이 파이썬에서 <code class="language-plaintext highlighter-rouge">list comprehension</code> 사용을 권장하는 이유다.</p>

<h3 id="️-features-of-tuple"><strong><code class="language-plaintext highlighter-rouge">⭐️ Features of tuple</code></strong></h3>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Python" /><category term="Python" /><category term="array" /><category term="list" /><category term="tuple" /><category term="list comprehension" /><category term="CS" /><summary type="html"><![CDATA[List, Tuple에 대한 이해]]></summary></entry><entry><title type="html">🤖 [P-Tuning] GPT Understand Too</title><link href="http://localhost:4000/nlp/p-tuning" rel="alternate" type="text/html" title="🤖 [P-Tuning] GPT Understand Too" /><published>2023-09-12T00:00:00+09:00</published><updated>2023-09-13T01:00:00+09:00</updated><id>http://localhost:4000/nlp/P_Tuning</id><content type="html" xml:base="http://localhost:4000/nlp/p-tuning"><![CDATA[<h3 id="overview"><code class="language-plaintext highlighter-rouge">🔭 Overview</code></h3>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="NLP" /><category term="Natural Language Process" /><category term="Self-Attention" /><category term="GPT" /><category term="Decoder" /><category term="p-tuning" /><category term="prompt learning" /><category term="AR" /><category term="Uni-Directional" /><summary type="html"><![CDATA[P-Tuning official paper review with implementation code by pytorch]]></summary></entry></feed>