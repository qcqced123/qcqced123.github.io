<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-10-14T22:45:59+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">AI/Business Study Log</title><subtitle>NLP, Marketing</subtitle><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><entry><title type="html">👨‍💻🐍 [Python] List &amp;amp; Tuple</title><link href="http://localhost:4000/python/list_tuple" rel="alternate" type="text/html" title="👨‍💻🐍 [Python] List &amp;amp; Tuple" /><published>2023-10-14T00:00:00+09:00</published><updated>2023-10-15T02:00:00+09:00</updated><id>http://localhost:4000/python/python_array</id><content type="html" xml:base="http://localhost:4000/python/list_tuple"><![CDATA[<h3 id="️concept-of-array-in-python"><strong><code class="language-plaintext highlighter-rouge">🗂️ Concept of Array in Python</code></strong></h3>

<p>C, C++, Java 같은 언어를 배울 때 가장 먼저 배우는 자료구조는 바로 배열이다. 그러나 파이썬을 배울 때는 조금 양상이 다르다. 배열이라는 표현의 자료구조는 언급도 없고 리스트, 튜플, 딕셔너리와 같은 형태의 자료구조에 대해서만 배우게 된다. 그렇다면 파이썬에 배열은 없는 것일까??</p>

<p>반은 맞고 반은 틀린 질문이라고 할 수 있다. 엄밀하게 말하면 앞에 나열한 언어들과 동일한 개념의 배열은 파이썬에 존재하지 않는다. 앞의 언어에서 배열이란 컨테이너 안에 값을 직접 담는 형태로 사용되지만, 순수한 파이썬의 배열은 값을 직접 담지 않고, 값의 래퍼런스를 담는 형태로 사용된다. 다시 말해 컨테이너에 값 대신 값이 위치한 곳의 주소를 담는다는 것이다. 덕분에 파이썬은 배열 형태의 자료구조에 데이터를 입력할 때, <code class="language-plaintext highlighter-rouge">type casting</code> 에서 자유롭다. 그래서 배열을 선언할 때 미리 배열의 자료형을 선언해줄 필요가 없는 것이다.</p>

<p>하지만 단점도 명확하다. 값 대신 주소를 담기 때문에 배열의 특정 위치값에 접근하려면 한단계를 더 거쳐야 하는 것이다. 주소를 갖고 있기 때문에, 물리 메모리 상에서 다닥다닥 붙어 있을 필요가 사라지고, 물리 메모리 공간 여기 저기에 흩어져 있다. 결국 다닥다닥 서로 붙어 있는 다른 언어의 배열보다 동작 속도는 필연적으로 느릴 수 밖에 없다. 배열의 동작 속도를 높이기 위해 넘파이나, 파이토치, 텐서플로와 같은 수학 연산 프레임워크는 C/C++의 배열을 파이썬 API로 호출하는 형식을 사용하고 있다. 덕분에 순수 파이썬 배열 자료구조보다 훨씬 빠른 동작속도를 자랑한다.</p>

<p>여기까지 파이썬의 배열에 해당되는 자료구조에 대한 공통적인 특징에 대해서 살펴보았다. 파이썬에서 배열 역할을 하는 자료구조는 무엇이 있을까?? 바로 리스트와 튜플인데, 리스트는 <code class="language-plaintext highlighter-rouge">mutable(dynamic) array</code>, 튜플은 <code class="language-plaintext highlighter-rouge">immutable(static) array</code> 의 역할을 한다. 리스트는 수정이 가능한 배열, 튜플은 선언 이후 수정이 불가한 배열이라고 생각하면 된다. 덕분에 객체 내부에 내장된 매직 메서드에 차이가 생긴다.</p>

<p>전자는 수정 사항을 반영해야 하기 때문에 <code class="language-plaintext highlighter-rouge">Resize()</code> 연산을 위해 별도의 매직 메서드가 구현되어 있으며, 이를 위해 현재 리스트의 길이 정보를 리스트 내부에 저장한다. 한편, 같은 크기의 데이터를 각각 리스트, 튜플에 넣더라도 리스트의 메모리가 더 크게 잡히게 된다. 그 이유는 <code class="language-plaintext highlighter-rouge">mutable</code> 한 특성을 고려해 인터프리터가 메모리 요청을 위해 커널과 커뮤니케이션 하는 횟수를 줄이기 위해 여유분까지 추가해두기 때문이다.</p>

<p>반면 튜플은 선언 시점에 고정되기 때문에 굳이 런타임 때 커널에 메모리를 요청할 필요가 없다. 따라서 운영체제를 거치지 않기 때문에 리스트보다 빠르다. 또한 크기가 20 이하의 튜플이라면 최대 2만개까지는 래퍼런싱이 풀려도 <code class="language-plaintext highlighter-rouge">python gc(메모리 관리)</code> 가 곧바로 삭제하지 않고 캐시에 저장해둔다. 때문에 같은 크기의 튜플이 다시 필요해지면 메모리를 새로이 할당할 필요 없이 저장되어 있던 튜플을 재활용할 수 있어서 훨씬 효율적이다. 리스트 경우처럼 인터프리터가 운영체제에 메모리를 구걸할 필요가 없기 때문에 튜플의 생성 및 할당 속도가 훨씬 빨라진다.</p>

<p>따라서 저장하려는 데이터의 특성(가변, 불변)을 잘 파악해 자료구조를 선택하는 것이 파이썬 코드의 성능 개선에 매우 중요하다. 이제부터는 리스트와 튜플 각각에 대한 특성을 살펴보자.</p>

<h3 id="️-features-of-list"><strong><code class="language-plaintext highlighter-rouge">⭐️ Features of list</code></strong></h3>

<p>앞서 리스트는 <code class="language-plaintext highlighter-rouge">array + resize()</code> 이라고 언급했다. 그렇다면 리스트가 동적 속성을 어떻게 구현하고 있는지 살펴보자. 리스트는 동적 배열이라고 이름 붙었지만 사실 진짜 실시간으로 배열의 크기가 증가하는 것은 아니다. 튜플과 마찬가지로 선언 시점에 특정한 크기에 맞는 공간을 할당 받는다. 다만 이후 수정될 것을 고려해 같은 데이터라도 좀 더 큰 공간을 할당 받을 뿐이다. 만약 어떤 입력 $A$에 대해서 튜플이 $N$의 공간을 할당 받는다면, 같은 입력에 대해 리스트는 $M (M &gt;N)$의 공간을 할당 받는 것이다. 만약 데이터가 추가될 때, 리스트의 전체 공간 크기를 점진적으로 늘리지 않고 남은 공간($M-N)$에 할당만 하다가, $N==M$이 되는 시점에 더 이상 추가하지 않고 크기가 $M$보다 큰 새로운 리스트를 메모리에 할당한다. 그 다음 기존 리스트를 그대로 복사해 <strong>새롭게 할당한 리스트에 복사</strong>한 뒤, 래퍼런싱이 사라진 이전 리스트는 <code class="language-plaintext highlighter-rouge">python gc</code> 가 삭제한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" Time Consuming """</span>
<span class="o">&gt;&gt;&gt;</span> <span class="o">%</span><span class="n">timeit</span> <span class="p">[[</span><span class="n">i</span><span class="o">*</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">)]</span>
<span class="mf">3.85</span> <span class="n">s</span> <span class="err">±</span> <span class="mf">44.5</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span> <span class="p">(</span><span class="n">mean</span> <span class="err">±</span> <span class="n">std</span><span class="p">.</span> <span class="n">dev</span><span class="p">.</span> <span class="n">of</span> <span class="mi">7</span> <span class="n">runs</span><span class="p">,</span> <span class="mi">1</span> <span class="n">loop</span> <span class="n">each</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="o">%</span><span class="n">timeit</span> <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span>         <span class="n">t</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">j</span><span class="p">)</span>
<span class="mf">13.3</span> <span class="n">ns</span> <span class="err">±</span> <span class="mf">0.0774</span> <span class="n">ns</span> <span class="n">per</span> <span class="n">loop</span> <span class="p">(</span><span class="n">mean</span> <span class="err">±</span> <span class="n">std</span><span class="p">.</span> <span class="n">dev</span><span class="p">.</span> <span class="n">of</span> <span class="mi">7</span> <span class="n">runs</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span><span class="mi">000</span><span class="p">,</span><span class="mi">000</span> <span class="n">loops</span> <span class="n">each</span><span class="p">)</span>

<span class="s">""" Memory Consuming """</span>
<span class="o">&gt;&gt;&gt;</span> <span class="o">%</span><span class="n">memit</span> <span class="p">[[</span><span class="n">i</span><span class="o">*</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">)]</span>
<span class="n">peak</span> <span class="n">memory</span><span class="p">:</span> <span class="mf">4323.73</span> <span class="n">MiB</span><span class="p">,</span> <span class="n">increment</span><span class="p">:</span> <span class="mf">3161.28</span> <span class="n">MiB</span>

<span class="o">&gt;&gt;&gt;</span>  <span class="o">%</span><span class="n">memit</span> <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span>  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span>         <span class="n">t</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">j</span><span class="p">)</span>
<span class="n">peak</span> <span class="n">memory</span><span class="p">:</span> <span class="mf">1297.91</span> <span class="n">MiB</span><span class="p">,</span> <span class="n">increment</span><span class="p">:</span> <span class="mf">0.02</span> <span class="n">MiB</span>
</code></pre></div></div>

<p>정리하면, 리스트는 실시간으로 배열 크기를 증가시키는게 아니라, 생성할 때 필요한 양보다 일부러 좀 더 많이 땡겨놓고 데이터를 계속 추가 하다가 빈공간이 없으면 더 큰 공간에 리스트를 새롭게 할당해 동적인 속성을 구현한다.</p>

<p>따라서 이미 선언된 리스트(특히 꽉찬)에 <code class="language-plaintext highlighter-rouge">append()</code> 를 통해 데이터를 추가하게 되면 메모리 재할당이 지속적으로 일어나 메모리도 많이 잡아먹고 생성 시간도 매우 느려지게 된다. 이것이 파이썬에서 <code class="language-plaintext highlighter-rouge">list comprehension</code> 사용을 권장하는 이유다.</p>

<h3 id="️-features-of-tuple"><strong><code class="language-plaintext highlighter-rouge">⭐️ Features of tuple</code></strong></h3>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Python" /><category term="Python" /><category term="array" /><category term="list" /><category term="tuple" /><category term="list comprehension" /><category term="CS" /><summary type="html"><![CDATA[List, Tuple에 대한 이해]]></summary></entry><entry><title type="html">🤖 [P-Tuning] GPT Understand Too</title><link href="http://localhost:4000/nlp/p-tuning" rel="alternate" type="text/html" title="🤖 [P-Tuning] GPT Understand Too" /><published>2023-09-12T00:00:00+09:00</published><updated>2023-09-13T01:00:00+09:00</updated><id>http://localhost:4000/nlp/P_Tuning</id><content type="html" xml:base="http://localhost:4000/nlp/p-tuning"><![CDATA[<h3 id="overview"><code class="language-plaintext highlighter-rouge">🔭 Overview</code></h3>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="NLP" /><category term="Natural Language Process" /><category term="Self-Attention" /><category term="GPT" /><category term="Decoder" /><category term="p-tuning" /><category term="prompt learning" /><category term="AR" /><category term="Uni-Directional" /><summary type="html"><![CDATA[P-Tuning official paper review with implementation code by pytorch]]></summary></entry><entry><title type="html">👩‍💻🔭 [baekjoon] 1962번: 그림</title><link href="http://localhost:4000/algorithm/baekjoon-1962" rel="alternate" type="text/html" title="👩‍💻🔭 [baekjoon] 1962번: 그림" /><published>2023-08-30T00:00:00+09:00</published><updated>2023-08-31T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/baekjoon_1962</id><content type="html" xml:base="http://localhost:4000/algorithm/baekjoon-1962"><![CDATA[<h3 id="️solution"><code class="language-plaintext highlighter-rouge">🖍️ solution</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="s">"""
[시간]
1) 16:50 ~ 17:20
[요약]
1) 큰 도화지에 그림이 그려져 있을 때, 그 그림의 개수와, 그 그림 중 넓이가 가장 넓은 것의 넓이를 출력
    - 영역 구분 및 넓이가 가장 큰 영역의 넓이 구하는 프로그램 작성
    - 상하좌우 1로 연결된 것이 그림
[전략]
1) BFS
    - 시간은 넉넉함
    - 조건문에서 다중조건 쓸 때 순서 유의해서 작성하기
"""</span>
<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">visit</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">visit</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">vy</span><span class="p">,</span> <span class="n">vx</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">ny</span> <span class="o">=</span> <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">vy</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">vx</span>
            <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="ow">and</span> <span class="n">paper</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visit</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]:</span>
                <span class="n">visit</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">])</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">count</span>

<span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">paper</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="n">visited</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="n">M</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>

<span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">paper</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">bfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">visited</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><code class="language-plaintext highlighter-rouge">💡 idea</code></h3>

<ul>
  <li><strong>1) <code class="language-plaintext highlighter-rouge">BFS</code>로 풀이</strong>
    <ul>
      <li><strong>테이블 형태로 자료구조가 주어지면 BFS로 접근하는게 좀 더 편리</strong>
        <ul>
          <li>특히 영역 분할, 넓이 구하는 문제는 <code class="language-plaintext highlighter-rouge">BFS</code>가 유리</li>
          <li><code class="language-plaintext highlighter-rouge">recursionlimit</code> 도 피할 수 있음</li>
        </ul>
      </li>
      <li><strong>조건문에서 다중 조건 사용할 때, 순서 유의해서 조건 나열하기</strong>
        <ul>
          <li>순서 맘대로 막하면 <code class="language-plaintext highlighter-rouge">IndexError</code> 발생</li>
        </ul>
      </li>
      <li><strong>도화지에 그림이 없는 경우 예외처리</strong></li>
    </ul>
  </li>
</ul>

<h3 id="experiement"><code class="language-plaintext highlighter-rouge">🧪 experiement</code></h3>

<p align="center">
<img src="/assets/images/algorithm/baekjoon_1962_experiment_result.png" alt="Experiment Result" class="align-center image-caption" width="100%&quot;, height=&quot;50%" />
<strong><em>Experiment Result</em></strong>
</p>

<p>첫번째 풀이 제출은 메서드에 <code class="language-plaintext highlighter-rouge">visited</code> 변수를 <code class="language-plaintext highlighter-rouge">지역 변수</code>로 할당하고 사용한 결과고, 두번째 풀이 제출은 <code class="language-plaintext highlighter-rouge">전역 변수</code> 처리하고 얻은 결과다. 전자가 메모리를 덜 소비하며, 연산 역시 더 빠른 모습이다. 반드시 메서드에서 사용할 변수들은 모두 스택에 할당해 지역 변수로 사용하자.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="String Handle" /><summary type="html"><![CDATA[백준 1962번 그림 풀이]]></summary></entry><entry><title type="html">👩‍💻🔠 [baekjoon] 5052번: 전화번호 목록</title><link href="http://localhost:4000/algorithm/baekjoon-5052" rel="alternate" type="text/html" title="👩‍💻🔠 [baekjoon] 5052번: 전화번호 목록" /><published>2023-08-29T00:00:00+09:00</published><updated>2023-08-30T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/baekjoon_5052</id><content type="html" xml:base="http://localhost:4000/algorithm/baekjoon-5052"><![CDATA[<h3 id="️solution"><code class="language-plaintext highlighter-rouge">🖍️ solution</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="s">"""
[시간]
1) 15:20 ~ 16:00

[요약]
1) 주어진 전화번호 목록을 보고, 일관성이 여부 판단
    - 하나의 번호가 다른 번호의 접두어 X
    - 주어진 모든 번호에 동일하게 연락할 수 있어야 일관성 있다고 판단
[전략]
1) 전화번호 앞자리를 최우선 기준으로 정렬
    - 시간 제한 &amp; 입력의 길이: 이중 루프 커버 불가능
    - 숫자처럼 생긴 '문자열'을 정렬, 길이와 관계 없이 자리수에 채워진 숫자가 비슷한 번호끼리 뭉침
        =&gt; 그래서 굳이 이중 루프를 이용해 전체를 탐색할 필요가 없음
        =&gt; 애초에 비슷한 것끼리 뭉쳐 있는 상태라서, local optimal ~ global optimal 기대 가능
        =&gt; 다만, 길이를 기준으로 정렬한게 아니라서, 슬라이싱 기준을 길이로 정해 줘야 한다.
"""</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())):</span>
    <span class="n">checker</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="s">'YES'</span>
    <span class="n">num_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">()))]</span>
    <span class="n">num_list</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num_list</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))]</span> <span class="o">==</span> <span class="n">num_list</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][:</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))]:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'NO'</span><span class="p">)</span>
            <span class="n">checker</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">checker</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><code class="language-plaintext highlighter-rouge">💡 idea</code></h3>

<ul>
  <li><strong>1) 전화번호 앞자리를 최우선 기준으로 정렬</strong>
    <ul>
      <li><strong>시간 제한 &amp; 입력의 길이: 이중 루프 커버 불가능</strong></li>
      <li><strong>숫자처럼 생긴 ‘문자열’을 정렬, 길이와 관계 없이 자리수에 채워진 숫자가 비슷한 번호끼리 뭉침</strong>
        <ul>
          <li><strong>그래서 굳이 이중 루프를 이용해 전체를 탐색할 필요가 없음</strong></li>
          <li><strong>애초에 비슷한 것끼리 뭉쳐 있는 상태라서, <code class="language-plaintext highlighter-rouge">local optimal ~ global optimal</code> 기대 가능</strong></li>
          <li><strong>다만, 길이를 기준으로 정렬한게 아니라서, 슬라이싱 기준을 길이로 정해 줘야 한다.</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>무지성으로 사용하던 정렬에 대해서 다시 한 번 생각하게 된 계기가 된 문제다. 필자는 처음 이 문제를 풀이할 때, 정렬하는 대상을 숫자라고 오인해 <code class="language-plaintext highlighter-rouge">key=len</code> 을 사용해 정렬을 했다. 이렇게 하면 문제가 무조건 이중 루프를 사용해야만 한다. 그러면 시간 초과에 걸리기 때문에 문제를 해결할 수 없다.</p>

<p>문제를 틀리고 나서 생각을 해보니, 정렬하는 대상은 실제 숫자가 아니라 <code class="language-plaintext highlighter-rouge">‘숫자처럼 생긴’</code> 문자열이다. 이 점을 잘 이용하면, 앞자리의 숫자가 비슷한 것끼리 뭉치게 정렬을 해줄 수 있다. 그렇다면 굳이 이중루프를 사용할 필요가 사라지고, 바로 옆 원소와 대조만 해도 <code class="language-plaintext highlighter-rouge">global optimal</code>을 기대해볼 수 있게 된다. 하지만 길이를 기준으로 문자열을 정렬한 것은 아니기 때문에 슬라이싱 기준을 <code class="language-plaintext highlighter-rouge">min()</code>을 이용해 더 짧은 문자열로 삼아줘야 한다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="String Handle" /><summary type="html"><![CDATA[백준 5052번 전화번호 목록]]></summary></entry><entry><title type="html">👩‍💻💵 [baekjoon] 1789번: 수들의 합</title><link href="http://localhost:4000/algorithm/baekjoon-1789" rel="alternate" type="text/html" title="👩‍💻💵 [baekjoon] 1789번: 수들의 합" /><published>2023-08-29T00:00:00+09:00</published><updated>2023-08-30T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/baekjoon_1789</id><content type="html" xml:base="http://localhost:4000/algorithm/baekjoon-1789"><![CDATA[<h3 id="️solution"><code class="language-plaintext highlighter-rouge">🖍️ solution</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="s">"""
[시간]
1) 01:40 ~ 02:10
[요약]
1) S: 서로 다른 N개의 자연수들의 합
    =&gt; 이 때, 자연수 N의 최대값
[전략]
1) 자연수 개수가 최대가 되도록 만들 어야 하기 때문에 최대한 작은 수들의 합으로 S를 구성
    - 10: 1,2,3,4 =&gt; 4개
"""</span>
<span class="n">S</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>
<span class="c1"># for 1, 2
</span><span class="k">if</span> <span class="n">S</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">tmp_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">S</span> <span class="o">-</span> <span class="n">tmp_sum</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">:</span>
            <span class="n">tmp_sum</span> <span class="o">+=</span> <span class="n">num</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><code class="language-plaintext highlighter-rouge">💡 idea</code></h3>

<ul>
  <li><strong>1) 최대한 작은 수들의 합으로 S를 구성</strong>
    <ul>
      <li><strong>최대한 작은 수들로 더할수록 N이 가장 커지기 때문</strong>
        <ul>
          <li><strong>쭉 더하다가 마지막에 <code class="language-plaintext highlighter-rouge">S - 지금까지 합</code> 의 수를 포함 시켜주면 되기 때문에 해결 가능</strong>
            <ul>
              <li><strong>사실 그 마저도 구하는게 숫자의 개수라서 값을 정확히 안구해줘도 된다</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="String Handle" /><summary type="html"><![CDATA[백준 1789번 수들의 합 풀이]]></summary></entry><entry><title type="html">👩‍💻🔠 [baekjoon] 17609번: 회문</title><link href="http://localhost:4000/algorithm/baekjoon-17609" rel="alternate" type="text/html" title="👩‍💻🔠 [baekjoon] 17609번: 회문" /><published>2023-08-29T00:00:00+09:00</published><updated>2023-08-30T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/baekjoon_17609</id><content type="html" xml:base="http://localhost:4000/algorithm/baekjoon-17609"><![CDATA[<h3 id="️solution"><code class="language-plaintext highlighter-rouge">🖍️ solution</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="s">"""
[시간]
1) 14:20 ~ 14:45

[요약]
1) 유사회문: 한 문자를 삭제하여 회문으로 만들 수 있는 문자열
    =&gt; 유사회문인지 아닌지 판단하는 프로그램 작성
2) 주어진 문자열의 길이는 10만, 문자열 개수는 최대 30개
    =&gt; 제한 시간이 1초라서 O(n)의 알고리즘을 설계 필요, Counter 사용 불가
[전략]
1) 슬라이싱 이용해서 원본과 뒤집은 문자열을 비교하는 과정에서 걸러내기 (루프 하나만 쓰게 만들 수 있음)
    - 각 자리를 대조하면 가장 처음 다른 문자가 등장하는 지점을 찾아재 해당 문자를 제거함.
    - 제거하는 것도 두가지 케이스가 발생, 둘 중 하나만 만족해도 유사 팰린드롬으로 판정
        =&gt; 원본의 문자 제거
        =&gt; 역본의 문자 제거
"""</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())):</span>
    <span class="n">checker1</span><span class="p">,</span> <span class="n">checker2</span> <span class="o">=</span> <span class="s">''</span><span class="p">,</span> <span class="s">''</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
    <span class="n">tmp_pal</span> <span class="o">=</span> <span class="n">text</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># pure palindrome
</span>    <span class="k">if</span> <span class="n">text</span> <span class="o">==</span> <span class="n">tmp_pal</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">continue</span>

    <span class="c1"># similar palindrome or not
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">tmp_pal</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> 
            <span class="n">checker1</span> <span class="o">=</span> <span class="n">checker1</span> <span class="o">+</span> <span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># remove original text's char
</span>            <span class="n">checker2</span> <span class="o">=</span> <span class="n">checker2</span> <span class="o">+</span> <span class="n">tmp_pal</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># remove reversed text's char
</span>            <span class="k">break</span>
        <span class="n">checker1</span> <span class="o">+=</span> <span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">checker2</span> <span class="o">+=</span> <span class="n">tmp_pal</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">checker1</span> <span class="o">==</span> <span class="n">checker1</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">checker2</span> <span class="o">==</span> <span class="n">checker2</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">print</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><code class="language-plaintext highlighter-rouge">💡 idea</code></h3>

<ul>
  <li><strong>1)  슬라이싱을 이용한 풀이</strong>
    <ul>
      <li><strong>원본과 슬라이싱으로 뒤집은 문자열을 철자 하나 하나 비교 (문자열 길이 및 시간 제한 때문에 이중 루프는 불가)</strong>
        <ul>
          <li><strong><code class="language-plaintext highlighter-rouge">linear search</code> 하면서, 처음으로 다른 철자가 등장하는 지점을 찾아 해당 문자를 제거, 제거는 두가지 케이스 발생</strong>
            <ul>
              <li><strong>원본의 철자를 제거하는 경우</strong></li>
              <li><strong>역본의 철자를 제거하는 경우</strong></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><strong>두가지 케이스 중에서 하나라도 만족한다면 유사 팰린드롬으로 판정</strong></li>
    </ul>
  </li>
</ul>

<p>시간압박이 있는 상황에서 슬라이딩 윈도우과 포인터 혼합 방식을 깔끔하게 구현하는 것이 생각보다 쉽지 않아서, 직관적으로 코드를 빠르게 만들 수 있는 <strong><code class="language-plaintext highlighter-rouge">슬라이싱 대조</code></strong> 방식을 선택하게 되었다. 혼합 방식에 비해 덜 엘레강스하고 느리지만, 훨씬 직관적인 풀이라고 생각한다.</p>

<p>철자 제거할 때 주의할 점은 원본과 역본 케이스 모두 고려해야 한다는 점이다. 둘 중 하나만 고려하면 반례에 걸리는게 생긴다. 필자는 처음에 무지성으로 역본의고 철자만 제거하는 방식으로 코드를 서술했다가 예제 입력 3번째 문자열에 의해 원본 역시 고려해야 함을 깨닫고 수정하게 되었다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="String Handle" /><summary type="html"><![CDATA[백준 17609번 회문 풀이]]></summary></entry><entry><title type="html">👩‍💻💵 [baekjoon] 11501번: 주식</title><link href="http://localhost:4000/algorithm/baekjoon-11501" rel="alternate" type="text/html" title="👩‍💻💵 [baekjoon] 11501번: 주식" /><published>2023-08-29T00:00:00+09:00</published><updated>2023-08-30T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/baekjoon_11501</id><content type="html" xml:base="http://localhost:4000/algorithm/baekjoon-11501"><![CDATA[<h3 id="️solution"><code class="language-plaintext highlighter-rouge">🖍️ solution</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="s">"""
[시간]
1) 14:10 ~ 14:34
[요약]
1) 주식을 '하나' 사기/원하는 만큼 가지고 있는 주식을 팔기/아무것도 안하기
    - 날 별로 주식의 가격을 알려주었을 때, 최대 이익이 얼마나 되는지 계산하는 프로그램 작성
[전략]
1) max() 이용해 문제 해결
    - max - 현재 ≥ 0: 사기
    - max - 현재 ≤ 0: 팔기
    =&gt; 시간 초과 때문에 문제 해결 불가
2) 리스트 역순으로 접근
"""</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())):</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">price_list</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">()),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span>
    <span class="n">price_list</span><span class="p">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="n">max_price</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">price_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="err"> </span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">profit</span> <span class="o">=</span> <span class="n">max_price</span> <span class="o">-</span> <span class="n">price_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">profit</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">profit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_price</span> <span class="o">=</span> <span class="n">price_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><code class="language-plaintext highlighter-rouge">💡 idea</code></h3>

<ul>
  <li><strong>1) 리스트 역순으로 뒤집고 <code class="language-plaintext highlighter-rouge">linear search</code></strong>
    <ul>
      <li><strong>입력값의 크기와 시간 제한상 이중 루프 이상 처리 불가</strong></li>
      <li><strong>구간에서 최대값과 현재 가격 비교</strong>
        <ul>
          <li><strong>양수면 result에 반영</strong></li>
          <li><strong>음수면 반영하지 않고, 구간의 최대값을 현재 가격으로 변경</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="String Handle" /><summary type="html"><![CDATA[백준 11501번 주식 풀이]]></summary></entry><entry><title type="html">👩‍💻🔠 [baekjoon] 1969번: DNA</title><link href="http://localhost:4000/algorithm/baekjoon-1969" rel="alternate" type="text/html" title="👩‍💻🔠 [baekjoon] 1969번: DNA" /><published>2023-08-28T00:00:00+09:00</published><updated>2023-08-29T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/baekjoon_1969</id><content type="html" xml:base="http://localhost:4000/algorithm/baekjoon-1969"><![CDATA[<h3 id="️solution"><code class="language-plaintext highlighter-rouge">🖍️ solution</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="s">"""
[시간]
1) 20:00 ~ 20:30

[요약]
1) DNA를 이루는 뉴클레오티드의 첫글자를 따서 표현, 종류는 4가지
    - A, T, G, C
2)  N개의 길이 M인 DNA가 주어지면 Hamming Distance의 합이 가장 작은 DNA S를 구하기
    - Hamming Distance: 각 위치의 뉴클오티드 문자가 다른 것의 개수
    =&gt; 자기 자신을 제외한 나머지 모든 원소와 Hamming Distance를 구하고 총합이 가장 작은 아이를 리턴해라
"""</span>
<span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">dna</span> <span class="o">=</span> <span class="p">[</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="n">result</span><span class="p">,</span> <span class="n">char_list</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]</span>  <span class="c1"># for append char, count
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">tmp</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">dna</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
    <span class="n">rank_counter</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">counter</span><span class="p">.</span><span class="n">most_common</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>  <span class="c1"># - 붙인 정렬 조건은 현재 정렬 기준과 반대로
</span>    <span class="n">result</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">counter</span><span class="p">.</span><span class="n">values</span><span class="p">())</span> <span class="o">-</span> <span class="n">rank_counter</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># counting
</span>    <span class="n">char_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">rank_counter</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># append char
</span>
<span class="k">print</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">char_list</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><code class="language-plaintext highlighter-rouge">💡 idea</code></h3>

<ul>
  <li><strong>1)  <code class="language-plaintext highlighter-rouge">linear search</code> 하면서 한 개라도 철자가 다른 자리수 찾기</strong>
    <ul>
      <li><strong>빈도수가 가장 높은 철자를 해당 자리의 문자로 결정, <code class="language-plaintext highlighter-rouge">collections.Counter</code> 이용</strong>
        <ul>
          <li><strong>최빈값이 여러개인 상황 (사전식 우선)</strong>
            <ul>
              <li><strong>다중 정렬 사용해 최빈값 &amp; 사전식 정렬 동시 적용</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>문제 풀이에 필요한 아이디어보다 다중 정렬 사용법을 정확히 아는 것이 해결에 더 중요했던 문제다. 코드 주석에 써있는대로 <code class="language-plaintext highlighter-rouge">-</code> 붙인 조건은 현재 정렬 기준과 반대로 정렬할 수 있다. 이걸 모르면 해결하기 꽤나 까다로운 문제라고 생각한다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="String Handle" /><summary type="html"><![CDATA[백준 1969번 괄호 풀이]]></summary></entry><entry><title type="html">👩‍💻🔠 [baekjoon] 12891번: DNA 비밀번호</title><link href="http://localhost:4000/algorithm/baekjoon-12891" rel="alternate" type="text/html" title="👩‍💻🔠 [baekjoon] 12891번: DNA 비밀번호" /><published>2023-08-28T00:00:00+09:00</published><updated>2023-08-29T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/baekjoon_12891</id><content type="html" xml:base="http://localhost:4000/algorithm/baekjoon-12891"><![CDATA[<h3 id="️solution"><code class="language-plaintext highlighter-rouge">🖍️ solution</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">deque</span>

<span class="s">"""
[시간]
1) 21:30 ~ 22:00

[요약]
1) DNA 문자열: A, C, G, T로만 구성된 문자열
    =&gt; DNA 문자열의 일부를 뽑아 비밀번호로 사용
    =&gt; 추출 기준은 서로 다른 문자의 개수가 특정 개수 이상 등장해야 함
    =&gt; 만들 수 있는 비밀번호 종류, 추출된 위치가 다르면 문자열이 같아도 다른 비밀번호로 취급
[전략]
1) collections.Counter 사용
    - 처음 슬라이딩 부분까지만 계산
"""</span>
<span class="n">S</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">dna</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
<span class="n">chars</span> <span class="o">=</span> <span class="p">[</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'G'</span><span class="p">,</span> <span class="s">'T'</span><span class="p">]</span>
<span class="n">result</span><span class="p">,</span> <span class="n">minimal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">chars</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">split</span><span class="p">())))}</span>

<span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">dna</span><span class="p">[:</span><span class="n">P</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">P</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">counter</span><span class="p">[</span><span class="n">dna</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">P</span><span class="p">]]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">counter</span><span class="p">[</span><span class="n">dna</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">checker</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">chars</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">counter</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minimal</span><span class="p">[</span><span class="n">char</span><span class="p">]:</span>
            <span class="n">checker</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="n">checker</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><code class="language-plaintext highlighter-rouge">💡 idea</code></h3>

<ul>
  <li><strong>1)  Sliding Window 사용</strong>
    <ul>
      <li><strong>개별 윈도우에 포함된 철자의 개수를 세어 기준치를 넘기는지 대조</strong>
        <ul>
          <li><strong><code class="language-plaintext highlighter-rouge">Time Complexity</code> 고려해, <code class="language-plaintext highlighter-rouge">collections.Counter</code>는 처음 윈도우에 한 번 사용</strong>
            <ul>
              <li><strong><code class="language-plaintext highlighter-rouge">Input</code>이 백만까지라서 모든 윈도우에 <code class="language-plaintext highlighter-rouge">Counter</code> 적용하면 <code class="language-plaintext highlighter-rouge">O(n^2)</code>으로 시간 초과 발생할 가능성 있음</strong></li>
            </ul>
          </li>
          <li><strong>이후 윈도우를 옮기면서 변화되는 철자의 개수만 수정</strong>
            <ul>
              <li><strong>맨 앞의 철자에 대한 개수를 한 개 빼주고, 앞으로 추가될 철자의 개수를 하나 늘려준다</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>비밀번호라고 판정하는 기준이 특정 철자의 개수라는 점에 유의해, 슬라이딩 윈도우를 변형하면 시간 초과되지 않고 문제를 해결할 수 있다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="String Handle" /><summary type="html"><![CDATA[백준 12891번 DNA 비밀번호 풀이]]></summary></entry><entry><title type="html">👩‍💻🔠 [baekjoon] 1254번: 팰린드롬 만들기</title><link href="http://localhost:4000/algorithm/baekjoon-1254" rel="alternate" type="text/html" title="👩‍💻🔠 [baekjoon] 1254번: 팰린드롬 만들기" /><published>2023-08-24T00:00:00+09:00</published><updated>2023-08-25T02:00:00+09:00</updated><id>http://localhost:4000/algorithm/baekjoon_1254</id><content type="html" xml:base="http://localhost:4000/algorithm/baekjoon-1254"><![CDATA[<h3 id="️solution"><code class="language-plaintext highlighter-rouge">🖍️ solution</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="s">"""
[풀이 시간]
1) 17:00 ~ 17:30

[요약]
1) 규완이가 적어놓고 간 문자열 S에 0개 이상의 문자를 문자열 뒤에 추가해서 팰린드롬을 만들려고 한다.
    - 가능한 짧은 문자열을 추가해 펠린드롬을 만들고 싶음
[전략]
1) 그냥 무식 단순 루프 돌리기
"""</span>
<span class="n">text</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
<span class="n">result</span><span class="p">,</span> <span class="n">slicer</span> <span class="o">=</span> <span class="mi">99999</span><span class="p">,</span> <span class="mi">1</span>

<span class="c1"># input is palindrome
</span><span class="k">if</span> <span class="n">text</span> <span class="o">==</span> <span class="n">text</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)):</span>
        <span class="n">tmp_text</span> <span class="o">=</span> <span class="n">text</span> <span class="o">+</span> <span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tmp_text</span> <span class="o">==</span> <span class="n">tmp_text</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_text</span><span class="p">)</span>
            <span class="k">break</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="idea"><code class="language-plaintext highlighter-rouge">💡 idea</code></h3>

<ul>
  <li><strong>1)  주어진 입력의 하위 시퀀스를 입력에 덧붙여 팰린드롬 여부 판단</strong>
    <ul>
      <li><strong>추가 시퀀스를 최소한으로 사용하는게 목적이라 1글자짜리부터 시작</strong>
        <ul>
          <li><strong>짧은 시퀀스부터 루프를 시작했기 때문에, 팰린드롬으로 판정되는 순간 루프 종료</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>좀 예쁘게 풀어보고 싶었으나, 아이디어가 딱히 떠오르지 않아 무식하게 루프를 돌렸다.</p>]]></content><author><name>qcqced</name><email>qcqced123@gmail.com</email></author><category term="Algorithm" /><category term="Python" /><category term="Codeing Test" /><category term="Algorithm" /><category term="Baekjoon" /><category term="String Handle" /><summary type="html"><![CDATA[백준 1254번 괄호 풀이]]></summary></entry></feed>