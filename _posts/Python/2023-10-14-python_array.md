---
title: "👨‍💻🐍 [Python] List & Tuple"
excerpt: "List, Tuple에 대한 이해"
permalink: "/python/list_tuple"
toc: true  # option for table of contents
toc_sticky: true  # option for table of content
categories:
  - Python
tags:
  - Python
  - array
  - list
  - tuple
  - list comprehension
  - CS
  
last_modified_at: 2023-10-14T12:00:00-05:00
---

### **`🗂️ Concept of Array in Python`**

C, C++, Java 같은 언어를 배울 때 가장 먼저 배우는 자료구조는 바로 배열이다. 그러나 파이썬을 배울 때는 조금 양상이 다르다. 배열이라는 표현의 자료구조는 언급도 없고 리스트, 튜플, 딕셔너리와 같은 형태의 자료구조에 대해서만 배우게 된다. 그렇다면 파이썬에 배열은 없는 것일까?? 

반은 맞고 반은 틀린 질문이라고 할 수 있다. 엄밀하게 말하면 앞에 나열한 언어들과 동일한 개념의 배열은 파이썬에 존재하지 않는다. 앞의 언어에서 배열이란 컨테이너 안에 값을 직접 담는 형태로 사용되지만, 순수한 파이썬의 배열은 값을 직접 담지 않고, 값의 래퍼런스를 담는 형태로 사용된다. 다시 말해 컨테이너에 값 대신 값이 위치한 곳의 주소를 담는다는 것이다. 덕분에 파이썬은 배열 형태의 자료구조에 데이터를 입력할 때, `type casting` 에서 자유롭다. 그래서 배열을 선언할 때 미리 배열의 자료형을 선언해줄 필요가 없는 것이다. 

하지만 단점도 명확하다. 값 대신 주소를 담기 때문에 배열의 특정 위치값에 접근하려면 한단계를 더 거쳐야 하는 것이다. 주소를 갖고 있기 때문에, 물리 메모리 상에서 다닥다닥 붙어 있을 필요가 사라지고, 물리 메모리 공간 여기 저기에 흩어져 있다. 결국 다닥다닥 서로 붙어 있는 다른 언어의 배열보다 동작 속도는 필연적으로 느릴 수 밖에 없다. 배열의 동작 속도를 높이기 위해 넘파이나, 파이토치, 텐서플로와 같은 수학 연산 프레임워크는 C/C++의 배열을 파이썬 API로 호출하는 형식을 사용하고 있다. 덕분에 순수 파이썬 배열 자료구조보다 훨씬 빠른 동작속도를 자랑한다. 

여기까지 파이썬의 배열에 해당되는 자료구조에 대한 공통적인 특징에 대해서 살펴보았다. 파이썬에서 배열 역할을 하는 자료구조는 무엇이 있을까?? 바로 리스트와 튜플인데, 리스트는 `mutable(dynamic) array`, 튜플은 `immutable(static) array` 의 역할을 한다. 리스트는 수정이 가능한 배열, 튜플은 선언 이후 수정이 불가한 배열이라고 생각하면 된다. 덕분에 객체 내부에 내장된 매직 메서드에 차이가 생긴다. 

전자는 수정 사항을 반영해야 하기 때문에 `Resize()` 연산을 위해 별도의 매직 메서드가 구현되어 있으며, 이를 위해 현재 리스트의 길이 정보를 리스트 내부에 저장한다. 한편, 같은 크기의 데이터를 각각 리스트, 튜플에 넣더라도 리스트의 메모리가 더 크게 잡히게 된다. 그 이유는 `mutable` 한 특성을 고려해 인터프리터가 메모리 요청을 위해 커널과 커뮤니케이션 하는 횟수를 줄이기 위해 여유분까지 추가해두기 때문이다. 

반면 튜플은 선언 시점에 고정되기 때문에 굳이 런타임 때 커널에 메모리를 요청할 필요가 없다. 따라서 운영체제를 거치지 않기 때문에 리스트보다 빠르다. 또한 크기가 20 이하의 튜플이라면 최대 2만개까지는 래퍼런싱이 풀려도 `python gc(메모리 관리)` 가 곧바로 삭제하지 않고 캐시에 저장해둔다. 때문에 같은 크기의 튜플이 다시 필요해지면 메모리를 새로이 할당할 필요 없이 저장되어 있던 튜플을 재활용할 수 있어서 훨씬 효율적이다. 리스트 경우처럼 인터프리터가 운영체제에 메모리를 구걸할 필요가 없기 때문에 튜플의 생성 및 할당 속도가 훨씬 빨라진다. 

따라서 저장하려는 데이터의 특성(가변, 불변)을 잘 파악해 자료구조를 선택하는 것이 파이썬 코드의 성능 개선에 매우 중요하다. 이제부터는 리스트와 튜플 각각에 대한 특성을 살펴보자.

### **`⭐️ Features of list`**

앞서 리스트는 `array + resize()` 이라고 언급했다. 그렇다면 리스트가 동적 속성을 어떻게 구현하고 있는지 살펴보자. 리스트는 동적 배열이라고 이름 붙었지만 사실 진짜 실시간으로 배열의 크기가 증가하는 것은 아니다. 튜플과 마찬가지로 선언 시점에 특정한 크기에 맞는 공간을 할당 받는다. 다만 이후 수정될 것을 고려해 같은 데이터라도 좀 더 큰 공간을 할당 받을 뿐이다. 만약 어떤 입력 $A$에 대해서 튜플이 $N$의 공간을 할당 받는다면, 같은 입력에 대해 리스트는 $M (M >N)$의 공간을 할당 받는 것이다. 만약 데이터가 추가될 때, 리스트의 전체 공간 크기를 점진적으로 늘리지 않고 남은 공간($M-N)$에 할당만 하다가, $N==M$이 되는 시점에 더 이상 추가하지 않고 크기가 $M$보다 큰 새로운 리스트를 메모리에 할당한다. 그 다음 기존 리스트를 그대로 복사해 **새롭게 할당한 리스트에 복사**한 뒤, 래퍼런싱이 사라진 이전 리스트는 `python gc` 가 삭제한다.

```python
""" Time Consuming """
>>> %timeit [[i*j for j in range(10000)] for i in range(10000)]
3.85 s ± 44.5 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

>>> %timeit t = []
>>> for i in range(10000):
>>>     for j in range(10000):
>>>         t.append(i*j)
13.3 ns ± 0.0774 ns per loop (mean ± std. dev. of 7 runs, 100,000,000 loops each)

""" Memory Consuming """
>>> %memit [[i*j for j in range(10000)] for i in range(10000)]
peak memory: 4323.73 MiB, increment: 3161.28 MiB

>>>  %memit t = []
>>>  for i in range(10000):
>>>     for j in range(10000):
>>>         t.append(i*j)
peak memory: 1297.91 MiB, increment: 0.02 MiB
```

정리하면, 리스트는 실시간으로 배열 크기를 증가시키는게 아니라, 생성할 때 필요한 양보다 일부러 좀 더 많이 땡겨놓고 데이터를 계속 추가 하다가 빈공간이 없으면 더 큰 공간에 리스트를 새롭게 할당해 동적인 속성을 구현한다. 

따라서 이미 선언된 리스트(특히 꽉찬)에 `append()` 를 통해 데이터를 추가하게 되면 메모리 재할당이 지속적으로 일어나 메모리도 많이 잡아먹고 생성 시간도 매우 느려지게 된다. 이것이 파이썬에서 `list comprehension` 사용을 권장하는 이유다.

### **`⭐️ Features of tuple`**
