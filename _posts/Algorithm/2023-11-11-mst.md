---
title: "ğŸ—‚ï¸ Graph Theory 5: MST with Kruskal & Prim"
excerpt: "MST with Kruskal & Prim Algorithm"
permalink: "/algorithm/mst"
toc: true  # option for table of contents
toc_sticky: true  # option for table of content
categories:
  - Algorithm
tags:
  - Python
  - Codeing Test
  - Algorithm
  - MST
  - Kruskal
  - Prim
last_modified_at: 2023-11-11T12:00:00-05:00
---

### `ğŸ¡Â Spanning Tree`

ê·¸ë˜í”„ ë‚´ë¶€ì— í¬í•¨ëœ ëª¨ë“  ë…¸ë“œë¥¼ í¬í•¨í•˜ëŠ” íŠ¸ë¦¬ë¥¼ ì˜ë¯¸í•œë‹¤. ëª¨ë“  ì •ì ì„ í¬í•¨í•˜ê¸´ í•˜ì§€ë§Œ ê·¼ë³¸ì€ íŠ¸ë¦¬ë¼ì„œ ì‚¬ì´í´ì´ ë°œìƒí•˜ë©´ ì•ˆë˜ë©°, ìµœì†Œì˜ ê°„ì„ ì„ ì‚¬ìš©í•´ ëª¨ë“  ë…¸ë“œë¥¼ ì—°ê²°í•´ì•¼ í•œë‹¤. ë”°ë¼ì„œ `Spanning Tree` ì˜ ê°„ì„  ê°œìˆ˜ëŠ” `ë…¸ë“œ ê°œìˆ˜-1`ì— í•´ë‹¹í•œë‹¤.

### `ğŸ’µÂ Minimum Spanning Tree`

ê·¸ë˜í”„ ìƒì—ì„œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì—¬ëŸ¬ `Spanning Tree` ì¤‘ì—ì„œ ê°„ì„ ë“¤ì˜ ê°€ì¤‘ì¹˜ í•©ì´ ìµœì†Œì¸ íŠ¸ë¦¬ë¥¼ ì˜ë¯¸í•œë‹¤. `MST`ë¥¼ êµ¬í˜„í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì€ ëŒ€í‘œì ìœ¼ë¡œ `Kruskal`, `Prim`ì•Œê³ ë¦¬ì¦˜ì´ ìˆë‹¤. ì „ìì˜ ì‹œê°„ ë³µì¡ë„ëŠ” `O(ElogE)`, í›„ìëŠ” ê¸°ë³¸ì ìœ¼ë¡œ `O(N^2)`ì´ë¼ì„œ ë…¸ë“œì— ë¹„í•´ ê°„ì„  ê°œìˆ˜ê°€ ì ì€ í¬ì†Œ ê·¸ë˜í”„ì˜ ê²½ìš°ëŠ” Kruskalì„, ë…¸ë“œì— ë¹„í•´ ê°„ì„ ì´ ë§ì€ ë°€ì§‘ ê·¸ë˜í”„ì˜ ê²½ìš°ëŠ” Primì„ ì‚¬ìš©í•˜ëŠ”ê²Œ ì‹œê°„ ë³µì¡ë„ ì¸¡ë©´ì—ì„œ ìœ ë¦¬í•˜ë‹¤. í•œí¸, Primì€ êµ¬í˜„ì‹œì— ì„ íƒí•˜ëŠ” ìë£Œêµ¬ì¡°ì— ë”°ë¼ì„œ ì‹œê°„ ë³µì¡ë„ë¥¼ ìµœì í™”í•  ìˆ˜ ìˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ ê°œë³„ ì•Œê³ ë¦¬ì¦˜ì— ëŒ€í•œ ì„¤ëª…ì—ì„œ ë‹¤ë£¨ë„ë¡ í•˜ê² ë‹¤. 

### `ğŸƒÂ Kruskal Algorithm (ê°„ì„  ì„ íƒ)`

ê·¸ë¦¬ë””í•˜ê²Œ ê·¸ë˜í”„ì˜ ëª¨ë“  ì •ì ì„ ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ì—°ê²°í•˜ëŠ” ë°©ë²•ì´ë‹¤. êµ¬ì²´ì ìœ¼ë¡œëŠ” ê°œë³„ ì‹œì ì—ì„œ ì‚¬ì´í´ì„ ì´ë£¨ì§€ ì•Šìœ¼ë©´ì„œ ìµœì†Œ ë¹„ìš©ì¸ ê°„ì„ ì„ ê²½ë¡œë¡œ ì„ íƒí•œë‹¤. ê·¸ë¦¬ë””ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ê¸° ë•Œë¬¸ì— ì´ì „ ê²°ê³¼, ë¯¸ë˜ ê²°ê³¼ë¥¼ ê³ ë ¤í•˜ì§€ ì•Šê³  í˜„ì¬ ìµœì†Œ ë¹„ìš©ì´ ë˜ëŠ” ê°„ì„ ë§Œì„ ì„ íƒí•œë‹¤. ì•Œê³ ë¦¬ì¦˜ì˜ êµ¬ì²´ì ì¸ ë™ì‘ ê³¼ì •ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

- 1) ê·¸ë˜í”„ì˜ ê°„ì„ ë“¤ì„ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬, ê°€ì¤‘ì¹˜ ê¸°ì¤€
- 2) ì‚¬ì´í´ì„ ë°œìƒì‹œí‚¤ëŠ”ì§€ ì—¬ë¶€ë¥¼ ì²´í¬í•˜ë©´ì„œ ìˆœì„œëŒ€ë¡œ ì„ íƒ
    - ê°€ì¥ ë‚®ì€ ê°€ì¤‘ì¹˜ë¶€í„° ì ‘ê·¼í•´ ì²´í¬
    - ì‚¬ì´í´ ë°œìƒ Xë¼ë©´ ì„ íƒ
- 3) ì„ íƒí•œ ê°„ì„ ì„ `MST`ì§‘í•©ì— ì¶”ê°€

ì‚¬ì´í´ì„ ë°œìƒì‹œí‚¤ëŠ”ì§€ ì—¬ë¶€ë¥¼ ì²´í¬í•˜ëŠ” ë¶€ë¶„ì´ êµ¬í˜„í•  ë•Œ ê¹Œë‹¤ë¡œìš¸ ìˆ˜ ìˆëŠ”ë°, Union-Find ì•Œê³ ë¦¬ì¦˜ì„ ë„ì…í•˜ë©´ ìˆ˜ì›”í•˜ê²Œ ë§Œë“¤ì–´ ë‚¼ ìˆ˜ ìˆë‹¤. Union-Findë¥¼ ë„ì…í•œ Kruskal Algorithmì„ Python ì½”ë“œë¡œ ì‘ì„±í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```python
""" kruskal algorithm example: baekjoon 1043 """

import sys

def find(arr: list, x: int) -> int:
    """ method for finding root node """
    if arr[x] != x:
        arr[x] = find(arr, arr[x])
    return arr[x]

def union(arr: list, x: int, y: int):
    """ method for union-find """
    x = find(arr, x)
    y = find(arr, y)
    if x < y:
        arr[y] = x
    else:
        arr[x] = y

N = int(sys.stdin.readline())  # number of nodes
M = int(sys.stdin.readline())  # number of edges
graph, parent = [], [0]*(N+1)

# 0-0) ê°„ì„  ì—°ê²° ì •ë³´ ì´ˆê¸°í™”, ì •ë ¬
for _ in range(M):
    src, end, cost = map(int, sys.stdin.readline().split())
    graph.append((cost, src, end))
graph.sort()

# 0-1) ì—°ê²° ì •ë³´ ì´ˆê¸°í™”
for i in range(1, N+1):
    parent[i] = i

# 1) Kruskal Algorithm
result = 0
for j in range(M):
    weight, start, final = graph[j]
    if find(parent, start) != find(parent, final):
        union(parent, start, final)
        result += weight

print(result)
```

find ë©”ì„œë“œëŠ” ì…ë ¥í•œ ë…¸ë“œì˜ ë£¨íŠ¸ ë…¸ë“œë¥¼ ì°¾ì•„ ë°˜í™˜í•œë‹¤. ì´ê²ƒì„ í™œìš©í•´ ì„œë¡œ ë‹¤ë¥¸ ë…¸ë“œê°€ ê°™ì€ ì§‘í•©(íŠ¸ë¦¬)ì— ì†í•˜ëŠ”ì§€ ì†ì‰½ê²Œ íŒì •í•  ìˆ˜ ìˆìœ¼ë©° ì´ê²ƒì€ ë°”ê¿” ìƒê°í•´ë³´ë©´ ì„ íƒëœ ë‘ ë…¸ë“œê°€ ì‚¬ì´í´ì„ ë°œìƒì‹œí‚¤ëŠ”ì§€ ì—¬ë¶€ë¥¼ ì•Œì•„ ë‚¼ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì´ë‹¤. ë§Œì•½ ë‘ ë…¸ë“œê°€ ê°™ì€ ë£¨íŠ¸ ë…¸ë“œê°’ì„ ê°–ëŠ”ë‹¤ë©´, ê²°êµ­ ê°™ì€ ì§‘í•©(íŠ¸ë¦¬)ì— ì†í•œë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•˜ë©°, ì´ê²ƒì€ ì‚¬ì´í´ì„ ìœ ë°œí•˜ê²Œ ë˜ëŠ” ê²ƒì´ë‹¤. ë”°ë¼ì„œ ì‚¬ì´í´ì„ ìœ ë°œí•˜ëŠ” ì •ì ì€ ì„ íƒí•˜ì§€ ì•Šìœ¼ë©°, íŠ¸ë¦¬ì˜ ì„±ì§ˆì„ ìœ ì§€í•  ìˆ˜ ìˆëŠ” ë…¸ë“œë¥¼ ì„ íƒí•´ `union` ì—°ì‚°ì— ëŒ€ì…í•œë‹¤.

### `ğŸ”´Â Prim Algorithm (ì •ì  ì„ íƒ)`

íŠ¹ì • ì •ì ì—ì„œ ì‹œì‘í•´ì„œ ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ê°„ì„ ë“¤ ìˆœì„œëŒ€ë¡œ íŠ¸ë¦¬ë¥¼ í™•ì¥í•´ë‚˜ê°€ëŠ” ë°©ë²•ì´ë‹¤. ì‹œì‘ì ì„ ì§€ì •í•œë‹¤ëŠ” ì ì—ì„œ ë‹¤ìµìŠ¤íŠ¸ë¼ì™€ ìœ ì‚¬í•˜ë©°, ê°„ì„ ì˜ ìˆ«ìê°€ ë§ì€ ë°€ì§‘ ê·¸ë˜í”„ ìƒí™©ì—ì„œ `Kruskal`ë³´ë‹¤ ë¹ ë¥´ë‹¤. êµ¬ì²´ì ì¸ ë™ì‘ ë°©ì‹ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

- **1) ì„ íƒ ë…¸ë“œë¥¼ MST ì§‘í•©ì— ì¶”ê°€**
- **2) MST ì§‘í•©ì— í¬í•¨ëœ ë…¸ë“œë“¤ì— ì¸ì ‘í•œ ì •ì ë“¤ íƒìƒ‰**
    - **ì‚¬ì´í´ ë°œìƒ ì—¬ë¶€ í™•ì¸**
        - **ì‚¬ì´í´ ë°œìƒ X: ìµœì†Œ ê°€ì¤‘ì¹˜ì˜ ê°„ì„ ì„ ì„ íƒ**
- **3) ì „ì²´ ê°„ì„ ì˜ ê°œìˆ˜ê°€ N-1ê°œê°€ ë  ë•Œê¹Œì§€, 1 & 2 ê³¼ì •  `Iteration`**

ê¸°ë³¸ì ìœ¼ë¡œëŠ” `O(N^2)`ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ê¸°ë¡í•œë‹¤. í•˜ì§€ë§Œ ìë£Œêµ¬ì¡° ìµœì í™”ì— ë”°ë¼ì„œ `Kruskal`ê³¼ ë¹„ìŠ·í•œ ì‹œê°„ë³µì¡ë„ì¸ `O(ElogE)`ì •ë„ë¡œê¹Œì§€ ë§Œë“¤ì–´ ë‚¼ ìˆ˜ ìˆë‹¤. ìµœì†Œ í™ì •ë ¬ê³¼ ìš°ì„ ìˆœìœ„ íë¥¼ ì´ìš©í•˜ë©´ ëœë‹¤. í™ì •ë ¬ì„ ì´ìš©í•´ ê·¸ë˜í”„ ì—°ê²° ì •ë³´ë¥¼ ê°€ì¤‘ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ì„ í•œ ë’¤ì—, ì‚¬ì´í´ì„ ë°œìƒì‹œí‚¤ì§€ ì•ŠëŠ” ì¸ì ‘ ë…¸ë“œë¥¼ ì„ íƒí•˜ë„ë¡ ë§Œë“ ë‹¤.

```python
""" prim algorithm example: baekjoon 1197 """

import sys, heapq
from typing import List
"""
[í’€ì´]
1) Prim with ìš°ì„ ìˆœìœ„ í (í™)
    - ì‹œì‘ì  ì„ íƒ, MST ì§‘í•©ì— ì¶”ê°€
    - MST ì§‘í•©ì˜ ë…¸ë“œë“¤ì— ì¸ì ‘í•œ ëª¨ë“  ì •ì  íƒìƒ‰
        - ì‚¬ì´í´ ë°œìƒ ì—¬ë¶€ í™•ì¸: ë°©ë¬¸ ì—¬ë¶€ë¡œ íŒì •
        - ì‚¬ì´í´ ë°œìƒ X: ìµœì†Œ ê°€ì¤‘ì¹˜ ê°„ì„  ì„ íƒ (heapifyë¥¼ í†µí•´ ê°œë³„ ë…¸ë“œë§ˆë‹¤ ê°„ì„ ë“¤ì„ ê°€ì¤‘ì¹˜ ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬)
"""

def prim(grid: List[List], visit: List[bool], start: int) -> int:
    visit[start] = True
    tmp = grid[start]  # ì„ íƒëœ ë…¸ë“œì— ëŒ€í•œ ëª¨ë“  ì¸ì ‘ ê°„ì„  ì¶”ì¶œ
    heapq.heapify(tmp)  # ì´ë¯¸ ìƒì„±ë˜ì–´ ìˆëŠ” ìë£Œêµ¬ì¡°ì— ëŒ€í•´ì„œëŠ” heapq.heapifyë¥¼ ì‚¬ìš©í•˜ë©´ í™ ì„±ì§ˆì„ ë§Œì¡±í•˜ë„ë¡ í•  ìˆ˜ ìˆë‹¤
    mst, total = [], 0
    while tmp:
        weight, u, v = heapq.heappop(tmp)
        if not visit[v]:  # ë¯¸ë°©ë¬¸ ë…¸ë“œë¡œì˜ ê°„ì„ ë§Œ ì„ íƒí•˜ëŠ” ë°©ì‹ìœ¼ë¡œ, ì‚¬ì´í´ ë°œìƒ ì—¬ë¶€ íŒì •í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì„ êµ¬í˜„
            visit[v] = True
            mst.append((u, v))
            total += weight
            for edge in graph[v]:
                if not visit[edge[2]]:
                    heapq.heappush(tmp, edge)
    return total

def solution():
    result = prim(graph, visited, 1)  # ì‹œì‘ ë…¸ë“œë¥¼ ì–´ë–¤ ê²ƒìœ¼ë¡œ ì„¤ì •í•´ë„ ìƒê´€ ì—†ìŒ
    print(result)

if __name__ == "__main__":
    sys.setrecursionlimit(10**6)
    V, E = map(int, sys.stdin.readline().split())
    graph, visited = [[] for _ in range(V+1)], [False]*(V+1)
    for _ in range(E):
        src, end, cost = map(int, sys.stdin.readline().split())
        graph[src].append([cost, src, end])
        graph[end].append([cost, end, src])
    solution()
```

ì‹œì‘ ì •ì ì€ ì•„ë¬´ê±°ë‚˜ ì„ íƒí•´ë„ ìƒê´€ì—†ë‹¤. ê·¸ë¦¬ê³  ê°€ì¥ ì£¼ëª©í•  ë¶€ë¶„ì€ ë…¸ë“œ ì„ íƒì‹œ ì‚¬ì´í´ ì—¬ë¶€ë¥¼ íŒì •í•˜ëŠ” ë°©ë²•ì„ ì–´ë–»ê²Œ êµ¬í˜„í–ˆëŠ”ê°€ì´ë‹¤. ê°œë³„ ë…¸ë“œì— ëŒ€í•œ ë°©ë¬¸ì—¬ë¶€ë¥¼ ê¸°ë¡í•˜ëŠ” ë°°ì—´ì„ ë”°ë¡œ ìƒì„±í•œ ë’¤, ë°©ë¬¸(í•´ë‹¹ ë…¸ë“œì™€ ì—°ê²°ë˜ëŠ” ê°„ì„  ì„ íƒ)í•  ë•Œ ë§ˆë‹¤ ë°©ë¬¸ ê¸°ë¡ì„ ì €ì¥í•œë‹¤. ê·¸ë¦¬ê³  ë§Œì•½ ì–´ë–¤ ë…¸ë“œë¥¼ ì„ íƒí–ˆì„ ë•Œ, ì´ë¯¸ ë°©ë¬¸í•œ ë…¸ë“œë¼ë©´ í•´ë‹¹ ë…¸ë“œì™€ ì—°ê²°í•˜ëŠ” ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ í˜„ì¬ ê°€ì¥ ìµœì†Œì— í•´ë‹¹í•˜ë”ë¼ë„ ì‚¬ì´í´ì„ ë°œìƒì‹œí‚¤ê¸° ë•Œë¬¸ì— ì„ íƒí•˜ì§€ ì•Šë„ë¡ ì‚¬ì´í´ ì—¬ë¶€ë¥¼ íŒì •í•˜ê²Œ ë§Œë“¤ì—ˆë‹¤.  
`Kruskal`ì²˜ëŸ¼ ì „ì²´ ëª¨ë“  ê°„ì„ ì„ ì•Œê³  ìˆëŠ” ìƒíƒœê°€ ì•„ë‹˜ì—ë„ ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ì˜ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ê²°ê³¼ë¥¼ ë§Œë“¤ì–´ ë‚¼ ìˆ˜ ìˆëŠ” ì´ìœ ëŠ” ë¯¸ë¦¬ ê°œë³„ ë…¸ë“œë³„ ê°„ì„ ë“¤ì„ ê°€ì¤‘ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ í•´ë’€ê¸° ë•Œë¬¸ì´ë‹¤. ì´ê²ƒ ë•Œë¬¸ì— ì§€ì—­ ìµœì ë“¤ì˜ í•©ì´ ì „ì—­ ìµœì ì´ ë˜ì–´ì•¼ í•˜ëŠ” ê·¸ë¦¬ë””ì˜ ì œì•½ ì¡°ê±´ì„ ë§Œì¡±ì‹œí‚¬ ìˆ˜ ìˆê²Œ ëœë‹¤.