---
title: "ðŸ—‚ï¸ Graph Theory 2: Dijkstra"
excerpt: "Dijkstra Algorithm with Priority Queue"
permalink: "/algorithm/dijkstra"
toc: true  # option for table of contents
toc_sticky: true  # option for table of content
categories:
  - Algorithm
tags:
  - Python
  - Codeing Test
  - Algorithm
  - Dijkstra
last_modified_at: 2023-11-11T12:00:00-05:00
---

### `ðŸ“š Dijkstra`

ë‹¤ìµìŠ¤íŠ¸ë¼ ìµœë‹¨ ê²½ë¡œ ë¬¸ì œëŠ” ê·¸ëž˜í”„ ìžë£Œ êµ¬ì¡°ì—ì„œ ì—¬ëŸ¬ ê°œì˜ ë…¸ë“œê°€ ì£¼ì–´ì¡Œì„ ë•Œ, íŠ¹ì •í•œ ë…¸ë“œ(ì‹œìž‘ì )ì—ì„œ íŠ¹ì •í•œ ë…¸ë“œ(ë„ì°©ì )ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•´ì£¼ëŠ” ì•Œê³ ë¦¬ì¦˜ì„ ì„¤ê³„í•´ì•¼ í•œë‹¤. íŠ¹ížˆ ë‹¤ìµìŠ¤íŠ¸ë¼ëŠ” `ìŒì˜ ê°„ì„ `ì´ ì—†ì„ ë•Œ ì •ìƒì ìœ¼ë¡œ ë™ìž‘í•˜ë©°, ìœ í–¥ & ë¬´í–¥ì„ ê°€ë¦¬ì§€ ì•Šê³  ì ìš©í•  ìˆ˜ ìžˆë‹¤. ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì˜ ë™ìž‘ì„ ê¸°ìˆ í•˜ë©´ ì•„ëž˜ì™€ ê°™ë‹¤.

- **1) ì¶œë°œ ë…¸ë“œ ì„¤ì •**
- **2) ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸” ì´ˆê¸°í™”(ì¶œë°œ ë…¸ë“œ ê°’ì€ 0)**
- **3) ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì¤‘ì—ì„œ í˜„ìž¬ ê°€ìž¥ ê°€ê¹Œìš´ ë…¸ë“œë¥¼ ì„ íƒ(ìµœë‹¨ ê±°ë¦¬ ë…¸ë“œ)**
- **4) ì„ íƒëœ ë…¸ë“œë¡œë¶€í„° íŒŒìƒë˜ëŠ” ë‹¤ë¥¸ ê²½ë¡œê°’ ì—…ë°ì´íŠ¸**
- **5) ëª¨ë“  ë…¸ë“œì— ëŒ€í•œ ê³„ì‚° ëë‚  ë•Œê¹Œì§€ 3~4ë²ˆ ë°˜ë³µ**

ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì„ ì„¤ê³„í•˜ëŠ” ë°©ë²•ì€ í¬ê²Œ ë‘ê°€ì§€ê°€ ìžˆë‹¤. ë¨¼ì € 3ë²ˆì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ 1) ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸”ì„ ë§¤ë²ˆ ì„ í˜• íƒìƒ‰í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜,  2) ì„ í˜• íƒìƒ‰ ëŒ€ì‹ ì— íž™ ì •ë ¬ì„ ì´ìš©í•´ ê°€ìž¥ ê°€ê¹Œìš´ ë…¸ë“œë¥¼ ì„ íƒí•˜ëŠ” ë°©ì‹ì´ ìžˆë‹¤. 1ë²ˆì˜ ê²½ìš° `O(V^2)` ê°€ ë˜ì–´ ìž…ë ¥ ë…¸ë“œê°€ 1000ê°œë§Œ ë„˜ì–´ê°€ë„ ì‹œê°„ ì´ˆê³¼ë¥¼ ë‹¹í•˜ê¸° ë•Œë¬¸ì—, 2ë²ˆì˜ ê²½ìš°ë¡œ ì†ŒìŠ¤ ì½”ë“œë¥¼ ìž‘ì„±í•˜ëŠ” ê²Œ ë°”ëžŒì§í•˜ë‹¤. ì½”ë“œ ì˜ˆì‹œëŠ” ì•„ëž˜ì™€ ê°™ë‹¤.

```python
""" Dijkstra implementation """

import sys
import heapq
from typing import List

def dijkstra(x: int, distance: List[int]) -> None:
    h = []
    heapq.heappush(h, (distance[x], x))
    while h:
        min_cost, node = heapq.heappop(h)
        # ë°©ë¬¸í•œ ë…¸ë“œ ì²˜ë¦¬: costë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë‹¤ìŒ ë…¸ë“œë¥¼ ì„ ì •, ë”°ë¼ì„œ costê°€ distance[node]ë³´ë‹¤ í¬ë‹¤ë©´ ì´ë¯¸ ë°©ë¬¸ í–ˆë˜ ë…¸ë“œë¡œ ë³¼ ìˆ˜ ìžˆìŒ
        if min_cost > distance[node]:
            continue
        for i in graph[node]:
            cost = min_cost + i[0]
            if cost < distance[i[1]]:
                distance[i[1]] = cost
                heapq.heappush(h, (cost, i[1]))

V, E = map(int, sys.stdin.readline().split())
src = int(sys.stdin.readline())

# 1) init graph
graph, costs = [[] for _ in range(V+1)], [float('inf')] * (V+1)
costs[src] = 0
for _ in range(E):
    u, v, weight = map(int, sys.stdin.readline().split())
    graph[u].append((weight, v))

dijkstra(src, costs)
for i in range(1, V+1):
    print(costs[i] if costs[i] != float('inf') else 'INF')
```